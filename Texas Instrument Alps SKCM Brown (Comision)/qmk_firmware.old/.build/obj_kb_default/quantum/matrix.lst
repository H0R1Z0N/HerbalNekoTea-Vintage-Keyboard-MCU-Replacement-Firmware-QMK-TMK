   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.matrix_init_user,"ax",@progbits
  12               		.weak	matrix_init_user
  14               	matrix_init_user:
  15               	.LFB14:
  16               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012 Jun Wako
   3:quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:quantum/matrix.c **** 
   5:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:quantum/matrix.c **** (at your option) any later version.
   9:quantum/matrix.c **** 
  10:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:quantum/matrix.c **** GNU General Public License for more details.
  14:quantum/matrix.c **** 
  15:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:quantum/matrix.c **** */
  18:quantum/matrix.c **** #include <stdint.h>
  19:quantum/matrix.c **** #include <stdbool.h>
  20:quantum/matrix.c **** #if defined(__AVR__)
  21:quantum/matrix.c **** #include <avr/io.h>
  22:quantum/matrix.c **** #endif
  23:quantum/matrix.c **** #include "wait.h"
  24:quantum/matrix.c **** #include "print.h"
  25:quantum/matrix.c **** #include "debug.h"
  26:quantum/matrix.c **** #include "util.h"
  27:quantum/matrix.c **** #include "matrix.h"
  28:quantum/matrix.c **** #include "timer.h"
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  34:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  35:quantum/matrix.c **** #endif
  36:quantum/matrix.c **** 
  37:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  38:quantum/matrix.c ****     static uint16_t debouncing_time;
  39:quantum/matrix.c ****     static bool debouncing = false;
  40:quantum/matrix.c **** #endif
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  43:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  44:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  45:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  46:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  47:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  48:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  49:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  50:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  51:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  52:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  53:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  54:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  55:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  56:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  57:quantum/matrix.c **** #endif
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** #ifdef MATRIX_MASKED
  60:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  61:quantum/matrix.c **** #endif
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** 
  66:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  67:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** static matrix_row_t matrix_raw[MATRIX_ROWS];
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #else // ROW2COL
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  17               		.loc 1 108 29 view -0
  18               		.cfi_startproc
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 109:quantum/matrix.c **** }
  23               		.loc 1 109 1 view .LVU1
  24               	/* epilogue start */
  25 0000 0895      		ret
  26               		.cfi_endproc
  27               	.LFE14:
  29               		.set	matrix_init_user.localalias,matrix_init_user
  30               		.section	.text.matrix_init_kb,"ax",@progbits
  31               		.weak	matrix_init_kb
  33               	matrix_init_kb:
  34               	.LFB12:
  98:quantum/matrix.c ****     matrix_init_user();
  35               		.loc 1 98 27 view -0
  36               		.cfi_startproc
  37               	/* prologue: function */
  38               	/* frame size = 0 */
  39               	/* stack size = 0 */
  40               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  41               		.loc 1 99 5 view .LVU3
  42 0000 0C94 0000 		jmp matrix_init_user
  43               	.LVL0:
  44               		.cfi_endproc
  45               	.LFE12:
  47               		.section	.text.matrix_init_quantum,"ax",@progbits
  48               		.weak	matrix_init_quantum
  50               	matrix_init_quantum:
  51               	.LFB10:
  88:quantum/matrix.c ****     matrix_init_kb();
  52               		.loc 1 88 32 view -0
  53               		.cfi_startproc
  54               	/* prologue: function */
  55               	/* frame size = 0 */
  56               	/* stack size = 0 */
  57               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  58               		.loc 1 89 5 view .LVU5
  59 0000 0C94 0000 		jmp matrix_init_kb
  60               	.LVL1:
  61               		.cfi_endproc
  62               	.LFE10:
  64               		.section	.text.matrix_scan_user,"ax",@progbits
  65               		.weak	matrix_scan_user
  67               	matrix_scan_user:
  68               	.LFB31:
  69               		.cfi_startproc
  70               	/* prologue: function */
  71               	/* frame size = 0 */
  72               	/* stack size = 0 */
  73               	.L__stack_usage = 0
  74               	/* epilogue start */
  75 0000 0895      		ret
  76               		.cfi_endproc
  77               	.LFE31:
  79               		.section	.text.matrix_scan_kb,"ax",@progbits
  80               		.weak	matrix_scan_kb
  82               	matrix_scan_kb:
  83               	.LFB13:
 103:quantum/matrix.c ****     matrix_scan_user();
  84               		.loc 1 103 27 view -0
  85               		.cfi_startproc
  86               	/* prologue: function */
  87               	/* frame size = 0 */
  88               	/* stack size = 0 */
  89               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  90               		.loc 1 104 5 view .LVU7
  91 0000 0C94 0000 		jmp matrix_scan_user
  92               	.LVL2:
  93               		.cfi_endproc
  94               	.LFE13:
  96               		.section	.text.matrix_scan_quantum,"ax",@progbits
  97               		.weak	matrix_scan_quantum
  99               	matrix_scan_quantum:
 100               	.LFB11:
  93:quantum/matrix.c ****     matrix_scan_kb();
 101               		.loc 1 93 32 view -0
 102               		.cfi_startproc
 103               	/* prologue: function */
 104               	/* frame size = 0 */
 105               	/* stack size = 0 */
 106               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 107               		.loc 1 94 5 view .LVU9
 108 0000 0C94 0000 		jmp matrix_scan_kb
 109               	.LVL3:
 110               		.cfi_endproc
 111               	.LFE11:
 113               		.section	.text.matrix_rows,"ax",@progbits
 114               	.global	matrix_rows
 116               	matrix_rows:
 117               	.LFB16:
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 118               		.loc 1 116 27 view -0
 119               		.cfi_startproc
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 124               		.loc 1 117 5 view .LVU11
 118:quantum/matrix.c **** }
 125               		.loc 1 118 1 is_stmt 0 view .LVU12
 126 0000 88E0      		ldi r24,lo8(8)
 127               	/* epilogue start */
 128 0002 0895      		ret
 129               		.cfi_endproc
 130               	.LFE16:
 132               		.section	.text.matrix_cols,"ax",@progbits
 133               	.global	matrix_cols
 135               	matrix_cols:
 136               	.LFB17:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 137               		.loc 1 121 27 is_stmt 1 view -0
 138               		.cfi_startproc
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 0 */
 142               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 143               		.loc 1 122 5 view .LVU14
 123:quantum/matrix.c **** }
 144               		.loc 1 123 1 is_stmt 0 view .LVU15
 145 0000 80E1      		ldi r24,lo8(16)
 146               	/* epilogue start */
 147 0002 0895      		ret
 148               		.cfi_endproc
 149               	.LFE17:
 151               		.section	.text.matrix_init,"ax",@progbits
 152               	.global	matrix_init
 154               	matrix_init:
 155               	.LFB18:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #else
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 156               		.loc 1 149 24 is_stmt 1 view -0
 157               		.cfi_startproc
 158               	/* prologue: function */
 159               	/* frame size = 0 */
 160               	/* stack size = 0 */
 161               	.L__stack_usage = 0
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 162               		.loc 1 153 9 view .LVU17
 163               		.loc 1 153 15 is_stmt 0 view .LVU18
 164 0000 85B7      		in r24,0x35
 165 0002 8068      		ori r24,lo8(-128)
 166 0004 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 167               		.loc 1 154 9 is_stmt 1 view .LVU19
 168               		.loc 1 154 15 is_stmt 0 view .LVU20
 169 0006 85B7      		in r24,0x35
 170 0008 8068      		ori r24,lo8(-128)
 171 000a 85BF      		out 0x35,r24
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #else // ROW2COL
 162:quantum/matrix.c ****     unselect_cols();
 172               		.loc 1 162 5 is_stmt 1 view .LVU21
 173               	.LBB21:
 174               	.LBI21:
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_raw[i] = 0;
 170:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 171:quantum/matrix.c ****     }
 172:quantum/matrix.c **** 
 173:quantum/matrix.c ****     matrix_init_quantum();
 174:quantum/matrix.c **** }
 175:quantum/matrix.c **** 
 176:quantum/matrix.c **** uint8_t matrix_scan(void)
 177:quantum/matrix.c **** {
 178:quantum/matrix.c **** 
 179:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Set row, read cols
 182:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 183:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 184:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 185:quantum/matrix.c **** 
 186:quantum/matrix.c ****             if (matrix_changed) {
 187:quantum/matrix.c ****                 debouncing = true;
 188:quantum/matrix.c ****                 debouncing_time = timer_read();
 189:quantum/matrix.c ****             }
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** #       else
 192:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 193:quantum/matrix.c **** #       endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     }
 196:quantum/matrix.c **** 
 197:quantum/matrix.c **** #else // ROW2COL
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // Set col, read rows
 200:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 201:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 202:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 203:quantum/matrix.c ****             if (matrix_changed) {
 204:quantum/matrix.c ****                 debouncing = true;
 205:quantum/matrix.c ****                 debouncing_time = timer_read();
 206:quantum/matrix.c ****             }
 207:quantum/matrix.c **** #       else
 208:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 209:quantum/matrix.c **** #       endif
 210:quantum/matrix.c **** 
 211:quantum/matrix.c ****     }
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #endif
 214:quantum/matrix.c **** 
 215:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 216:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 217:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 218:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 219:quantum/matrix.c ****             }
 220:quantum/matrix.c ****             debouncing = false;
 221:quantum/matrix.c ****         }
 222:quantum/matrix.c **** #   endif
 223:quantum/matrix.c **** 
 224:quantum/matrix.c ****     matrix_scan_quantum();
 225:quantum/matrix.c ****     return 1;
 226:quantum/matrix.c **** }
 227:quantum/matrix.c **** 
 228:quantum/matrix.c **** bool matrix_is_modified(void)
 229:quantum/matrix.c **** {
 230:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 231:quantum/matrix.c ****     if (debouncing) return false;
 232:quantum/matrix.c **** #endif
 233:quantum/matrix.c ****     return true;
 234:quantum/matrix.c **** }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c **** inline
 237:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 238:quantum/matrix.c **** {
 239:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** inline
 243:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 244:quantum/matrix.c **** {
 245:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 246:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 247:quantum/matrix.c **** #ifdef MATRIX_MASKED
 248:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 249:quantum/matrix.c **** #else
 250:quantum/matrix.c ****     return matrix[row];
 251:quantum/matrix.c **** #endif
 252:quantum/matrix.c **** }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c **** void matrix_print(void)
 255:quantum/matrix.c **** {
 256:quantum/matrix.c ****     print_matrix_header();
 257:quantum/matrix.c **** 
 258:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 259:quantum/matrix.c ****         phex(row); print(": ");
 260:quantum/matrix.c ****         print_matrix_row(row);
 261:quantum/matrix.c ****         print("\n");
 262:quantum/matrix.c ****     }
 263:quantum/matrix.c **** }
 264:quantum/matrix.c **** 
 265:quantum/matrix.c **** uint8_t matrix_key_count(void)
 266:quantum/matrix.c **** {
 267:quantum/matrix.c ****     uint8_t count = 0;
 268:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 269:quantum/matrix.c ****         count += matrix_bitpop(i);
 270:quantum/matrix.c ****     }
 271:quantum/matrix.c ****     return count;
 272:quantum/matrix.c **** }
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** 
 276:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 277:quantum/matrix.c **** 
 278:quantum/matrix.c **** static void init_cols(void)
 279:quantum/matrix.c **** {
 280:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 281:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 283:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 284:quantum/matrix.c ****     }
 285:quantum/matrix.c **** }
 286:quantum/matrix.c **** 
 287:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 288:quantum/matrix.c **** {
 289:quantum/matrix.c ****     // Store last value of row prior to reading
 290:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 291:quantum/matrix.c **** 
 292:quantum/matrix.c ****     // Clear data in matrix row
 293:quantum/matrix.c ****     current_matrix[current_row] = 0;
 294:quantum/matrix.c **** 
 295:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 296:quantum/matrix.c ****     select_row(current_row);
 297:quantum/matrix.c ****     wait_us(30);
 298:quantum/matrix.c **** 
 299:quantum/matrix.c ****     // For each col...
 300:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 301:quantum/matrix.c **** 
 302:quantum/matrix.c ****         // Select the col pin to read (active low)
 303:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 304:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 305:quantum/matrix.c **** 
 306:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 307:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 308:quantum/matrix.c ****     }
 309:quantum/matrix.c **** 
 310:quantum/matrix.c ****     // Unselect row
 311:quantum/matrix.c ****     unselect_row(current_row);
 312:quantum/matrix.c **** 
 313:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 314:quantum/matrix.c **** }
 315:quantum/matrix.c **** 
 316:quantum/matrix.c **** static void select_row(uint8_t row)
 317:quantum/matrix.c **** {
 318:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 320:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 321:quantum/matrix.c **** }
 322:quantum/matrix.c **** 
 323:quantum/matrix.c **** static void unselect_row(uint8_t row)
 324:quantum/matrix.c **** {
 325:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 327:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 328:quantum/matrix.c **** }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c **** static void unselect_rows(void)
 331:quantum/matrix.c **** {
 332:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 335:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 336:quantum/matrix.c ****     }
 337:quantum/matrix.c **** }
 338:quantum/matrix.c **** 
 339:quantum/matrix.c **** #else // ROW2COL
 340:quantum/matrix.c **** 
 341:quantum/matrix.c **** static void init_rows(void)
 342:quantum/matrix.c **** {
 343:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 344:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 346:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 347:quantum/matrix.c ****     }
 348:quantum/matrix.c **** }
 349:quantum/matrix.c **** 
 350:quantum/matrix.c **** static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col)
 351:quantum/matrix.c **** {
 352:quantum/matrix.c ****     bool matrix_changed = false;
 353:quantum/matrix.c **** 
 354:quantum/matrix.c ****     // Select col and wait for col selecton to stabilize
 355:quantum/matrix.c ****     select_col(current_col);
 356:quantum/matrix.c ****     wait_us(30);
 357:quantum/matrix.c **** 
 358:quantum/matrix.c ****     // For each row...
 359:quantum/matrix.c ****     for(uint8_t row_index = 0; row_index < MATRIX_ROWS; row_index++)
 360:quantum/matrix.c ****     {
 361:quantum/matrix.c **** 
 362:quantum/matrix.c ****         // Store last value of row prior to reading
 363:quantum/matrix.c ****         matrix_row_t last_row_value = current_matrix[row_index];
 364:quantum/matrix.c **** 
 365:quantum/matrix.c ****         // Check row pin state
 366:quantum/matrix.c ****         if ((_SFR_IO8(row_pins[row_index] >> 4) & _BV(row_pins[row_index] & 0xF)) == 0)
 367:quantum/matrix.c ****         {
 368:quantum/matrix.c ****             // Pin LO, set col bit
 369:quantum/matrix.c ****             current_matrix[row_index] |= (ROW_SHIFTER << current_col);
 370:quantum/matrix.c ****         }
 371:quantum/matrix.c ****         else
 372:quantum/matrix.c ****         {
 373:quantum/matrix.c ****             // Pin HI, clear col bit
 374:quantum/matrix.c ****             current_matrix[row_index] &= ~(ROW_SHIFTER << current_col);
 375:quantum/matrix.c ****         }
 376:quantum/matrix.c **** 
 377:quantum/matrix.c ****         // Determine if the matrix changed state
 378:quantum/matrix.c ****         if ((last_row_value != current_matrix[row_index]) && !(matrix_changed))
 379:quantum/matrix.c ****         {
 380:quantum/matrix.c ****             matrix_changed = true;
 381:quantum/matrix.c ****         }
 382:quantum/matrix.c ****     }
 383:quantum/matrix.c **** 
 384:quantum/matrix.c ****     // Unselect col
 385:quantum/matrix.c ****     unselect_col(current_col);
 386:quantum/matrix.c **** 
 387:quantum/matrix.c ****     return matrix_changed;
 388:quantum/matrix.c **** }
 389:quantum/matrix.c **** 
 390:quantum/matrix.c **** static void select_col(uint8_t col)
 391:quantum/matrix.c **** {
 392:quantum/matrix.c ****     uint8_t pin = col_pins[col];
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 394:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 395:quantum/matrix.c **** }
 396:quantum/matrix.c **** 
 397:quantum/matrix.c **** static void unselect_col(uint8_t col)
 398:quantum/matrix.c **** {
 399:quantum/matrix.c ****     uint8_t pin = col_pins[col];
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 401:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 402:quantum/matrix.c **** }
 403:quantum/matrix.c **** 
 404:quantum/matrix.c **** static void unselect_cols(void)
 175               		.loc 1 404 13 view .LVU22
 405:quantum/matrix.c **** {
 406:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 176               		.loc 1 406 5 view .LVU23
 177               	.LBB22:
 178               		.loc 1 406 9 view .LVU24
 179               	.LVL4:
 180               		.loc 1 406 26 view .LVU25
 181 000c A0E0      		ldi r26,lo8(col_pins)
 182 000e B0E0      		ldi r27,hi8(col_pins)
 183 0010 40E0      		ldi r20,lo8(col_pins+16)
 184 0012 50E0      		ldi r21,hi8(col_pins+16)
 185               	.LBB23:
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 408:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 186               		.loc 1 408 38 is_stmt 0 view .LVU26
 187 0014 61E0      		ldi r22,lo8(1)
 188 0016 70E0      		ldi r23,0
 189               	.LVL5:
 190               	.L10:
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 191               		.loc 1 407 9 is_stmt 1 view .LVU27
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 192               		.loc 1 407 17 is_stmt 0 view .LVU28
 193 0018 8D91      		ld r24,X+
 194               	.LVL6:
 195               		.loc 1 408 9 is_stmt 1 view .LVU29
 196               		.loc 1 408 34 is_stmt 0 view .LVU30
 197 001a E82F      		mov r30,r24
 198 001c E295      		swap r30
 199 001e EF70      		andi r30,lo8(15)
 200 0020 F0E0      		ldi r31,0
 201 0022 91A1      		ldd r25,Z+33
 202               		.loc 1 408 38 view .LVU31
 203 0024 8F70      		andi r24,lo8(15)
 204               	.LVL7:
 205               		.loc 1 408 38 view .LVU32
 206 0026 9B01      		movw r18,r22
 207 0028 00C0      		rjmp 2f
 208               		1:
 209 002a 220F      		lsl r18
 210               		2:
 211 002c 8A95      		dec r24
 212 002e 02F4      		brpl 1b
 213               		.loc 1 408 34 view .LVU33
 214 0030 822F      		mov r24,r18
 215 0032 8095      		com r24
 216 0034 8923      		and r24,r25
 217 0036 81A3      		std Z+33,r24
 218               	.LVL8:
 409:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 219               		.loc 1 409 9 is_stmt 1 view .LVU34
 220               		.loc 1 409 34 is_stmt 0 view .LVU35
 221 0038 82A1      		ldd r24,Z+34
 222 003a 822B      		or r24,r18
 223 003c 82A3      		std Z+34,r24
 224               	.LBE23:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 225               		.loc 1 406 42 is_stmt 1 view .LVU36
 226               	.LVL9:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 227               		.loc 1 406 26 view .LVU37
 228 003e 4A17      		cp r20,r26
 229 0040 5B07      		cpc r21,r27
 230 0042 01F4      		brne .L10
 231 0044 A0E0      		ldi r26,lo8(row_pins)
 232 0046 B0E0      		ldi r27,hi8(row_pins)
 233               	.LVL10:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 234               		.loc 1 406 26 is_stmt 0 view .LVU38
 235 0048 40E0      		ldi r20,lo8(row_pins+8)
 236 004a 50E0      		ldi r21,hi8(row_pins+8)
 237               	.LBE22:
 238               	.LBE21:
 239               	.LBB24:
 240               	.LBB25:
 241               	.LBB26:
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 242               		.loc 1 345 38 view .LVU39
 243 004c 61E0      		ldi r22,lo8(1)
 244 004e 70E0      		ldi r23,0
 245               	.L11:
 246               	.LVL11:
 344:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 247               		.loc 1 344 9 is_stmt 1 view .LVU40
 344:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 248               		.loc 1 344 17 is_stmt 0 view .LVU41
 249 0050 8D91      		ld r24,X+
 250               	.LVL12:
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 251               		.loc 1 345 9 is_stmt 1 view .LVU42
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 252               		.loc 1 345 34 is_stmt 0 view .LVU43
 253 0052 E82F      		mov r30,r24
 254 0054 E295      		swap r30
 255 0056 EF70      		andi r30,lo8(15)
 256 0058 F0E0      		ldi r31,0
 257 005a 91A1      		ldd r25,Z+33
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 258               		.loc 1 345 38 view .LVU44
 259 005c 8F70      		andi r24,lo8(15)
 260               	.LVL13:
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 261               		.loc 1 345 38 view .LVU45
 262 005e 9B01      		movw r18,r22
 263 0060 00C0      		rjmp 2f
 264               		1:
 265 0062 220F      		lsl r18
 266               		2:
 267 0064 8A95      		dec r24
 268 0066 02F4      		brpl 1b
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 269               		.loc 1 345 34 view .LVU46
 270 0068 822F      		mov r24,r18
 271 006a 8095      		com r24
 272 006c 8923      		and r24,r25
 273 006e 81A3      		std Z+33,r24
 274               	.LVL14:
 346:quantum/matrix.c ****     }
 275               		.loc 1 346 9 is_stmt 1 view .LVU47
 346:quantum/matrix.c ****     }
 276               		.loc 1 346 34 is_stmt 0 view .LVU48
 277 0070 82A1      		ldd r24,Z+34
 278 0072 822B      		or r24,r18
 279 0074 82A3      		std Z+34,r24
 280               	.LBE26:
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 281               		.loc 1 343 42 is_stmt 1 view .LVU49
 282               	.LVL15:
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 283               		.loc 1 343 26 view .LVU50
 284 0076 4A17      		cp r20,r26
 285 0078 5B07      		cpc r21,r27
 286 007a 01F4      		brne .L11
 287               	.LBE25:
 288               	.LBE24:
 289               	.LBB27:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 290               		.loc 1 168 19 is_stmt 0 view .LVU51
 291 007c 80E1      		ldi r24,lo8(16)
 292 007e E0E0      		ldi r30,lo8(matrix)
 293 0080 F0E0      		ldi r31,hi8(matrix)
 294 0082 DF01      		movw r26,r30
 295               	.LVL16:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 296               		.loc 1 168 19 view .LVU52
 297 0084 982F      		mov r25,r24
 298               		0:
 299 0086 1D92      		st X+,__zero_reg__
 300 0088 9A95      		dec r25
 301 008a 01F4      		brne 0b
 170:quantum/matrix.c ****     }
 302               		.loc 1 170 30 view .LVU53
 303 008c E0E0      		ldi r30,lo8(matrix_debouncing)
 304 008e F0E0      		ldi r31,hi8(matrix_debouncing)
 305 0090 DF01      		movw r26,r30
 306               		0:
 307 0092 1D92      		st X+,__zero_reg__
 308 0094 8A95      		dec r24
 309 0096 01F4      		brne 0b
 170:quantum/matrix.c ****     }
 310               		.loc 1 170 30 view .LVU54
 311               	.LBE27:
 173:quantum/matrix.c **** }
 312               		.loc 1 173 5 is_stmt 1 view .LVU55
 313 0098 0C94 0000 		jmp matrix_init_quantum
 314               	.LVL17:
 315               		.cfi_endproc
 316               	.LFE18:
 318               		.section	.text.matrix_scan,"ax",@progbits
 319               	.global	matrix_scan
 321               	matrix_scan:
 322               	.LFB19:
 177:quantum/matrix.c **** 
 323               		.loc 1 177 1 view -0
 324               		.cfi_startproc
 325 0000 3F92      		push r3
 326               	.LCFI0:
 327               		.cfi_def_cfa_offset 3
 328               		.cfi_offset 3, -2
 329 0002 4F92      		push r4
 330               	.LCFI1:
 331               		.cfi_def_cfa_offset 4
 332               		.cfi_offset 4, -3
 333 0004 5F92      		push r5
 334               	.LCFI2:
 335               		.cfi_def_cfa_offset 5
 336               		.cfi_offset 5, -4
 337 0006 6F92      		push r6
 338               	.LCFI3:
 339               		.cfi_def_cfa_offset 6
 340               		.cfi_offset 6, -5
 341 0008 7F92      		push r7
 342               	.LCFI4:
 343               		.cfi_def_cfa_offset 7
 344               		.cfi_offset 7, -6
 345 000a 8F92      		push r8
 346               	.LCFI5:
 347               		.cfi_def_cfa_offset 8
 348               		.cfi_offset 8, -7
 349 000c 9F92      		push r9
 350               	.LCFI6:
 351               		.cfi_def_cfa_offset 9
 352               		.cfi_offset 9, -8
 353 000e AF92      		push r10
 354               	.LCFI7:
 355               		.cfi_def_cfa_offset 10
 356               		.cfi_offset 10, -9
 357 0010 BF92      		push r11
 358               	.LCFI8:
 359               		.cfi_def_cfa_offset 11
 360               		.cfi_offset 11, -10
 361 0012 CF92      		push r12
 362               	.LCFI9:
 363               		.cfi_def_cfa_offset 12
 364               		.cfi_offset 12, -11
 365 0014 DF92      		push r13
 366               	.LCFI10:
 367               		.cfi_def_cfa_offset 13
 368               		.cfi_offset 13, -12
 369 0016 EF92      		push r14
 370               	.LCFI11:
 371               		.cfi_def_cfa_offset 14
 372               		.cfi_offset 14, -13
 373 0018 FF92      		push r15
 374               	.LCFI12:
 375               		.cfi_def_cfa_offset 15
 376               		.cfi_offset 15, -14
 377 001a 0F93      		push r16
 378               	.LCFI13:
 379               		.cfi_def_cfa_offset 16
 380               		.cfi_offset 16, -15
 381 001c 1F93      		push r17
 382               	.LCFI14:
 383               		.cfi_def_cfa_offset 17
 384               		.cfi_offset 17, -16
 385 001e CF93      		push r28
 386               	.LCFI15:
 387               		.cfi_def_cfa_offset 18
 388               		.cfi_offset 28, -17
 389 0020 DF93      		push r29
 390               	.LCFI16:
 391               		.cfi_def_cfa_offset 19
 392               		.cfi_offset 29, -18
 393 0022 00D0      		rcall .
 394 0024 00D0      		rcall .
 395               	.LCFI17:
 396               		.cfi_def_cfa_offset 23
 397 0026 CDB7      		in r28,__SP_L__
 398 0028 DEB7      		in r29,__SP_H__
 399               	.LCFI18:
 400               		.cfi_def_cfa_register 28
 401               	/* prologue: function */
 402               	/* frame size = 4 */
 403               	/* stack size = 21 */
 404               	.L__stack_usage = 21
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 405               		.loc 1 200 5 view .LVU57
 406               	.LBB45:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 407               		.loc 1 200 10 view .LVU58
 408               	.LVL18:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 409               		.loc 1 200 47 view .LVU59
 410 002a 00E0      		ldi r16,lo8(col_pins)
 411 002c 10E0      		ldi r17,hi8(col_pins)
 412               	.LBE45:
 177:quantum/matrix.c **** 
 413               		.loc 1 177 1 is_stmt 0 view .LVU60
 414 002e 1A82      		std Y+2,__zero_reg__
 415 0030 1982      		std Y+1,__zero_reg__
 416               	.LBB70:
 417               	.LBB46:
 418               	.LBB47:
 419               	.LBB48:
 420               	.LBB49:
 421               	.LBB50:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 422               		.loc 1 393 34 view .LVU61
 423 0032 EE24      		clr r14
 424 0034 E394      		inc r14
 425 0036 F12C      		mov r15,__zero_reg__
 426 0038 90E0      		ldi r25,lo8(matrix_debouncing+16)
 427 003a 692E      		mov r6,r25
 428 003c 90E0      		ldi r25,hi8(matrix_debouncing+16)
 429 003e 792E      		mov r7,r25
 430               	.LBE50:
 431               	.LBE49:
 432               	.LBB52:
 433               	.LBB53:
 378:quantum/matrix.c ****         {
 434               		.loc 1 378 12 view .LVU62
 435 0040 3324      		clr r3
 436 0042 3394      		inc r3
 437               	.LVL19:
 438               	.L20:
 378:quantum/matrix.c ****         {
 439               		.loc 1 378 12 view .LVU63
 440               	.LBE53:
 441               	.LBE52:
 442               	.LBE48:
 443               	.LBE47:
 202:quantum/matrix.c ****             if (matrix_changed) {
 444               		.loc 1 202 13 is_stmt 1 view .LVU64
 445               	.LBB67:
 446               	.LBI47:
 350:quantum/matrix.c **** {
 447               		.loc 1 350 13 view .LVU65
 448               	.LBB65:
 352:quantum/matrix.c **** 
 449               		.loc 1 352 5 view .LVU66
 355:quantum/matrix.c ****     wait_us(30);
 450               		.loc 1 355 5 view .LVU67
 451               	.LBB57:
 452               	.LBI49:
 390:quantum/matrix.c **** {
 453               		.loc 1 390 13 view .LVU68
 454               	.LBB51:
 392:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 455               		.loc 1 392 5 view .LVU69
 392:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 456               		.loc 1 392 13 is_stmt 0 view .LVU70
 457 0044 D801      		movw r26,r16
 458 0046 8D91      		ld r24,X+
 459 0048 8D01      		movw r16,r26
 460               	.LVL20:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 461               		.loc 1 393 5 is_stmt 1 view .LVU71
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 462               		.loc 1 393 30 is_stmt 0 view .LVU72
 463 004a E82F      		mov r30,r24
 464 004c E295      		swap r30
 465 004e EF70      		andi r30,lo8(15)
 466 0050 F0E0      		ldi r31,0
 467 0052 91A1      		ldd r25,Z+33
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 468               		.loc 1 393 34 view .LVU73
 469 0054 8F70      		andi r24,lo8(15)
 470               	.LVL21:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 471               		.loc 1 393 34 view .LVU74
 472 0056 5701      		movw r10,r14
 473 0058 00C0      		rjmp 2f
 474               		1:
 475 005a AA0C      		lsl r10
 476               		2:
 477 005c 8A95      		dec r24
 478 005e 02F4      		brpl 1b
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 479               		.loc 1 393 30 view .LVU75
 480 0060 892F      		mov r24,r25
 481 0062 8A29      		or r24,r10
 482 0064 81A3      		std Z+33,r24
 483               	.LVL22:
 394:quantum/matrix.c **** }
 484               		.loc 1 394 5 is_stmt 1 view .LVU76
 394:quantum/matrix.c **** }
 485               		.loc 1 394 30 is_stmt 0 view .LVU77
 486 0066 82A1      		ldd r24,Z+34
 487 0068 5A2C      		mov r5,r10
 488 006a 5094      		com r5
 489 006c 8521      		and r24,r5
 490 006e 82A3      		std Z+34,r24
 394:quantum/matrix.c **** }
 491               		.loc 1 394 30 view .LVU78
 492               	.LBE51:
 493               	.LBE57:
 356:quantum/matrix.c **** 
 494               		.loc 1 356 5 is_stmt 1 view .LVU79
 495               	.LVL23:
 496               	.LBB58:
 497               	.LBI58:
 498               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2551 2020-10-10 20:33:35Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 499               		.loc 2 255 1 view .LVU80
 500               	.LBB59:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 501               		.loc 2 257 2 view .LVU81
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 502               		.loc 2 261 2 view .LVU82
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 503               		.loc 2 262 2 view .LVU83
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 504               		.loc 2 263 2 view .LVU84
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 505               		.loc 2 273 3 view .LVU85
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 506               		.loc 2 276 2 view .LVU86
 507 0070 B0EA      		ldi r27,lo8(-96)
 508 0072 BA95      	1:	dec r27
 509 0074 01F4      		brne 1b
 510               	.LVL24:
 511               		.loc 2 276 2 is_stmt 0 view .LVU87
 512               	.LBE59:
 513               	.LBE58:
 359:quantum/matrix.c ****     {
 514               		.loc 1 359 5 is_stmt 1 view .LVU88
 515               	.LBB60:
 359:quantum/matrix.c ****     {
 516               		.loc 1 359 9 view .LVU89
 359:quantum/matrix.c ****     {
 517               		.loc 1 359 42 view .LVU90
 518               	.LBB54:
 374:quantum/matrix.c ****         }
 519               		.loc 1 374 56 is_stmt 0 view .LVU91
 520 0076 B701      		movw r22,r14
 521 0078 0980      		ldd r0,Y+1
 522 007a 00C0      		rjmp 2f
 523               		1:
 524 007c 660F      		lsl r22
 525 007e 771F      		rol r23
 526               		2:
 527 0080 0A94      		dec r0
 528 0082 02F4      		brpl 1b
 374:quantum/matrix.c ****         }
 529               		.loc 1 374 42 view .LVU92
 530 0084 4B01      		movw r8,r22
 531 0086 8094      		com r8
 532 0088 9094      		com r9
 533 008a 80E0      		ldi r24,lo8(matrix_debouncing)
 534 008c 90E0      		ldi r25,hi8(matrix_debouncing)
 535 008e 9C83      		std Y+4,r25
 536 0090 8B83      		std Y+3,r24
 537 0092 40E0      		ldi r20,lo8(row_pins)
 538 0094 50E0      		ldi r21,hi8(row_pins)
 539               	.LBE54:
 540               	.LBE60:
 352:quantum/matrix.c **** 
 541               		.loc 1 352 10 view .LVU93
 542 0096 412C      		mov r4,__zero_reg__
 543               	.LVL25:
 544               	.L18:
 545               	.LBB61:
 546               	.LBB55:
 363:quantum/matrix.c **** 
 547               		.loc 1 363 9 is_stmt 1 view .LVU94
 363:quantum/matrix.c **** 
 548               		.loc 1 363 22 is_stmt 0 view .LVU95
 549 0098 AB81      		ldd r26,Y+3
 550 009a BC81      		ldd r27,Y+4
 551 009c 2D91      		ld r18,X+
 552 009e 3D91      		ld r19,X+
 553 00a0 BC83      		std Y+4,r27
 554 00a2 AB83      		std Y+3,r26
 555               	.LVL26:
 366:quantum/matrix.c ****         {
 556               		.loc 1 366 9 is_stmt 1 view .LVU96
 366:quantum/matrix.c ****         {
 557               		.loc 1 366 14 is_stmt 0 view .LVU97
 558 00a4 DA01      		movw r26,r20
 559 00a6 DD90      		ld r13,X+
 560 00a8 AD01      		movw r20,r26
 561               	.LVL27:
 366:quantum/matrix.c ****         {
 562               		.loc 1 366 14 view .LVU98
 563 00aa 8D2D      		mov r24,r13
 564 00ac 8295      		swap r24
 565 00ae 8F70      		andi r24,lo8(15)
 566 00b0 805E      		subi r24,lo8(-(32))
 567 00b2 90E0      		ldi r25,0
 568 00b4 DC01      		movw r26,r24
 569 00b6 8C91      		ld r24,X
 570 00b8 90E0      		ldi r25,0
 366:quantum/matrix.c ****         {
 571               		.loc 1 366 51 view .LVU99
 572 00ba BD2D      		mov r27,r13
 573 00bc BF70      		andi r27,lo8(15)
 366:quantum/matrix.c ****         {
 574               		.loc 1 366 83 view .LVU100
 575 00be 00C0      		rjmp 2f
 576               		1:
 577 00c0 9595      		asr r25
 578 00c2 8795      		ror r24
 579               		2:
 580 00c4 BA95      		dec r27
 581 00c6 02F4      		brpl 1b
 366:quantum/matrix.c ****         {
 582               		.loc 1 366 12 view .LVU101
 583 00c8 80FD      		sbrc r24,0
 584 00ca 00C0      		rjmp .L15
 369:quantum/matrix.c ****         }
 585               		.loc 1 369 13 is_stmt 1 view .LVU102
 369:quantum/matrix.c ****         }
 586               		.loc 1 369 39 is_stmt 0 view .LVU103
 587 00cc C901      		movw r24,r18
 588 00ce 862B      		or r24,r22
 589 00d0 972B      		or r25,r23
 590               	.L16:
 591 00d2 CB80      		ldd r12,Y+3
 592 00d4 DC80      		ldd r13,Y+4
 593 00d6 A2E0      		ldi r26,2
 594 00d8 CA1A      		sub r12,r26
 595 00da D108      		sbc r13,__zero_reg__
 596 00dc D601      		movw r26,r12
 597 00de 8D93      		st X+,r24
 598 00e0 9C93      		st X,r25
 378:quantum/matrix.c ****         {
 599               		.loc 1 378 9 is_stmt 1 view .LVU104
 378:quantum/matrix.c ****         {
 600               		.loc 1 378 12 is_stmt 0 view .LVU105
 601 00e2 2817      		cp r18,r24
 602 00e4 3907      		cpc r19,r25
 603 00e6 01F0      		breq .L17
 604 00e8 4424      		clr r4
 605 00ea 4394      		inc r4
 606               	.LVL28:
 607               	.L17:
 378:quantum/matrix.c ****         {
 608               		.loc 1 378 12 view .LVU106
 609               	.LBE55:
 359:quantum/matrix.c ****     {
 610               		.loc 1 359 66 is_stmt 1 view .LVU107
 359:quantum/matrix.c ****     {
 611               		.loc 1 359 42 view .LVU108
 612 00ec 8B81      		ldd r24,Y+3
 613 00ee 9C81      		ldd r25,Y+4
 614 00f0 6816      		cp r6,r24
 615 00f2 7906      		cpc r7,r25
 616 00f4 01F4      		brne .L18
 617               	.LBE61:
 385:quantum/matrix.c **** 
 618               		.loc 1 385 5 view .LVU109
 619               	.LVL29:
 620               	.LBB62:
 621               	.LBI62:
 397:quantum/matrix.c **** {
 622               		.loc 1 397 13 view .LVU110
 623               	.LBB63:
 399:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 624               		.loc 1 399 5 view .LVU111
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 625               		.loc 1 400 5 view .LVU112
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 626               		.loc 1 400 30 is_stmt 0 view .LVU113
 627 00f6 81A1      		ldd r24,Z+33
 628 00f8 5822      		and r5,r24
 629 00fa 51A2      		std Z+33,r5
 401:quantum/matrix.c **** }
 630               		.loc 1 401 5 is_stmt 1 view .LVU114
 401:quantum/matrix.c **** }
 631               		.loc 1 401 30 is_stmt 0 view .LVU115
 632 00fc 82A1      		ldd r24,Z+34
 633 00fe 8A29      		or r24,r10
 634 0100 82A3      		std Z+34,r24
 401:quantum/matrix.c **** }
 635               		.loc 1 401 30 view .LVU116
 636               	.LBE63:
 637               	.LBE62:
 387:quantum/matrix.c **** }
 638               		.loc 1 387 5 is_stmt 1 view .LVU117
 639               	.LVL30:
 387:quantum/matrix.c **** }
 640               		.loc 1 387 5 is_stmt 0 view .LVU118
 641               	.LBE65:
 642               	.LBE67:
 203:quantum/matrix.c ****                 debouncing = true;
 643               		.loc 1 203 13 is_stmt 1 view .LVU119
 203:quantum/matrix.c ****                 debouncing = true;
 644               		.loc 1 203 16 is_stmt 0 view .LVU120
 645 0102 4420      		tst r4
 646 0104 01F0      		breq .L19
 647               	.LVL31:
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 648               		.loc 1 204 17 is_stmt 1 view .LVU121
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 649               		.loc 1 204 28 is_stmt 0 view .LVU122
 650 0106 3092 0000 		sts debouncing,r3
 205:quantum/matrix.c ****             }
 651               		.loc 1 205 17 is_stmt 1 view .LVU123
 205:quantum/matrix.c ****             }
 652               		.loc 1 205 35 is_stmt 0 view .LVU124
 653 010a 0E94 0000 		call timer_read
 654               	.LVL32:
 205:quantum/matrix.c ****             }
 655               		.loc 1 205 33 view .LVU125
 656 010e 9093 0000 		sts debouncing_time+1,r25
 657 0112 8093 0000 		sts debouncing_time,r24
 658               	.LVL33:
 659               	.L19:
 205:quantum/matrix.c ****             }
 660               		.loc 1 205 33 view .LVU126
 661               	.LBE46:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 662               		.loc 1 200 73 is_stmt 1 discriminator 2 view .LVU127
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 663               		.loc 1 200 47 discriminator 2 view .LVU128
 664 0116 A981      		ldd r26,Y+1
 665 0118 BA81      		ldd r27,Y+2
 666 011a 1196      		adiw r26,1
 667 011c BA83      		std Y+2,r27
 668 011e A983      		std Y+1,r26
 669               	.LVL34:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 670               		.loc 1 200 47 is_stmt 0 discriminator 2 view .LVU129
 671 0120 5097      		sbiw r26,16
 672 0122 01F0      		breq .+2
 673 0124 00C0      		rjmp .L20
 674               	.LBE70:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 675               		.loc 1 216 9 is_stmt 1 view .LVU130
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 676               		.loc 1 216 12 is_stmt 0 view .LVU131
 677 0126 8091 0000 		lds r24,debouncing
 678 012a 8823      		tst r24
 679 012c 01F0      		breq .L22
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 680               		.loc 1 216 28 discriminator 1 view .LVU132
 681 012e 8091 0000 		lds r24,debouncing_time
 682 0132 9091 0000 		lds r25,debouncing_time+1
 683 0136 0E94 0000 		call timer_elapsed
 684               	.LVL35:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 685               		.loc 1 216 24 discriminator 1 view .LVU133
 686 013a 0697      		sbiw r24,6
 687 013c 00F0      		brlo .L22
 688               	.LBB71:
 218:quantum/matrix.c ****             }
 689               		.loc 1 218 27 view .LVU134
 690 013e 80E1      		ldi r24,lo8(16)
 691 0140 E0E0      		ldi r30,lo8(matrix_debouncing)
 692 0142 F0E0      		ldi r31,hi8(matrix_debouncing)
 693 0144 A0E0      		ldi r26,lo8(matrix)
 694 0146 B0E0      		ldi r27,hi8(matrix)
 695               		0:
 696 0148 0190      		ld r0,Z+
 697 014a 0D92      		st X+,r0
 698 014c 8A95      		dec r24
 699 014e 01F4      		brne 0b
 700               	.LBE71:
 220:quantum/matrix.c ****         }
 701               		.loc 1 220 13 is_stmt 1 view .LVU135
 220:quantum/matrix.c ****         }
 702               		.loc 1 220 24 is_stmt 0 view .LVU136
 703 0150 1092 0000 		sts debouncing,__zero_reg__
 704               	.L22:
 224:quantum/matrix.c ****     return 1;
 705               		.loc 1 224 5 is_stmt 1 view .LVU137
 706 0154 0E94 0000 		call matrix_scan_quantum
 707               	.LVL36:
 225:quantum/matrix.c **** }
 708               		.loc 1 225 5 view .LVU138
 226:quantum/matrix.c **** 
 709               		.loc 1 226 1 is_stmt 0 view .LVU139
 710 0158 81E0      		ldi r24,lo8(1)
 711               	/* epilogue start */
 712 015a 0F90      		pop __tmp_reg__
 713 015c 0F90      		pop __tmp_reg__
 714 015e 0F90      		pop __tmp_reg__
 715 0160 0F90      		pop __tmp_reg__
 716 0162 DF91      		pop r29
 717 0164 CF91      		pop r28
 718 0166 1F91      		pop r17
 719 0168 0F91      		pop r16
 720 016a FF90      		pop r15
 721 016c EF90      		pop r14
 722 016e DF90      		pop r13
 723 0170 CF90      		pop r12
 724 0172 BF90      		pop r11
 725 0174 AF90      		pop r10
 726 0176 9F90      		pop r9
 727 0178 8F90      		pop r8
 728 017a 7F90      		pop r7
 729 017c 6F90      		pop r6
 730 017e 5F90      		pop r5
 731 0180 4F90      		pop r4
 732 0182 3F90      		pop r3
 733 0184 0895      		ret
 734               	.LVL37:
 735               	.L15:
 736               	.LBB72:
 737               	.LBB69:
 738               	.LBB68:
 739               	.LBB66:
 740               	.LBB64:
 741               	.LBB56:
 374:quantum/matrix.c ****         }
 742               		.loc 1 374 13 is_stmt 1 view .LVU140
 374:quantum/matrix.c ****         }
 743               		.loc 1 374 39 is_stmt 0 view .LVU141
 744 0186 C901      		movw r24,r18
 745 0188 8821      		and r24,r8
 746 018a 9921      		and r25,r9
 747 018c 00C0      		rjmp .L16
 748               	.LBE56:
 749               	.LBE64:
 750               	.LBE66:
 751               	.LBE68:
 752               	.LBE69:
 753               	.LBE72:
 754               		.cfi_endproc
 755               	.LFE19:
 757               		.section	.text.matrix_is_modified,"ax",@progbits
 758               	.global	matrix_is_modified
 760               	matrix_is_modified:
 761               	.LFB20:
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 762               		.loc 1 229 1 is_stmt 1 view -0
 763               		.cfi_startproc
 764               	/* prologue: function */
 765               	/* frame size = 0 */
 766               	/* stack size = 0 */
 767               	.L__stack_usage = 0
 231:quantum/matrix.c **** #endif
 768               		.loc 1 231 5 view .LVU143
 231:quantum/matrix.c **** #endif
 769               		.loc 1 231 8 is_stmt 0 view .LVU144
 770 0000 9091 0000 		lds r25,debouncing
 234:quantum/matrix.c **** 
 771               		.loc 1 234 1 view .LVU145
 772 0004 81E0      		ldi r24,lo8(1)
 773 0006 8927      		eor r24,r25
 774               	/* epilogue start */
 775 0008 0895      		ret
 776               		.cfi_endproc
 777               	.LFE20:
 779               		.section	.text.matrix_is_on,"ax",@progbits
 780               	.global	matrix_is_on
 782               	matrix_is_on:
 783               	.LVL38:
 784               	.LFB21:
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 785               		.loc 1 238 1 is_stmt 1 view -0
 786               		.cfi_startproc
 787               	/* prologue: function */
 788               	/* frame size = 0 */
 789               	/* stack size = 0 */
 790               	.L__stack_usage = 0
 239:quantum/matrix.c **** }
 791               		.loc 1 239 5 view .LVU147
 239:quantum/matrix.c **** }
 792               		.loc 1 239 19 is_stmt 0 view .LVU148
 793 0000 E82F      		mov r30,r24
 794 0002 F0E0      		ldi r31,0
 795 0004 EE0F      		lsl r30
 796 0006 FF1F      		rol r31
 797               	.LVL39:
 239:quantum/matrix.c **** }
 798               		.loc 1 239 19 view .LVU149
 799 0008 E050      		subi r30,lo8(-(matrix))
 800 000a F040      		sbci r31,hi8(-(matrix))
 239:quantum/matrix.c **** }
 801               		.loc 1 239 43 view .LVU150
 802 000c 81E0      		ldi r24,lo8(1)
 803 000e 90E0      		ldi r25,0
 804 0010 6230      		cpi r22,lo8(2)
 805 0012 00F4      		brsh .L31
 806 0014 80E0      		ldi r24,0
 807               	.L31:
 239:quantum/matrix.c **** }
 808               		.loc 1 239 25 view .LVU151
 809 0016 2081      		ld r18,Z
 810 0018 3181      		ldd r19,Z+1
 811 001a 8223      		and r24,r18
 240:quantum/matrix.c **** 
 812               		.loc 1 240 1 view .LVU152
 813 001c 8170      		andi r24,lo8(1)
 814               	/* epilogue start */
 815 001e 0895      		ret
 816               		.cfi_endproc
 817               	.LFE21:
 819               		.section	.text.matrix_get_row,"ax",@progbits
 820               	.global	matrix_get_row
 822               	matrix_get_row:
 823               	.LVL40:
 824               	.LFB22:
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 825               		.loc 1 244 1 is_stmt 1 view -0
 826               		.cfi_startproc
 827               	/* prologue: function */
 828               	/* frame size = 0 */
 829               	/* stack size = 0 */
 830               	.L__stack_usage = 0
 250:quantum/matrix.c **** #endif
 831               		.loc 1 250 5 view .LVU154
 250:quantum/matrix.c **** #endif
 832               		.loc 1 250 18 is_stmt 0 view .LVU155
 833 0000 E82F      		mov r30,r24
 834 0002 F0E0      		ldi r31,0
 835 0004 EE0F      		lsl r30
 836 0006 FF1F      		rol r31
 837               	.LVL41:
 250:quantum/matrix.c **** #endif
 838               		.loc 1 250 18 view .LVU156
 839 0008 E050      		subi r30,lo8(-(matrix))
 840 000a F040      		sbci r31,hi8(-(matrix))
 252:quantum/matrix.c **** 
 841               		.loc 1 252 1 view .LVU157
 842 000c 8081      		ld r24,Z
 843 000e 9181      		ldd r25,Z+1
 844               	/* epilogue start */
 845 0010 0895      		ret
 846               		.cfi_endproc
 847               	.LFE22:
 849               		.section	.text.matrix_print,"ax",@progbits
 850               	.global	matrix_print
 852               	matrix_print:
 853               	.LFB23:
 255:quantum/matrix.c ****     print_matrix_header();
 854               		.loc 1 255 1 is_stmt 1 view -0
 855               		.cfi_startproc
 856               	/* prologue: function */
 857               	/* frame size = 0 */
 858               	/* stack size = 0 */
 859               	.L__stack_usage = 0
 256:quantum/matrix.c **** 
 860               		.loc 1 256 26 view .LVU159
 258:quantum/matrix.c ****         phex(row); print(": ");
 861               		.loc 1 258 5 view .LVU160
 258:quantum/matrix.c ****         phex(row); print(": ");
 862               		.loc 1 258 10 view .LVU161
 258:quantum/matrix.c ****         phex(row); print(": ");
 863               		.loc 1 258 31 view .LVU162
 864               	/* epilogue start */
 263:quantum/matrix.c **** 
 865               		.loc 1 263 1 is_stmt 0 view .LVU163
 866 0000 0895      		ret
 867               		.cfi_endproc
 868               	.LFE23:
 870               		.section	.text.matrix_key_count,"ax",@progbits
 871               	.global	matrix_key_count
 873               	matrix_key_count:
 874               	.LFB24:
 266:quantum/matrix.c ****     uint8_t count = 0;
 875               		.loc 1 266 1 is_stmt 1 view -0
 876               		.cfi_startproc
 877 0000 0F93      		push r16
 878               	.LCFI19:
 879               		.cfi_def_cfa_offset 3
 880               		.cfi_offset 16, -2
 881 0002 1F93      		push r17
 882               	.LCFI20:
 883               		.cfi_def_cfa_offset 4
 884               		.cfi_offset 17, -3
 885 0004 CF93      		push r28
 886               	.LCFI21:
 887               		.cfi_def_cfa_offset 5
 888               		.cfi_offset 28, -4
 889               	/* prologue: function */
 890               	/* frame size = 0 */
 891               	/* stack size = 3 */
 892               	.L__stack_usage = 3
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 893               		.loc 1 267 5 view .LVU165
 894               	.LVL42:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 895               		.loc 1 268 5 view .LVU166
 896               	.LBB73:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 897               		.loc 1 268 10 view .LVU167
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 898               		.loc 1 268 27 view .LVU168
 899 0006 00E0      		ldi r16,lo8(matrix)
 900 0008 10E0      		ldi r17,hi8(matrix)
 901               	.LBE73:
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 902               		.loc 1 267 13 is_stmt 0 view .LVU169
 903 000a C0E0      		ldi r28,0
 904               	.LVL43:
 905               	.L35:
 906               	.LBB74:
 269:quantum/matrix.c ****     }
 907               		.loc 1 269 9 is_stmt 1 discriminator 3 view .LVU170
 269:quantum/matrix.c ****     }
 908               		.loc 1 269 18 is_stmt 0 discriminator 3 view .LVU171
 909 000c F801      		movw r30,r16
 910 000e 8191      		ld r24,Z+
 911 0010 9191      		ld r25,Z+
 912 0012 8F01      		movw r16,r30
 913               	.LVL44:
 269:quantum/matrix.c ****     }
 914               		.loc 1 269 18 discriminator 3 view .LVU172
 915 0014 0E94 0000 		call bitpop16
 916               	.LVL45:
 269:quantum/matrix.c ****     }
 917               		.loc 1 269 15 discriminator 3 view .LVU173
 918 0018 C80F      		add r28,r24
 919               	.LVL46:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 920               		.loc 1 268 43 is_stmt 1 discriminator 3 view .LVU174
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 921               		.loc 1 268 27 discriminator 3 view .LVU175
 922 001a F0E0      		ldi r31,hi8(matrix+16)
 923 001c 0030      		cpi r16,lo8(matrix+16)
 924 001e 1F07      		cpc r17,r31
 925 0020 01F4      		brne .L35
 926               	.LBE74:
 271:quantum/matrix.c **** }
 927               		.loc 1 271 5 view .LVU176
 272:quantum/matrix.c **** 
 928               		.loc 1 272 1 is_stmt 0 view .LVU177
 929 0022 8C2F      		mov r24,r28
 930               	/* epilogue start */
 931 0024 CF91      		pop r28
 932               	.LVL47:
 272:quantum/matrix.c **** 
 933               		.loc 1 272 1 view .LVU178
 934 0026 1F91      		pop r17
 935 0028 0F91      		pop r16
 936               	.LVL48:
 272:quantum/matrix.c **** 
 937               		.loc 1 272 1 view .LVU179
 938 002a 0895      		ret
 939               		.cfi_endproc
 940               	.LFE24:
 942               		.section	.bss.matrix_debouncing,"aw",@nobits
 945               	matrix_debouncing:
 946 0000 0000 0000 		.zero	16
 946      0000 0000 
 946      0000 0000 
 946      0000 0000 
 947               		.section	.bss.matrix,"aw",@nobits
 950               	matrix:
 951 0000 0000 0000 		.zero	16
 951      0000 0000 
 951      0000 0000 
 951      0000 0000 
 952               		.section	.rodata.col_pins,"a"
 955               	col_pins:
 956 0000 F7F6 F5F4 		.ascii	"\367\366\365\364\363\362\361\360\3070\306`\301\300\227\225"
 956      F3F2 F1F0 
 956      C730 C660 
 956      C1C0 9795 
 957               		.section	.rodata.row_pins,"a"
 960               	row_pins:
 961 0000 3790 9192 		.ascii	"7\220\221\2226543"
 961      3635 3433 
 962               		.section	.bss.debouncing,"aw",@nobits
 965               	debouncing:
 966 0000 00        		.zero	1
 967               		.section	.bss.debouncing_time,"aw",@nobits
 970               	debouncing_time:
 971 0000 0000      		.zero	2
 972               		.text
 973               	.Letext0:
 974               		.file 3 "/usr/avr/include/stdint.h"
 975               		.file 4 "./tmk_core/common/matrix.h"
 976               		.file 5 "./tmk_core/common/util.h"
 977               		.file 6 "./tmk_core/common/timer.h"
 978               		.file 7 "/usr/avr/include/math.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccyz1qU7.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccyz1qU7.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccyz1qU7.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccyz1qU7.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccyz1qU7.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccyz1qU7.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccyz1qU7.s:14     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccyz1qU7.s:14     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias
     /tmp/ccyz1qU7.s:33     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccyz1qU7.s:50     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccyz1qU7.s:67     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccyz1qU7.s:82     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccyz1qU7.s:99     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccyz1qU7.s:116    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccyz1qU7.s:135    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccyz1qU7.s:154    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccyz1qU7.s:955    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccyz1qU7.s:960    .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccyz1qU7.s:950    .bss.matrix:0000000000000000 matrix
     /tmp/ccyz1qU7.s:945    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccyz1qU7.s:321    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccyz1qU7.s:965    .bss.debouncing:0000000000000000 debouncing
     /tmp/ccyz1qU7.s:970    .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/ccyz1qU7.s:760    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccyz1qU7.s:782    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccyz1qU7.s:822    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccyz1qU7.s:852    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccyz1qU7.s:873    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop16
__do_copy_data
__do_clear_bss
