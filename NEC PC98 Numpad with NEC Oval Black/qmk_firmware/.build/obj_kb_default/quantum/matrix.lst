   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_user,"ax",@progbits
  11               		.weak	matrix_init_user
  13               	matrix_init_user:
  14               	.LFB10:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012 Jun Wako
   3:quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:quantum/matrix.c **** 
   5:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:quantum/matrix.c **** (at your option) any later version.
   9:quantum/matrix.c **** 
  10:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:quantum/matrix.c **** GNU General Public License for more details.
  14:quantum/matrix.c **** 
  15:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:quantum/matrix.c **** */
  18:quantum/matrix.c **** #include <stdint.h>
  19:quantum/matrix.c **** #include <stdbool.h>
  20:quantum/matrix.c **** #if defined(__AVR__)
  21:quantum/matrix.c **** #include <avr/io.h>
  22:quantum/matrix.c **** #endif
  23:quantum/matrix.c **** #include "wait.h"
  24:quantum/matrix.c **** #include "print.h"
  25:quantum/matrix.c **** #include "debug.h"
  26:quantum/matrix.c **** #include "util.h"
  27:quantum/matrix.c **** #include "matrix.h"
  28:quantum/matrix.c **** #include "timer.h"
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  34:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  35:quantum/matrix.c **** #endif
  36:quantum/matrix.c **** 
  37:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  38:quantum/matrix.c ****     static uint16_t debouncing_time;
  39:quantum/matrix.c ****     static bool debouncing = false;
  40:quantum/matrix.c **** #endif
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  43:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  44:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  45:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  46:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  47:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  48:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  49:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  50:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  51:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  52:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  53:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  54:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  55:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  56:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  57:quantum/matrix.c **** #endif
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** #ifdef MATRIX_MASKED
  60:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  61:quantum/matrix.c **** #endif
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** 
  66:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  67:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** static matrix_row_t matrix_raw[MATRIX_ROWS];
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #else // ROW2COL
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  16               		.loc 1 108 29 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 109:quantum/matrix.c **** }
  22               		.loc 1 109 1 view .LVU1
  23               	/* epilogue start */
  24 0000 0895      		ret
  25               		.cfi_endproc
  26               	.LFE10:
  28               		.set	matrix_init_user.localalias,matrix_init_user
  29               		.section	.text.matrix_init_kb,"ax",@progbits
  30               		.weak	matrix_init_kb
  32               	matrix_init_kb:
  33               	.LFB8:
  98:quantum/matrix.c ****     matrix_init_user();
  34               		.loc 1 98 27 view -0
  35               		.cfi_startproc
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  40               		.loc 1 99 5 view .LVU3
  41 0000 0C94 0000 		jmp matrix_init_user
  42               	.LVL0:
  43               		.cfi_endproc
  44               	.LFE8:
  46               		.section	.text.matrix_init_quantum,"ax",@progbits
  47               		.weak	matrix_init_quantum
  49               	matrix_init_quantum:
  50               	.LFB6:
  88:quantum/matrix.c ****     matrix_init_kb();
  51               		.loc 1 88 32 view -0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  57               		.loc 1 89 5 view .LVU5
  58 0000 0C94 0000 		jmp matrix_init_kb
  59               	.LVL1:
  60               		.cfi_endproc
  61               	.LFE6:
  63               		.section	.text.matrix_scan_user,"ax",@progbits
  64               		.weak	matrix_scan_user
  66               	matrix_scan_user:
  67               	.LFB27:
  68               		.cfi_startproc
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 0 */
  72               	.L__stack_usage = 0
  73               	/* epilogue start */
  74 0000 0895      		ret
  75               		.cfi_endproc
  76               	.LFE27:
  78               		.section	.text.matrix_scan_kb,"ax",@progbits
  79               		.weak	matrix_scan_kb
  81               	matrix_scan_kb:
  82               	.LFB9:
 103:quantum/matrix.c ****     matrix_scan_user();
  83               		.loc 1 103 27 view -0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  89               		.loc 1 104 5 view .LVU7
  90 0000 0C94 0000 		jmp matrix_scan_user
  91               	.LVL2:
  92               		.cfi_endproc
  93               	.LFE9:
  95               		.section	.text.matrix_scan_quantum,"ax",@progbits
  96               		.weak	matrix_scan_quantum
  98               	matrix_scan_quantum:
  99               	.LFB7:
  93:quantum/matrix.c ****     matrix_scan_kb();
 100               		.loc 1 93 32 view -0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 106               		.loc 1 94 5 view .LVU9
 107 0000 0C94 0000 		jmp matrix_scan_kb
 108               	.LVL3:
 109               		.cfi_endproc
 110               	.LFE7:
 112               		.section	.text.matrix_rows,"ax",@progbits
 113               	.global	matrix_rows
 115               	matrix_rows:
 116               	.LFB12:
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 117               		.loc 1 116 27 view -0
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 123               		.loc 1 117 5 view .LVU11
 118:quantum/matrix.c **** }
 124               		.loc 1 118 1 is_stmt 0 view .LVU12
 125 0000 8EE0      		ldi r24,lo8(14)
 126               	/* epilogue start */
 127 0002 0895      		ret
 128               		.cfi_endproc
 129               	.LFE12:
 131               		.section	.text.matrix_cols,"ax",@progbits
 132               	.global	matrix_cols
 134               	matrix_cols:
 135               	.LFB13:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 136               		.loc 1 121 27 is_stmt 1 view -0
 137               		.cfi_startproc
 138               	/* prologue: function */
 139               	/* frame size = 0 */
 140               	/* stack size = 0 */
 141               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 142               		.loc 1 122 5 view .LVU14
 123:quantum/matrix.c **** }
 143               		.loc 1 123 1 is_stmt 0 view .LVU15
 144 0000 83E0      		ldi r24,lo8(3)
 145               	/* epilogue start */
 146 0002 0895      		ret
 147               		.cfi_endproc
 148               	.LFE13:
 150               		.section	.text.matrix_init,"ax",@progbits
 151               	.global	matrix_init
 153               	matrix_init:
 154               	.LFB14:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #else
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 155               		.loc 1 149 24 is_stmt 1 view -0
 156               		.cfi_startproc
 157 0000 CF93      		push r28
 158               	.LCFI0:
 159               		.cfi_def_cfa_offset 3
 160               		.cfi_offset 28, -2
 161 0002 DF93      		push r29
 162               	.LCFI1:
 163               		.cfi_def_cfa_offset 4
 164               		.cfi_offset 29, -3
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 2 */
 168               	.L__stack_usage = 2
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 169               		.loc 1 153 9 view .LVU17
 170               		.loc 1 153 15 is_stmt 0 view .LVU18
 171 0004 85B7      		in r24,0x35
 172 0006 8068      		ori r24,lo8(-128)
 173 0008 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 174               		.loc 1 154 9 is_stmt 1 view .LVU19
 175               		.loc 1 154 15 is_stmt 0 view .LVU20
 176 000a 85B7      		in r24,0x35
 177 000c 8068      		ori r24,lo8(-128)
 178 000e 85BF      		out 0x35,r24
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #else // ROW2COL
 162:quantum/matrix.c ****     unselect_cols();
 179               		.loc 1 162 5 is_stmt 1 view .LVU21
 180               	.LBB19:
 181               	.LBI19:
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_raw[i] = 0;
 170:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 171:quantum/matrix.c ****     }
 172:quantum/matrix.c **** 
 173:quantum/matrix.c ****     matrix_init_quantum();
 174:quantum/matrix.c **** }
 175:quantum/matrix.c **** 
 176:quantum/matrix.c **** uint8_t matrix_scan(void)
 177:quantum/matrix.c **** {
 178:quantum/matrix.c **** 
 179:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Set row, read cols
 182:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 183:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 184:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 185:quantum/matrix.c **** 
 186:quantum/matrix.c ****             if (matrix_changed) {
 187:quantum/matrix.c ****                 debouncing = true;
 188:quantum/matrix.c ****                 debouncing_time = timer_read();
 189:quantum/matrix.c ****             }
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** #       else
 192:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 193:quantum/matrix.c **** #       endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     }
 196:quantum/matrix.c **** 
 197:quantum/matrix.c **** #else // ROW2COL
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // Set col, read rows
 200:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 201:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 202:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 203:quantum/matrix.c ****             if (matrix_changed) {
 204:quantum/matrix.c ****                 debouncing = true;
 205:quantum/matrix.c ****                 debouncing_time = timer_read();
 206:quantum/matrix.c ****             }
 207:quantum/matrix.c **** #       else
 208:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 209:quantum/matrix.c **** #       endif
 210:quantum/matrix.c **** 
 211:quantum/matrix.c ****     }
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #endif
 214:quantum/matrix.c **** 
 215:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 216:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 217:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 218:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 219:quantum/matrix.c ****             }
 220:quantum/matrix.c ****             debouncing = false;
 221:quantum/matrix.c ****         }
 222:quantum/matrix.c **** #   endif
 223:quantum/matrix.c **** 
 224:quantum/matrix.c ****     matrix_scan_quantum();
 225:quantum/matrix.c ****     return 1;
 226:quantum/matrix.c **** }
 227:quantum/matrix.c **** 
 228:quantum/matrix.c **** bool matrix_is_modified(void)
 229:quantum/matrix.c **** {
 230:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 231:quantum/matrix.c ****     if (debouncing) return false;
 232:quantum/matrix.c **** #endif
 233:quantum/matrix.c ****     return true;
 234:quantum/matrix.c **** }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c **** inline
 237:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 238:quantum/matrix.c **** {
 239:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** inline
 243:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 244:quantum/matrix.c **** {
 245:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 246:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 247:quantum/matrix.c **** #ifdef MATRIX_MASKED
 248:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 249:quantum/matrix.c **** #else
 250:quantum/matrix.c ****     return matrix[row];
 251:quantum/matrix.c **** #endif
 252:quantum/matrix.c **** }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c **** void matrix_print(void)
 255:quantum/matrix.c **** {
 256:quantum/matrix.c ****     print_matrix_header();
 257:quantum/matrix.c **** 
 258:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 259:quantum/matrix.c ****         phex(row); print(": ");
 260:quantum/matrix.c ****         print_matrix_row(row);
 261:quantum/matrix.c ****         print("\n");
 262:quantum/matrix.c ****     }
 263:quantum/matrix.c **** }
 264:quantum/matrix.c **** 
 265:quantum/matrix.c **** uint8_t matrix_key_count(void)
 266:quantum/matrix.c **** {
 267:quantum/matrix.c ****     uint8_t count = 0;
 268:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 269:quantum/matrix.c ****         count += matrix_bitpop(i);
 270:quantum/matrix.c ****     }
 271:quantum/matrix.c ****     return count;
 272:quantum/matrix.c **** }
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** 
 276:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 277:quantum/matrix.c **** 
 278:quantum/matrix.c **** static void init_cols(void)
 279:quantum/matrix.c **** {
 280:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 281:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 283:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 284:quantum/matrix.c ****     }
 285:quantum/matrix.c **** }
 286:quantum/matrix.c **** 
 287:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 288:quantum/matrix.c **** {
 289:quantum/matrix.c ****     // Store last value of row prior to reading
 290:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 291:quantum/matrix.c **** 
 292:quantum/matrix.c ****     // Clear data in matrix row
 293:quantum/matrix.c ****     current_matrix[current_row] = 0;
 294:quantum/matrix.c **** 
 295:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 296:quantum/matrix.c ****     select_row(current_row);
 297:quantum/matrix.c ****     wait_us(30);
 298:quantum/matrix.c **** 
 299:quantum/matrix.c ****     // For each col...
 300:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 301:quantum/matrix.c **** 
 302:quantum/matrix.c ****         // Select the col pin to read (active low)
 303:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 304:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 305:quantum/matrix.c **** 
 306:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 307:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 308:quantum/matrix.c ****     }
 309:quantum/matrix.c **** 
 310:quantum/matrix.c ****     // Unselect row
 311:quantum/matrix.c ****     unselect_row(current_row);
 312:quantum/matrix.c **** 
 313:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 314:quantum/matrix.c **** }
 315:quantum/matrix.c **** 
 316:quantum/matrix.c **** static void select_row(uint8_t row)
 317:quantum/matrix.c **** {
 318:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 320:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 321:quantum/matrix.c **** }
 322:quantum/matrix.c **** 
 323:quantum/matrix.c **** static void unselect_row(uint8_t row)
 324:quantum/matrix.c **** {
 325:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 327:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 328:quantum/matrix.c **** }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c **** static void unselect_rows(void)
 331:quantum/matrix.c **** {
 332:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 335:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 336:quantum/matrix.c ****     }
 337:quantum/matrix.c **** }
 338:quantum/matrix.c **** 
 339:quantum/matrix.c **** #else // ROW2COL
 340:quantum/matrix.c **** 
 341:quantum/matrix.c **** static void init_rows(void)
 342:quantum/matrix.c **** {
 343:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 344:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 346:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 347:quantum/matrix.c ****     }
 348:quantum/matrix.c **** }
 349:quantum/matrix.c **** 
 350:quantum/matrix.c **** static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col)
 351:quantum/matrix.c **** {
 352:quantum/matrix.c ****     bool matrix_changed = false;
 353:quantum/matrix.c **** 
 354:quantum/matrix.c ****     // Select col and wait for col selecton to stabilize
 355:quantum/matrix.c ****     select_col(current_col);
 356:quantum/matrix.c ****     wait_us(30);
 357:quantum/matrix.c **** 
 358:quantum/matrix.c ****     // For each row...
 359:quantum/matrix.c ****     for(uint8_t row_index = 0; row_index < MATRIX_ROWS; row_index++)
 360:quantum/matrix.c ****     {
 361:quantum/matrix.c **** 
 362:quantum/matrix.c ****         // Store last value of row prior to reading
 363:quantum/matrix.c ****         matrix_row_t last_row_value = current_matrix[row_index];
 364:quantum/matrix.c **** 
 365:quantum/matrix.c ****         // Check row pin state
 366:quantum/matrix.c ****         if ((_SFR_IO8(row_pins[row_index] >> 4) & _BV(row_pins[row_index] & 0xF)) == 0)
 367:quantum/matrix.c ****         {
 368:quantum/matrix.c ****             // Pin LO, set col bit
 369:quantum/matrix.c ****             current_matrix[row_index] |= (ROW_SHIFTER << current_col);
 370:quantum/matrix.c ****         }
 371:quantum/matrix.c ****         else
 372:quantum/matrix.c ****         {
 373:quantum/matrix.c ****             // Pin HI, clear col bit
 374:quantum/matrix.c ****             current_matrix[row_index] &= ~(ROW_SHIFTER << current_col);
 375:quantum/matrix.c ****         }
 376:quantum/matrix.c **** 
 377:quantum/matrix.c ****         // Determine if the matrix changed state
 378:quantum/matrix.c ****         if ((last_row_value != current_matrix[row_index]) && !(matrix_changed))
 379:quantum/matrix.c ****         {
 380:quantum/matrix.c ****             matrix_changed = true;
 381:quantum/matrix.c ****         }
 382:quantum/matrix.c ****     }
 383:quantum/matrix.c **** 
 384:quantum/matrix.c ****     // Unselect col
 385:quantum/matrix.c ****     unselect_col(current_col);
 386:quantum/matrix.c **** 
 387:quantum/matrix.c ****     return matrix_changed;
 388:quantum/matrix.c **** }
 389:quantum/matrix.c **** 
 390:quantum/matrix.c **** static void select_col(uint8_t col)
 391:quantum/matrix.c **** {
 392:quantum/matrix.c ****     uint8_t pin = col_pins[col];
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 394:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 395:quantum/matrix.c **** }
 396:quantum/matrix.c **** 
 397:quantum/matrix.c **** static void unselect_col(uint8_t col)
 398:quantum/matrix.c **** {
 399:quantum/matrix.c ****     uint8_t pin = col_pins[col];
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 401:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 402:quantum/matrix.c **** }
 403:quantum/matrix.c **** 
 404:quantum/matrix.c **** static void unselect_cols(void)
 182               		.loc 1 404 13 view .LVU22
 183               	.LBE19:
 405:quantum/matrix.c **** {
 406:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 184               		.loc 1 406 5 view .LVU23
 185               	.LBB22:
 186               	.LBB20:
 187               		.loc 1 406 9 view .LVU24
 188               	.LVL4:
 189               		.loc 1 406 24 view .LVU25
 190 0010 C0E0      		ldi r28,lo8(col_pins)
 191 0012 D0E0      		ldi r29,hi8(col_pins)
 192 0014 20E0      		ldi r18,lo8(col_pins+3)
 193 0016 30E0      		ldi r19,hi8(col_pins+3)
 194               	.LBB21:
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 408:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 195               		.loc 1 408 38 is_stmt 0 view .LVU26
 196 0018 41E0      		ldi r20,lo8(1)
 197 001a 50E0      		ldi r21,0
 198               	.LVL5:
 199               	.L10:
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 200               		.loc 1 407 9 is_stmt 1 view .LVU27
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 201               		.loc 1 407 17 is_stmt 0 view .LVU28
 202 001c 8991      		ld r24,Y+
 203               	.LVL6:
 204               		.loc 1 408 9 is_stmt 1 view .LVU29
 205               		.loc 1 408 34 is_stmt 0 view .LVU30
 206 001e E82F      		mov r30,r24
 207 0020 E295      		swap r30
 208 0022 EF70      		andi r30,lo8(15)
 209 0024 A1E2      		ldi r26,lo8(33)
 210 0026 AE0F      		add r26,r30
 211 0028 B0E0      		ldi r27,0
 212 002a FC91      		ld r31,X
 213               		.loc 1 408 38 view .LVU31
 214 002c 8F70      		andi r24,lo8(15)
 215               	.LVL7:
 216               		.loc 1 408 38 view .LVU32
 217 002e BA01      		movw r22,r20
 218 0030 00C0      		rjmp 2f
 219               		1:
 220 0032 660F      		lsl r22
 221               		2:
 222 0034 8A95      		dec r24
 223 0036 02F4      		brpl 1b
 224               		.loc 1 408 34 view .LVU33
 225 0038 962F      		mov r25,r22
 226 003a 9095      		com r25
 227 003c 9F23      		and r25,r31
 228 003e 9C93      		st X,r25
 229               	.LVL8:
 409:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 230               		.loc 1 409 9 is_stmt 1 view .LVU34
 231               		.loc 1 409 34 is_stmt 0 view .LVU35
 232 0040 EE5D      		subi r30,lo8(-(34))
 233 0042 F0E0      		ldi r31,0
 234 0044 8081      		ld r24,Z
 235 0046 862B      		or r24,r22
 236 0048 8083      		st Z,r24
 237               	.LBE21:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 238               		.loc 1 406 41 is_stmt 1 view .LVU36
 239               	.LVL9:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 240               		.loc 1 406 24 view .LVU37
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 241               		.loc 1 406 5 is_stmt 0 view .LVU38
 242 004a 2C17      		cp r18,r28
 243 004c 3D07      		cpc r19,r29
 244 004e 01F4      		brne .L10
 245 0050 C0E0      		ldi r28,lo8(row_pins)
 246 0052 D0E0      		ldi r29,hi8(row_pins)
 247               	.LVL10:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 248               		.loc 1 406 5 view .LVU39
 249 0054 20E0      		ldi r18,lo8(row_pins+14)
 250 0056 30E0      		ldi r19,hi8(row_pins+14)
 251               	.LBE20:
 252               	.LBE22:
 253               	.LBB23:
 254               	.LBB24:
 255               	.LBB25:
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 256               		.loc 1 345 38 view .LVU40
 257 0058 41E0      		ldi r20,lo8(1)
 258 005a 50E0      		ldi r21,0
 259               	.L11:
 260               	.LVL11:
 344:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 261               		.loc 1 344 9 is_stmt 1 view .LVU41
 344:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 262               		.loc 1 344 17 is_stmt 0 view .LVU42
 263 005c 8991      		ld r24,Y+
 264               	.LVL12:
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 265               		.loc 1 345 9 is_stmt 1 view .LVU43
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 266               		.loc 1 345 34 is_stmt 0 view .LVU44
 267 005e E82F      		mov r30,r24
 268 0060 E295      		swap r30
 269 0062 EF70      		andi r30,lo8(15)
 270 0064 A1E2      		ldi r26,lo8(33)
 271 0066 AE0F      		add r26,r30
 272 0068 B0E0      		ldi r27,0
 273 006a FC91      		ld r31,X
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 274               		.loc 1 345 38 view .LVU45
 275 006c 8F70      		andi r24,lo8(15)
 276               	.LVL13:
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 277               		.loc 1 345 38 view .LVU46
 278 006e BA01      		movw r22,r20
 279 0070 00C0      		rjmp 2f
 280               		1:
 281 0072 660F      		lsl r22
 282               		2:
 283 0074 8A95      		dec r24
 284 0076 02F4      		brpl 1b
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 285               		.loc 1 345 34 view .LVU47
 286 0078 962F      		mov r25,r22
 287 007a 9095      		com r25
 288 007c 9F23      		and r25,r31
 289 007e 9C93      		st X,r25
 290               	.LVL14:
 346:quantum/matrix.c ****     }
 291               		.loc 1 346 9 is_stmt 1 view .LVU48
 346:quantum/matrix.c ****     }
 292               		.loc 1 346 34 is_stmt 0 view .LVU49
 293 0080 EE5D      		subi r30,lo8(-(34))
 294 0082 F0E0      		ldi r31,0
 295 0084 8081      		ld r24,Z
 296 0086 862B      		or r24,r22
 297 0088 8083      		st Z,r24
 298               	.LBE25:
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 299               		.loc 1 343 41 is_stmt 1 view .LVU50
 300               	.LVL15:
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 301               		.loc 1 343 24 view .LVU51
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 302               		.loc 1 343 5 is_stmt 0 view .LVU52
 303 008a 2C17      		cp r18,r28
 304 008c 3D07      		cpc r19,r29
 305 008e 01F4      		brne .L11
 306               	.LBE24:
 307               	.LBE23:
 308               	.LBB26:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 309               		.loc 1 168 19 view .LVU53
 310 0090 8EE0      		ldi r24,lo8(14)
 311 0092 E0E0      		ldi r30,lo8(matrix)
 312 0094 F0E0      		ldi r31,hi8(matrix)
 313 0096 DF01      		movw r26,r30
 314 0098 982F      		mov r25,r24
 315               		0:
 316 009a 1D92      		st X+,__zero_reg__
 317 009c 9A95      		dec r25
 318 009e 01F4      		brne 0b
 170:quantum/matrix.c ****     }
 319               		.loc 1 170 30 view .LVU54
 320 00a0 E0E0      		ldi r30,lo8(matrix_debouncing)
 321 00a2 F0E0      		ldi r31,hi8(matrix_debouncing)
 322 00a4 DF01      		movw r26,r30
 323               		0:
 324 00a6 1D92      		st X+,__zero_reg__
 325 00a8 8A95      		dec r24
 326 00aa 01F4      		brne 0b
 327               	.LVL16:
 170:quantum/matrix.c ****     }
 328               		.loc 1 170 30 view .LVU55
 329               	.LBE26:
 173:quantum/matrix.c **** }
 330               		.loc 1 173 5 is_stmt 1 view .LVU56
 331               	/* epilogue start */
 174:quantum/matrix.c **** 
 332               		.loc 1 174 1 is_stmt 0 view .LVU57
 333 00ac DF91      		pop r29
 334 00ae CF91      		pop r28
 173:quantum/matrix.c **** }
 335               		.loc 1 173 5 view .LVU58
 336 00b0 0C94 0000 		jmp matrix_init_quantum
 337               	.LVL17:
 338               		.cfi_endproc
 339               	.LFE14:
 341               		.section	.text.matrix_scan,"ax",@progbits
 342               	.global	matrix_scan
 344               	matrix_scan:
 345               	.LFB15:
 177:quantum/matrix.c **** 
 346               		.loc 1 177 1 is_stmt 1 view -0
 347               		.cfi_startproc
 348 0000 3F92      		push r3
 349               	.LCFI2:
 350               		.cfi_def_cfa_offset 3
 351               		.cfi_offset 3, -2
 352 0002 4F92      		push r4
 353               	.LCFI3:
 354               		.cfi_def_cfa_offset 4
 355               		.cfi_offset 4, -3
 356 0004 5F92      		push r5
 357               	.LCFI4:
 358               		.cfi_def_cfa_offset 5
 359               		.cfi_offset 5, -4
 360 0006 6F92      		push r6
 361               	.LCFI5:
 362               		.cfi_def_cfa_offset 6
 363               		.cfi_offset 6, -5
 364 0008 7F92      		push r7
 365               	.LCFI6:
 366               		.cfi_def_cfa_offset 7
 367               		.cfi_offset 7, -6
 368 000a 8F92      		push r8
 369               	.LCFI7:
 370               		.cfi_def_cfa_offset 8
 371               		.cfi_offset 8, -7
 372 000c 9F92      		push r9
 373               	.LCFI8:
 374               		.cfi_def_cfa_offset 9
 375               		.cfi_offset 9, -8
 376 000e AF92      		push r10
 377               	.LCFI9:
 378               		.cfi_def_cfa_offset 10
 379               		.cfi_offset 10, -9
 380 0010 BF92      		push r11
 381               	.LCFI10:
 382               		.cfi_def_cfa_offset 11
 383               		.cfi_offset 11, -10
 384 0012 CF92      		push r12
 385               	.LCFI11:
 386               		.cfi_def_cfa_offset 12
 387               		.cfi_offset 12, -11
 388 0014 DF92      		push r13
 389               	.LCFI12:
 390               		.cfi_def_cfa_offset 13
 391               		.cfi_offset 13, -12
 392 0016 EF92      		push r14
 393               	.LCFI13:
 394               		.cfi_def_cfa_offset 14
 395               		.cfi_offset 14, -13
 396 0018 FF92      		push r15
 397               	.LCFI14:
 398               		.cfi_def_cfa_offset 15
 399               		.cfi_offset 15, -14
 400 001a 0F93      		push r16
 401               	.LCFI15:
 402               		.cfi_def_cfa_offset 16
 403               		.cfi_offset 16, -15
 404 001c 1F93      		push r17
 405               	.LCFI16:
 406               		.cfi_def_cfa_offset 17
 407               		.cfi_offset 17, -16
 408 001e CF93      		push r28
 409               	.LCFI17:
 410               		.cfi_def_cfa_offset 18
 411               		.cfi_offset 28, -17
 412 0020 DF93      		push r29
 413               	.LCFI18:
 414               		.cfi_def_cfa_offset 19
 415               		.cfi_offset 29, -18
 416 0022 00D0      		rcall .
 417 0024 00D0      		rcall .
 418               	.LCFI19:
 419               		.cfi_def_cfa_offset 23
 420 0026 CDB7      		in r28,__SP_L__
 421 0028 DEB7      		in r29,__SP_H__
 422               	.LCFI20:
 423               		.cfi_def_cfa_register 28
 424               	/* prologue: function */
 425               	/* frame size = 4 */
 426               	/* stack size = 21 */
 427               	.L__stack_usage = 21
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 428               		.loc 1 200 5 view .LVU60
 429               	.LBB40:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 430               		.loc 1 200 10 view .LVU61
 431               	.LVL18:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 432               		.loc 1 200 35 view .LVU62
 433 002a 00E0      		ldi r16,lo8(col_pins)
 434 002c 10E0      		ldi r17,hi8(col_pins)
 435               	.LBE40:
 177:quantum/matrix.c **** 
 436               		.loc 1 177 1 is_stmt 0 view .LVU63
 437 002e 1A82      		std Y+2,__zero_reg__
 438 0030 1982      		std Y+1,__zero_reg__
 439               	.LBB60:
 440               	.LBB41:
 441               	.LBB42:
 442               	.LBB43:
 443               	.LBB44:
 444               	.LBB45:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 445               		.loc 1 393 34 view .LVU64
 446 0032 CC24      		clr r12
 447 0034 C394      		inc r12
 448 0036 D12C      		mov r13,__zero_reg__
 449 0038 90E0      		ldi r25,lo8(matrix_debouncing+14)
 450 003a E92E      		mov r14,r25
 451 003c 90E0      		ldi r25,hi8(matrix_debouncing+14)
 452 003e F92E      		mov r15,r25
 453               	.LBE45:
 454               	.LBE44:
 455               	.LBB47:
 456               	.LBB48:
 378:quantum/matrix.c ****         {
 457               		.loc 1 378 12 view .LVU65
 458 0040 4424      		clr r4
 459 0042 4394      		inc r4
 460               	.LVL19:
 461               	.L20:
 378:quantum/matrix.c ****         {
 462               		.loc 1 378 12 view .LVU66
 463               	.LBE48:
 464               	.LBE47:
 465               	.LBE43:
 466               	.LBE42:
 202:quantum/matrix.c ****             if (matrix_changed) {
 467               		.loc 1 202 13 is_stmt 1 view .LVU67
 468               	.LBB59:
 469               	.LBI42:
 350:quantum/matrix.c **** {
 470               		.loc 1 350 13 view .LVU68
 471               	.LBB58:
 352:quantum/matrix.c **** 
 472               		.loc 1 352 5 view .LVU69
 355:quantum/matrix.c ****     wait_us(30);
 473               		.loc 1 355 5 view .LVU70
 474               	.LBB51:
 475               	.LBI44:
 390:quantum/matrix.c **** {
 476               		.loc 1 390 13 view .LVU71
 477               	.LBB46:
 392:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 478               		.loc 1 392 5 view .LVU72
 392:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 479               		.loc 1 392 13 is_stmt 0 view .LVU73
 480 0044 F801      		movw r30,r16
 481 0046 8191      		ld r24,Z+
 482 0048 8F01      		movw r16,r30
 483               	.LVL20:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 484               		.loc 1 393 5 is_stmt 1 view .LVU74
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 485               		.loc 1 393 30 is_stmt 0 view .LVU75
 486 004a E82F      		mov r30,r24
 487 004c E295      		swap r30
 488 004e EF70      		andi r30,lo8(15)
 489 0050 A1E2      		ldi r26,lo8(33)
 490 0052 AE0F      		add r26,r30
 491 0054 B0E0      		ldi r27,0
 492 0056 9C91      		ld r25,X
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 493               		.loc 1 393 34 view .LVU76
 494 0058 8F70      		andi r24,lo8(15)
 495               	.LVL21:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 496               		.loc 1 393 34 view .LVU77
 497 005a 9601      		movw r18,r12
 498 005c 00C0      		rjmp 2f
 499               		1:
 500 005e 220F      		lsl r18
 501               		2:
 502 0060 8A95      		dec r24
 503 0062 02F4      		brpl 1b
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 504               		.loc 1 393 30 view .LVU78
 505 0064 892F      		mov r24,r25
 506 0066 822B      		or r24,r18
 507 0068 8C93      		st X,r24
 508               	.LVL22:
 394:quantum/matrix.c **** }
 509               		.loc 1 394 5 is_stmt 1 view .LVU79
 394:quantum/matrix.c **** }
 510               		.loc 1 394 30 is_stmt 0 view .LVU80
 511 006a EE5D      		subi r30,lo8(-(34))
 512 006c 8E2F      		mov r24,r30
 513 006e 90E0      		ldi r25,0
 514 0070 9C83      		std Y+4,r25
 515 0072 8B83      		std Y+3,r24
 516 0074 FC01      		movw r30,r24
 517 0076 8081      		ld r24,Z
 518 0078 622E      		mov r6,r18
 519 007a 6094      		com r6
 520 007c 8621      		and r24,r6
 521 007e 8083      		st Z,r24
 394:quantum/matrix.c **** }
 522               		.loc 1 394 30 view .LVU81
 523               	.LBE46:
 524               	.LBE51:
 356:quantum/matrix.c **** 
 525               		.loc 1 356 5 is_stmt 1 view .LVU82
 526               	.LVL23:
 527               	.LBB52:
 528               	.LBI52:
 529               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 530               		.loc 2 255 1 view .LVU83
 531               	.LBB53:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 532               		.loc 2 257 2 view .LVU84
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 533               		.loc 2 261 2 view .LVU85
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 534               		.loc 2 262 2 view .LVU86
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 535               		.loc 2 263 2 view .LVU87
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 536               		.loc 2 273 3 view .LVU88
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 537               		.loc 2 276 2 view .LVU89
 538 0080 F0EA      		ldi r31,lo8(-96)
 539 0082 FA95      	1:	dec r31
 540 0084 01F4      		brne 1b
 541               	.LVL24:
 542               		.loc 2 276 2 is_stmt 0 view .LVU90
 543               	.LBE53:
 544               	.LBE52:
 359:quantum/matrix.c ****     {
 545               		.loc 1 359 5 is_stmt 1 view .LVU91
 546               	.LBB54:
 359:quantum/matrix.c ****     {
 547               		.loc 1 359 9 view .LVU92
 359:quantum/matrix.c ****     {
 548               		.loc 1 359 32 view .LVU93
 549               	.LBB49:
 374:quantum/matrix.c ****         }
 550               		.loc 1 374 56 is_stmt 0 view .LVU94
 551 0086 C601      		movw r24,r12
 552 0088 0980      		ldd r0,Y+1
 553 008a 00C0      		rjmp 2f
 554               		1:
 555 008c 880F      		lsl r24
 556 008e 991F      		rol r25
 557               		2:
 558 0090 0A94      		dec r0
 559 0092 02F4      		brpl 1b
 374:quantum/matrix.c ****         }
 560               		.loc 1 374 39 view .LVU95
 561 0094 582E      		mov r5,r24
 562 0096 982E      		mov r9,r24
 563 0098 9094      		com r9
 564 009a 80E0      		ldi r24,lo8(matrix_debouncing)
 565 009c 90E0      		ldi r25,hi8(matrix_debouncing)
 566 009e 60E0      		ldi r22,lo8(row_pins)
 567 00a0 70E0      		ldi r23,hi8(row_pins)
 568               	.LBE49:
 569               	.LBE54:
 352:quantum/matrix.c **** 
 570               		.loc 1 352 10 view .LVU96
 571 00a2 712C      		mov r7,__zero_reg__
 572               	.LVL25:
 573               	.L18:
 574               	.LBB55:
 575               	.LBB50:
 363:quantum/matrix.c **** 
 576               		.loc 1 363 9 is_stmt 1 view .LVU97
 363:quantum/matrix.c **** 
 577               		.loc 1 363 22 is_stmt 0 view .LVU98
 578 00a4 FC01      		movw r30,r24
 579 00a6 8190      		ld r8,Z+
 580 00a8 CF01      		movw r24,r30
 581               	.LVL26:
 366:quantum/matrix.c ****         {
 582               		.loc 1 366 9 is_stmt 1 view .LVU99
 366:quantum/matrix.c ****         {
 583               		.loc 1 366 14 is_stmt 0 view .LVU100
 584 00aa FB01      		movw r30,r22
 585 00ac 3190      		ld r3,Z+
 586 00ae BF01      		movw r22,r30
 587 00b0 432D      		mov r20,r3
 588 00b2 4295      		swap r20
 589 00b4 4F70      		andi r20,lo8(15)
 590 00b6 405E      		subi r20,lo8(-(32))
 591 00b8 50E0      		ldi r21,0
 592 00ba FA01      		movw r30,r20
 593 00bc A080      		ld r10,Z
 594 00be B12C      		mov r11,__zero_reg__
 366:quantum/matrix.c ****         {
 595               		.loc 1 366 51 view .LVU101
 596 00c0 432D      		mov r20,r3
 597 00c2 4F70      		andi r20,lo8(15)
 366:quantum/matrix.c ****         {
 598               		.loc 1 366 83 view .LVU102
 599 00c4 00C0      		rjmp 2f
 600               		1:
 601 00c6 B594      		asr r11
 602 00c8 A794      		ror r10
 603               		2:
 604 00ca 4A95      		dec r20
 605 00cc 02F4      		brpl 1b
 606 00ce AC01      		movw r20,r24
 607 00d0 4150      		subi r20,1
 608 00d2 5109      		sbc r21,__zero_reg__
 369:quantum/matrix.c ****         }
 609               		.loc 1 369 39 view .LVU103
 610 00d4 B52C      		mov r11,r5
 611 00d6 B828      		or r11,r8
 366:quantum/matrix.c ****         {
 612               		.loc 1 366 12 view .LVU104
 613 00d8 A0FE      		sbrs r10,0
 614 00da 00C0      		rjmp .L29
 374:quantum/matrix.c ****         }
 615               		.loc 1 374 13 is_stmt 1 view .LVU105
 374:quantum/matrix.c ****         }
 616               		.loc 1 374 39 is_stmt 0 view .LVU106
 617 00dc B92C      		mov r11,r9
 618 00de B820      		and r11,r8
 619               	.L29:
 620 00e0 FA01      		movw r30,r20
 621 00e2 B082      		st Z,r11
 378:quantum/matrix.c ****         {
 622               		.loc 1 378 9 is_stmt 1 view .LVU107
 378:quantum/matrix.c ****         {
 623               		.loc 1 378 12 is_stmt 0 view .LVU108
 624 00e4 4081      		ld r20,Z
 625 00e6 8416      		cp r8,r20
 626 00e8 01F0      		breq .L17
 627 00ea 7724      		clr r7
 628 00ec 7394      		inc r7
 629               	.LVL27:
 630               	.L17:
 378:quantum/matrix.c ****         {
 631               		.loc 1 378 12 view .LVU109
 632               	.LBE50:
 359:quantum/matrix.c ****     {
 633               		.loc 1 359 57 is_stmt 1 view .LVU110
 359:quantum/matrix.c ****     {
 634               		.loc 1 359 32 view .LVU111
 359:quantum/matrix.c ****     {
 635               		.loc 1 359 5 is_stmt 0 view .LVU112
 636 00ee E816      		cp r14,r24
 637 00f0 F906      		cpc r15,r25
 638 00f2 01F4      		brne .L18
 639               	.LBE55:
 385:quantum/matrix.c **** 
 640               		.loc 1 385 5 is_stmt 1 view .LVU113
 641               	.LVL28:
 642               	.LBB56:
 643               	.LBI56:
 397:quantum/matrix.c **** {
 644               		.loc 1 397 13 view .LVU114
 645               	.LBB57:
 399:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 646               		.loc 1 399 5 view .LVU115
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 647               		.loc 1 400 5 view .LVU116
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 648               		.loc 1 400 30 is_stmt 0 view .LVU117
 649 00f4 8C91      		ld r24,X
 650               	.LVL29:
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 651               		.loc 1 400 30 view .LVU118
 652 00f6 6822      		and r6,r24
 653 00f8 6C92      		st X,r6
 401:quantum/matrix.c **** }
 654               		.loc 1 401 5 is_stmt 1 view .LVU119
 401:quantum/matrix.c **** }
 655               		.loc 1 401 30 is_stmt 0 view .LVU120
 656 00fa EB81      		ldd r30,Y+3
 657 00fc FC81      		ldd r31,Y+4
 658               	.LVL30:
 401:quantum/matrix.c **** }
 659               		.loc 1 401 30 view .LVU121
 660 00fe 8081      		ld r24,Z
 661 0100 282B      		or r18,r24
 662 0102 2083      		st Z,r18
 401:quantum/matrix.c **** }
 663               		.loc 1 401 30 view .LVU122
 664               	.LBE57:
 665               	.LBE56:
 387:quantum/matrix.c **** }
 666               		.loc 1 387 5 is_stmt 1 view .LVU123
 667               	.LVL31:
 387:quantum/matrix.c **** }
 668               		.loc 1 387 5 is_stmt 0 view .LVU124
 669               	.LBE58:
 670               	.LBE59:
 203:quantum/matrix.c ****                 debouncing = true;
 671               		.loc 1 203 13 is_stmt 1 view .LVU125
 203:quantum/matrix.c ****                 debouncing = true;
 672               		.loc 1 203 16 is_stmt 0 view .LVU126
 673 0104 7720      		tst r7
 674 0106 01F0      		breq .L19
 675               	.LVL32:
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 676               		.loc 1 204 17 is_stmt 1 view .LVU127
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 677               		.loc 1 204 28 is_stmt 0 view .LVU128
 678 0108 4092 0000 		sts debouncing,r4
 205:quantum/matrix.c ****             }
 679               		.loc 1 205 17 is_stmt 1 view .LVU129
 205:quantum/matrix.c ****             }
 680               		.loc 1 205 35 is_stmt 0 view .LVU130
 681 010c 0E94 0000 		call timer_read
 682               	.LVL33:
 205:quantum/matrix.c ****             }
 683               		.loc 1 205 33 view .LVU131
 684 0110 9093 0000 		sts debouncing_time+1,r25
 685 0114 8093 0000 		sts debouncing_time,r24
 686               	.LVL34:
 687               	.L19:
 205:quantum/matrix.c ****             }
 688               		.loc 1 205 33 view .LVU132
 689               	.LBE41:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 690               		.loc 1 200 62 is_stmt 1 discriminator 2 view .LVU133
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 691               		.loc 1 200 35 discriminator 2 view .LVU134
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 692               		.loc 1 200 5 is_stmt 0 discriminator 2 view .LVU135
 693 0118 8981      		ldd r24,Y+1
 694 011a 9A81      		ldd r25,Y+2
 695 011c 0196      		adiw r24,1
 696 011e 9A83      		std Y+2,r25
 697 0120 8983      		std Y+1,r24
 698               	.LVL35:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 699               		.loc 1 200 5 discriminator 2 view .LVU136
 700 0122 0397      		sbiw r24,3
 701 0124 01F0      		breq .+2
 702 0126 00C0      		rjmp .L20
 703               	.LBE60:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 704               		.loc 1 216 9 is_stmt 1 view .LVU137
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 705               		.loc 1 216 12 is_stmt 0 view .LVU138
 706 0128 8091 0000 		lds r24,debouncing
 707 012c 8823      		tst r24
 708 012e 01F0      		breq .L22
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 709               		.loc 1 216 28 discriminator 1 view .LVU139
 710 0130 8091 0000 		lds r24,debouncing_time
 711 0134 9091 0000 		lds r25,debouncing_time+1
 712 0138 0E94 0000 		call timer_elapsed
 713               	.LVL36:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 714               		.loc 1 216 24 discriminator 1 view .LVU140
 715 013c 0697      		sbiw r24,6
 716 013e 00F0      		brlo .L22
 717               	.LBB61:
 218:quantum/matrix.c ****             }
 718               		.loc 1 218 27 view .LVU141
 719 0140 8EE0      		ldi r24,lo8(14)
 720 0142 E0E0      		ldi r30,lo8(matrix_debouncing)
 721 0144 F0E0      		ldi r31,hi8(matrix_debouncing)
 722 0146 A0E0      		ldi r26,lo8(matrix)
 723 0148 B0E0      		ldi r27,hi8(matrix)
 724               		0:
 725 014a 0190      		ld r0,Z+
 726 014c 0D92      		st X+,r0
 727 014e 8A95      		dec r24
 728 0150 01F4      		brne 0b
 729               	.LBE61:
 220:quantum/matrix.c ****         }
 730               		.loc 1 220 13 is_stmt 1 view .LVU142
 220:quantum/matrix.c ****         }
 731               		.loc 1 220 24 is_stmt 0 view .LVU143
 732 0152 1092 0000 		sts debouncing,__zero_reg__
 733               	.L22:
 224:quantum/matrix.c ****     return 1;
 734               		.loc 1 224 5 is_stmt 1 view .LVU144
 735 0156 0E94 0000 		call matrix_scan_quantum
 736               	.LVL37:
 225:quantum/matrix.c **** }
 737               		.loc 1 225 5 view .LVU145
 226:quantum/matrix.c **** 
 738               		.loc 1 226 1 is_stmt 0 view .LVU146
 739 015a 81E0      		ldi r24,lo8(1)
 740               	/* epilogue start */
 741 015c 0F90      		pop __tmp_reg__
 742 015e 0F90      		pop __tmp_reg__
 743 0160 0F90      		pop __tmp_reg__
 744 0162 0F90      		pop __tmp_reg__
 745 0164 DF91      		pop r29
 746 0166 CF91      		pop r28
 747 0168 1F91      		pop r17
 748 016a 0F91      		pop r16
 749 016c FF90      		pop r15
 750 016e EF90      		pop r14
 751 0170 DF90      		pop r13
 752 0172 CF90      		pop r12
 753 0174 BF90      		pop r11
 754 0176 AF90      		pop r10
 755 0178 9F90      		pop r9
 756 017a 8F90      		pop r8
 757 017c 7F90      		pop r7
 758 017e 6F90      		pop r6
 759 0180 5F90      		pop r5
 760 0182 4F90      		pop r4
 761 0184 3F90      		pop r3
 762 0186 0895      		ret
 763               		.cfi_endproc
 764               	.LFE15:
 766               		.section	.text.matrix_is_modified,"ax",@progbits
 767               	.global	matrix_is_modified
 769               	matrix_is_modified:
 770               	.LFB16:
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 771               		.loc 1 229 1 is_stmt 1 view -0
 772               		.cfi_startproc
 773               	/* prologue: function */
 774               	/* frame size = 0 */
 775               	/* stack size = 0 */
 776               	.L__stack_usage = 0
 231:quantum/matrix.c **** #endif
 777               		.loc 1 231 5 view .LVU148
 231:quantum/matrix.c **** #endif
 778               		.loc 1 231 8 is_stmt 0 view .LVU149
 779 0000 9091 0000 		lds r25,debouncing
 234:quantum/matrix.c **** 
 780               		.loc 1 234 1 view .LVU150
 781 0004 81E0      		ldi r24,lo8(1)
 782 0006 8927      		eor r24,r25
 783               	/* epilogue start */
 784 0008 0895      		ret
 785               		.cfi_endproc
 786               	.LFE16:
 788               		.section	.text.matrix_is_on,"ax",@progbits
 789               	.global	matrix_is_on
 791               	matrix_is_on:
 792               	.LVL38:
 793               	.LFB17:
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 794               		.loc 1 238 1 is_stmt 1 view -0
 795               		.cfi_startproc
 796               	/* prologue: function */
 797               	/* frame size = 0 */
 798               	/* stack size = 0 */
 799               	.L__stack_usage = 0
 239:quantum/matrix.c **** }
 800               		.loc 1 239 5 view .LVU152
 239:quantum/matrix.c **** }
 801               		.loc 1 239 19 is_stmt 0 view .LVU153
 802 0000 E82F      		mov r30,r24
 803 0002 F0E0      		ldi r31,0
 804 0004 E050      		subi r30,lo8(-(matrix))
 805 0006 F040      		sbci r31,hi8(-(matrix))
 806 0008 8081      		ld r24,Z
 807               	.LVL39:
 239:quantum/matrix.c **** }
 808               		.loc 1 239 43 view .LVU154
 809 000a 21E0      		ldi r18,lo8(1)
 810 000c 30E0      		ldi r19,0
 811 000e 6230      		cpi r22,lo8(2)
 812 0010 00F4      		brsh .L32
 813 0012 20E0      		ldi r18,0
 814               	.L32:
 239:quantum/matrix.c **** }
 815               		.loc 1 239 25 view .LVU155
 816 0014 8223      		and r24,r18
 240:quantum/matrix.c **** 
 817               		.loc 1 240 1 view .LVU156
 818 0016 8170      		andi r24,lo8(1)
 819               	/* epilogue start */
 820 0018 0895      		ret
 821               		.cfi_endproc
 822               	.LFE17:
 824               		.section	.text.matrix_get_row,"ax",@progbits
 825               	.global	matrix_get_row
 827               	matrix_get_row:
 828               	.LVL40:
 829               	.LFB18:
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 830               		.loc 1 244 1 is_stmt 1 view -0
 831               		.cfi_startproc
 832               	/* prologue: function */
 833               	/* frame size = 0 */
 834               	/* stack size = 0 */
 835               	.L__stack_usage = 0
 250:quantum/matrix.c **** #endif
 836               		.loc 1 250 5 view .LVU158
 250:quantum/matrix.c **** #endif
 837               		.loc 1 250 18 is_stmt 0 view .LVU159
 838 0000 E82F      		mov r30,r24
 839 0002 F0E0      		ldi r31,0
 840 0004 E050      		subi r30,lo8(-(matrix))
 841 0006 F040      		sbci r31,hi8(-(matrix))
 252:quantum/matrix.c **** 
 842               		.loc 1 252 1 view .LVU160
 843 0008 8081      		ld r24,Z
 844               	.LVL41:
 845               	/* epilogue start */
 252:quantum/matrix.c **** 
 846               		.loc 1 252 1 view .LVU161
 847 000a 0895      		ret
 848               		.cfi_endproc
 849               	.LFE18:
 851               		.section	.text.matrix_print,"ax",@progbits
 852               	.global	matrix_print
 854               	matrix_print:
 855               	.LFB19:
 255:quantum/matrix.c ****     print_matrix_header();
 856               		.loc 1 255 1 is_stmt 1 view -0
 857               		.cfi_startproc
 858               	/* prologue: function */
 859               	/* frame size = 0 */
 860               	/* stack size = 0 */
 861               	.L__stack_usage = 0
 256:quantum/matrix.c **** 
 862               		.loc 1 256 26 view .LVU163
 258:quantum/matrix.c ****         phex(row); print(": ");
 863               		.loc 1 258 5 view .LVU164
 258:quantum/matrix.c ****         phex(row); print(": ");
 864               		.loc 1 258 10 view .LVU165
 258:quantum/matrix.c ****         phex(row); print(": ");
 865               		.loc 1 258 27 view .LVU166
 866               	/* epilogue start */
 263:quantum/matrix.c **** 
 867               		.loc 1 263 1 is_stmt 0 view .LVU167
 868 0000 0895      		ret
 869               		.cfi_endproc
 870               	.LFE19:
 872               		.section	.text.matrix_key_count,"ax",@progbits
 873               	.global	matrix_key_count
 875               	matrix_key_count:
 876               	.LFB20:
 266:quantum/matrix.c ****     uint8_t count = 0;
 877               		.loc 1 266 1 is_stmt 1 view -0
 878               		.cfi_startproc
 879 0000 0F93      		push r16
 880               	.LCFI21:
 881               		.cfi_def_cfa_offset 3
 882               		.cfi_offset 16, -2
 883 0002 1F93      		push r17
 884               	.LCFI22:
 885               		.cfi_def_cfa_offset 4
 886               		.cfi_offset 17, -3
 887 0004 CF93      		push r28
 888               	.LCFI23:
 889               		.cfi_def_cfa_offset 5
 890               		.cfi_offset 28, -4
 891               	/* prologue: function */
 892               	/* frame size = 0 */
 893               	/* stack size = 3 */
 894               	.L__stack_usage = 3
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 895               		.loc 1 267 5 view .LVU169
 896               	.LVL42:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 897               		.loc 1 268 5 view .LVU170
 898               	.LBB62:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 899               		.loc 1 268 10 view .LVU171
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 900               		.loc 1 268 25 view .LVU172
 901 0006 00E0      		ldi r16,lo8(matrix)
 902 0008 10E0      		ldi r17,hi8(matrix)
 903               	.LBE62:
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 904               		.loc 1 267 13 is_stmt 0 view .LVU173
 905 000a C0E0      		ldi r28,0
 906               	.LVL43:
 907               	.L36:
 908               	.LBB63:
 269:quantum/matrix.c ****     }
 909               		.loc 1 269 9 is_stmt 1 discriminator 3 view .LVU174
 269:quantum/matrix.c ****     }
 910               		.loc 1 269 18 is_stmt 0 discriminator 3 view .LVU175
 911 000c F801      		movw r30,r16
 912 000e 8191      		ld r24,Z+
 913 0010 8F01      		movw r16,r30
 914               	.LVL44:
 269:quantum/matrix.c ****     }
 915               		.loc 1 269 18 discriminator 3 view .LVU176
 916 0012 0E94 0000 		call bitpop
 917               	.LVL45:
 269:quantum/matrix.c ****     }
 918               		.loc 1 269 15 discriminator 3 view .LVU177
 919 0016 C80F      		add r28,r24
 920               	.LVL46:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 921               		.loc 1 268 42 is_stmt 1 discriminator 3 view .LVU178
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 922               		.loc 1 268 25 discriminator 3 view .LVU179
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 923               		.loc 1 268 5 is_stmt 0 discriminator 3 view .LVU180
 924 0018 F0E0      		ldi r31,hi8(matrix+14)
 925 001a 0030      		cpi r16,lo8(matrix+14)
 926 001c 1F07      		cpc r17,r31
 927 001e 01F4      		brne .L36
 928               	.LBE63:
 271:quantum/matrix.c **** }
 929               		.loc 1 271 5 is_stmt 1 view .LVU181
 272:quantum/matrix.c **** 
 930               		.loc 1 272 1 is_stmt 0 view .LVU182
 931 0020 8C2F      		mov r24,r28
 932               	/* epilogue start */
 933 0022 CF91      		pop r28
 934               	.LVL47:
 272:quantum/matrix.c **** 
 935               		.loc 1 272 1 view .LVU183
 936 0024 1F91      		pop r17
 937 0026 0F91      		pop r16
 938               	.LVL48:
 272:quantum/matrix.c **** 
 939               		.loc 1 272 1 view .LVU184
 940 0028 0895      		ret
 941               		.cfi_endproc
 942               	.LFE20:
 944               		.section	.bss.matrix_debouncing,"aw",@nobits
 947               	matrix_debouncing:
 948 0000 0000 0000 		.zero	14
 948      0000 0000 
 948      0000 0000 
 948      0000 
 949               		.section	.bss.matrix,"aw",@nobits
 952               	matrix:
 953 0000 0000 0000 		.zero	14
 953      0000 0000 
 953      0000 0000 
 953      0000 
 954               		.section	.rodata.col_pins,"a"
 957               	col_pins:
 958 0000 31F7 F6   		.ascii	"1\367\366"
 959               		.section	.rodata.row_pins,"a"
 962               	row_pins:
 963 0000 F4F5 9392 		.ascii	"\364\365\223\222\221\220\224f\227\3064532"
 963      9190 9466 
 963      97C6 3435 
 963      3332 
 964               		.section	.bss.debouncing,"aw",@nobits
 967               	debouncing:
 968 0000 00        		.zero	1
 969               		.section	.bss.debouncing_time,"aw",@nobits
 972               	debouncing_time:
 973 0000 0000      		.zero	2
 974               		.text
 975               	.Letext0:
 976               		.file 3 "/usr/avr/include/stdint.h"
 977               		.file 4 "./tmk_core/common/matrix.h"
 978               		.file 5 "./tmk_core/common/util.h"
 979               		.file 6 "./tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/cc0oAi0a.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc0oAi0a.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc0oAi0a.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc0oAi0a.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc0oAi0a.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc0oAi0a.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/cc0oAi0a.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias
     /tmp/cc0oAi0a.s:32     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/cc0oAi0a.s:49     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/cc0oAi0a.s:66     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/cc0oAi0a.s:81     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/cc0oAi0a.s:98     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/cc0oAi0a.s:115    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/cc0oAi0a.s:134    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/cc0oAi0a.s:153    .text.matrix_init:0000000000000000 matrix_init
     /tmp/cc0oAi0a.s:957    .rodata.col_pins:0000000000000000 col_pins
     /tmp/cc0oAi0a.s:962    .rodata.row_pins:0000000000000000 row_pins
     /tmp/cc0oAi0a.s:952    .bss.matrix:0000000000000000 matrix
     /tmp/cc0oAi0a.s:947    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/cc0oAi0a.s:344    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/cc0oAi0a.s:967    .bss.debouncing:0000000000000000 debouncing
     /tmp/cc0oAi0a.s:972    .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/cc0oAi0a.s:769    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/cc0oAi0a.s:791    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/cc0oAi0a.s:827    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/cc0oAi0a.s:854    .text.matrix_print:0000000000000000 matrix_print
     /tmp/cc0oAi0a.s:875    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop
__do_copy_data
__do_clear_bss
