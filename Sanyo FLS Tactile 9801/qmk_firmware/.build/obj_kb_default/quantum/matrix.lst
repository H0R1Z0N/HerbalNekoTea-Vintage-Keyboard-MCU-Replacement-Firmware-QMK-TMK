   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.matrix_init_user,"ax",@progbits
  12               		.weak	matrix_init_user
  14               	matrix_init_user:
  15               	.LFB10:
  16               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012 Jun Wako
   3:quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:quantum/matrix.c **** 
   5:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:quantum/matrix.c **** (at your option) any later version.
   9:quantum/matrix.c **** 
  10:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:quantum/matrix.c **** GNU General Public License for more details.
  14:quantum/matrix.c **** 
  15:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:quantum/matrix.c **** */
  18:quantum/matrix.c **** #include <stdint.h>
  19:quantum/matrix.c **** #include <stdbool.h>
  20:quantum/matrix.c **** #if defined(__AVR__)
  21:quantum/matrix.c **** #include <avr/io.h>
  22:quantum/matrix.c **** #endif
  23:quantum/matrix.c **** #include "wait.h"
  24:quantum/matrix.c **** #include "print.h"
  25:quantum/matrix.c **** #include "debug.h"
  26:quantum/matrix.c **** #include "util.h"
  27:quantum/matrix.c **** #include "matrix.h"
  28:quantum/matrix.c **** #include "timer.h"
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  34:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  35:quantum/matrix.c **** #endif
  36:quantum/matrix.c **** 
  37:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  38:quantum/matrix.c ****     static uint16_t debouncing_time;
  39:quantum/matrix.c ****     static bool debouncing = false;
  40:quantum/matrix.c **** #endif
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  43:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  44:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  45:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  46:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  47:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  48:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  49:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  50:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  51:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  52:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  53:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  54:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  55:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  56:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  57:quantum/matrix.c **** #endif
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** #ifdef MATRIX_MASKED
  60:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  61:quantum/matrix.c **** #endif
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** 
  66:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  67:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** static matrix_row_t matrix_raw[MATRIX_ROWS];
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #else // ROW2COL
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  17               		.loc 1 108 29 view -0
  18               		.cfi_startproc
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 109:quantum/matrix.c **** }
  23               		.loc 1 109 1 view .LVU1
  24               	/* epilogue start */
  25 0000 0895      		ret
  26               		.cfi_endproc
  27               	.LFE10:
  29               		.set	matrix_init_user.localalias,matrix_init_user
  30               		.section	.text.matrix_init_kb,"ax",@progbits
  31               		.weak	matrix_init_kb
  33               	matrix_init_kb:
  34               	.LFB8:
  98:quantum/matrix.c ****     matrix_init_user();
  35               		.loc 1 98 27 view -0
  36               		.cfi_startproc
  37               	/* prologue: function */
  38               	/* frame size = 0 */
  39               	/* stack size = 0 */
  40               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  41               		.loc 1 99 5 view .LVU3
  42 0000 0C94 0000 		jmp matrix_init_user
  43               	.LVL0:
  44               		.cfi_endproc
  45               	.LFE8:
  47               		.section	.text.matrix_init_quantum,"ax",@progbits
  48               		.weak	matrix_init_quantum
  50               	matrix_init_quantum:
  51               	.LFB6:
  88:quantum/matrix.c ****     matrix_init_kb();
  52               		.loc 1 88 32 view -0
  53               		.cfi_startproc
  54               	/* prologue: function */
  55               	/* frame size = 0 */
  56               	/* stack size = 0 */
  57               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  58               		.loc 1 89 5 view .LVU5
  59 0000 0C94 0000 		jmp matrix_init_kb
  60               	.LVL1:
  61               		.cfi_endproc
  62               	.LFE6:
  64               		.section	.text.matrix_scan_user,"ax",@progbits
  65               		.weak	matrix_scan_user
  67               	matrix_scan_user:
  68               	.LFB27:
  69               		.cfi_startproc
  70               	/* prologue: function */
  71               	/* frame size = 0 */
  72               	/* stack size = 0 */
  73               	.L__stack_usage = 0
  74               	/* epilogue start */
  75 0000 0895      		ret
  76               		.cfi_endproc
  77               	.LFE27:
  79               		.section	.text.matrix_scan_kb,"ax",@progbits
  80               		.weak	matrix_scan_kb
  82               	matrix_scan_kb:
  83               	.LFB9:
 103:quantum/matrix.c ****     matrix_scan_user();
  84               		.loc 1 103 27 view -0
  85               		.cfi_startproc
  86               	/* prologue: function */
  87               	/* frame size = 0 */
  88               	/* stack size = 0 */
  89               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  90               		.loc 1 104 5 view .LVU7
  91 0000 0C94 0000 		jmp matrix_scan_user
  92               	.LVL2:
  93               		.cfi_endproc
  94               	.LFE9:
  96               		.section	.text.matrix_scan_quantum,"ax",@progbits
  97               		.weak	matrix_scan_quantum
  99               	matrix_scan_quantum:
 100               	.LFB7:
  93:quantum/matrix.c ****     matrix_scan_kb();
 101               		.loc 1 93 32 view -0
 102               		.cfi_startproc
 103               	/* prologue: function */
 104               	/* frame size = 0 */
 105               	/* stack size = 0 */
 106               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 107               		.loc 1 94 5 view .LVU9
 108 0000 0C94 0000 		jmp matrix_scan_kb
 109               	.LVL3:
 110               		.cfi_endproc
 111               	.LFE7:
 113               		.section	.text.matrix_rows,"ax",@progbits
 114               	.global	matrix_rows
 116               	matrix_rows:
 117               	.LFB12:
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 118               		.loc 1 116 27 view -0
 119               		.cfi_startproc
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 124               		.loc 1 117 5 view .LVU11
 118:quantum/matrix.c **** }
 125               		.loc 1 118 1 is_stmt 0 view .LVU12
 126 0000 89E0      		ldi r24,lo8(9)
 127               	/* epilogue start */
 128 0002 0895      		ret
 129               		.cfi_endproc
 130               	.LFE12:
 132               		.section	.text.matrix_cols,"ax",@progbits
 133               	.global	matrix_cols
 135               	matrix_cols:
 136               	.LFB13:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 137               		.loc 1 121 27 is_stmt 1 view -0
 138               		.cfi_startproc
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 0 */
 142               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 143               		.loc 1 122 5 view .LVU14
 123:quantum/matrix.c **** }
 144               		.loc 1 123 1 is_stmt 0 view .LVU15
 145 0000 82E1      		ldi r24,lo8(18)
 146               	/* epilogue start */
 147 0002 0895      		ret
 148               		.cfi_endproc
 149               	.LFE13:
 151               		.section	.text.matrix_init,"ax",@progbits
 152               	.global	matrix_init
 154               	matrix_init:
 155               	.LFB14:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #else
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 156               		.loc 1 149 24 is_stmt 1 view -0
 157               		.cfi_startproc
 158 0000 CF93      		push r28
 159               	.LCFI0:
 160               		.cfi_def_cfa_offset 3
 161               		.cfi_offset 28, -2
 162 0002 DF93      		push r29
 163               	.LCFI1:
 164               		.cfi_def_cfa_offset 4
 165               		.cfi_offset 29, -3
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 2 */
 169               	.L__stack_usage = 2
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 170               		.loc 1 153 9 view .LVU17
 171               		.loc 1 153 15 is_stmt 0 view .LVU18
 172 0004 85B7      		in r24,0x35
 173 0006 8068      		ori r24,lo8(-128)
 174 0008 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 175               		.loc 1 154 9 is_stmt 1 view .LVU19
 176               		.loc 1 154 15 is_stmt 0 view .LVU20
 177 000a 85B7      		in r24,0x35
 178 000c 8068      		ori r24,lo8(-128)
 179 000e 85BF      		out 0x35,r24
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 180               		.loc 1 159 5 is_stmt 1 view .LVU21
 181               	.LBB19:
 182               	.LBI19:
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #else // ROW2COL
 162:quantum/matrix.c ****     unselect_cols();
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_raw[i] = 0;
 170:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 171:quantum/matrix.c ****     }
 172:quantum/matrix.c **** 
 173:quantum/matrix.c ****     matrix_init_quantum();
 174:quantum/matrix.c **** }
 175:quantum/matrix.c **** 
 176:quantum/matrix.c **** uint8_t matrix_scan(void)
 177:quantum/matrix.c **** {
 178:quantum/matrix.c **** 
 179:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Set row, read cols
 182:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 183:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 184:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 185:quantum/matrix.c **** 
 186:quantum/matrix.c ****             if (matrix_changed) {
 187:quantum/matrix.c ****                 debouncing = true;
 188:quantum/matrix.c ****                 debouncing_time = timer_read();
 189:quantum/matrix.c ****             }
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** #       else
 192:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 193:quantum/matrix.c **** #       endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     }
 196:quantum/matrix.c **** 
 197:quantum/matrix.c **** #else // ROW2COL
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // Set col, read rows
 200:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 201:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 202:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 203:quantum/matrix.c ****             if (matrix_changed) {
 204:quantum/matrix.c ****                 debouncing = true;
 205:quantum/matrix.c ****                 debouncing_time = timer_read();
 206:quantum/matrix.c ****             }
 207:quantum/matrix.c **** #       else
 208:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 209:quantum/matrix.c **** #       endif
 210:quantum/matrix.c **** 
 211:quantum/matrix.c ****     }
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #endif
 214:quantum/matrix.c **** 
 215:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 216:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 217:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 218:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 219:quantum/matrix.c ****             }
 220:quantum/matrix.c ****             debouncing = false;
 221:quantum/matrix.c ****         }
 222:quantum/matrix.c **** #   endif
 223:quantum/matrix.c **** 
 224:quantum/matrix.c ****     matrix_scan_quantum();
 225:quantum/matrix.c ****     return 1;
 226:quantum/matrix.c **** }
 227:quantum/matrix.c **** 
 228:quantum/matrix.c **** bool matrix_is_modified(void)
 229:quantum/matrix.c **** {
 230:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 231:quantum/matrix.c ****     if (debouncing) return false;
 232:quantum/matrix.c **** #endif
 233:quantum/matrix.c ****     return true;
 234:quantum/matrix.c **** }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c **** inline
 237:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 238:quantum/matrix.c **** {
 239:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** inline
 243:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 244:quantum/matrix.c **** {
 245:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 246:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 247:quantum/matrix.c **** #ifdef MATRIX_MASKED
 248:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 249:quantum/matrix.c **** #else
 250:quantum/matrix.c ****     return matrix[row];
 251:quantum/matrix.c **** #endif
 252:quantum/matrix.c **** }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c **** void matrix_print(void)
 255:quantum/matrix.c **** {
 256:quantum/matrix.c ****     print_matrix_header();
 257:quantum/matrix.c **** 
 258:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 259:quantum/matrix.c ****         phex(row); print(": ");
 260:quantum/matrix.c ****         print_matrix_row(row);
 261:quantum/matrix.c ****         print("\n");
 262:quantum/matrix.c ****     }
 263:quantum/matrix.c **** }
 264:quantum/matrix.c **** 
 265:quantum/matrix.c **** uint8_t matrix_key_count(void)
 266:quantum/matrix.c **** {
 267:quantum/matrix.c ****     uint8_t count = 0;
 268:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 269:quantum/matrix.c ****         count += matrix_bitpop(i);
 270:quantum/matrix.c ****     }
 271:quantum/matrix.c ****     return count;
 272:quantum/matrix.c **** }
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** 
 276:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 277:quantum/matrix.c **** 
 278:quantum/matrix.c **** static void init_cols(void)
 279:quantum/matrix.c **** {
 280:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 281:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 283:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 284:quantum/matrix.c ****     }
 285:quantum/matrix.c **** }
 286:quantum/matrix.c **** 
 287:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 288:quantum/matrix.c **** {
 289:quantum/matrix.c ****     // Store last value of row prior to reading
 290:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 291:quantum/matrix.c **** 
 292:quantum/matrix.c ****     // Clear data in matrix row
 293:quantum/matrix.c ****     current_matrix[current_row] = 0;
 294:quantum/matrix.c **** 
 295:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 296:quantum/matrix.c ****     select_row(current_row);
 297:quantum/matrix.c ****     wait_us(30);
 298:quantum/matrix.c **** 
 299:quantum/matrix.c ****     // For each col...
 300:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 301:quantum/matrix.c **** 
 302:quantum/matrix.c ****         // Select the col pin to read (active low)
 303:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 304:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 305:quantum/matrix.c **** 
 306:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 307:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 308:quantum/matrix.c ****     }
 309:quantum/matrix.c **** 
 310:quantum/matrix.c ****     // Unselect row
 311:quantum/matrix.c ****     unselect_row(current_row);
 312:quantum/matrix.c **** 
 313:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 314:quantum/matrix.c **** }
 315:quantum/matrix.c **** 
 316:quantum/matrix.c **** static void select_row(uint8_t row)
 317:quantum/matrix.c **** {
 318:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 320:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 321:quantum/matrix.c **** }
 322:quantum/matrix.c **** 
 323:quantum/matrix.c **** static void unselect_row(uint8_t row)
 324:quantum/matrix.c **** {
 325:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 327:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 328:quantum/matrix.c **** }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c **** static void unselect_rows(void)
 183               		.loc 1 330 13 view .LVU22
 184               	.LBE19:
 331:quantum/matrix.c **** {
 332:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 185               		.loc 1 332 5 view .LVU23
 186               	.LBB22:
 187               	.LBB20:
 188               		.loc 1 332 9 view .LVU24
 189               	.LVL4:
 190               		.loc 1 332 24 view .LVU25
 191 0010 C0E0      		ldi r28,lo8(row_pins)
 192 0012 D0E0      		ldi r29,hi8(row_pins)
 193 0014 20E0      		ldi r18,lo8(row_pins+9)
 194 0016 30E0      		ldi r19,hi8(row_pins+9)
 195               	.LBB21:
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 196               		.loc 1 334 38 is_stmt 0 view .LVU26
 197 0018 41E0      		ldi r20,lo8(1)
 198 001a 50E0      		ldi r21,0
 199               	.LVL5:
 200               	.L10:
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 201               		.loc 1 333 9 is_stmt 1 view .LVU27
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 202               		.loc 1 333 17 is_stmt 0 view .LVU28
 203 001c 8991      		ld r24,Y+
 204               	.LVL6:
 205               		.loc 1 334 9 is_stmt 1 view .LVU29
 206               		.loc 1 334 34 is_stmt 0 view .LVU30
 207 001e E82F      		mov r30,r24
 208 0020 E295      		swap r30
 209 0022 EF70      		andi r30,lo8(15)
 210 0024 A1E2      		ldi r26,lo8(33)
 211 0026 AE0F      		add r26,r30
 212 0028 B0E0      		ldi r27,0
 213 002a FC91      		ld r31,X
 214               		.loc 1 334 38 view .LVU31
 215 002c 8F70      		andi r24,lo8(15)
 216               	.LVL7:
 217               		.loc 1 334 38 view .LVU32
 218 002e BA01      		movw r22,r20
 219 0030 00C0      		rjmp 2f
 220               		1:
 221 0032 660F      		lsl r22
 222               		2:
 223 0034 8A95      		dec r24
 224 0036 02F4      		brpl 1b
 225               		.loc 1 334 34 view .LVU33
 226 0038 962F      		mov r25,r22
 227 003a 9095      		com r25
 228 003c 9F23      		and r25,r31
 229 003e 9C93      		st X,r25
 230               	.LVL8:
 335:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 231               		.loc 1 335 9 is_stmt 1 view .LVU34
 232               		.loc 1 335 34 is_stmt 0 view .LVU35
 233 0040 EE5D      		subi r30,lo8(-(34))
 234 0042 F0E0      		ldi r31,0
 235 0044 8081      		ld r24,Z
 236 0046 862B      		or r24,r22
 237 0048 8083      		st Z,r24
 238               	.LBE21:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 239               		.loc 1 332 41 is_stmt 1 view .LVU36
 240               	.LVL9:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 241               		.loc 1 332 24 view .LVU37
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 242               		.loc 1 332 5 is_stmt 0 view .LVU38
 243 004a 2C17      		cp r18,r28
 244 004c 3D07      		cpc r19,r29
 245 004e 01F4      		brne .L10
 246 0050 C0E0      		ldi r28,lo8(col_pins)
 247 0052 D0E0      		ldi r29,hi8(col_pins)
 248               	.LVL10:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 249               		.loc 1 332 5 view .LVU39
 250 0054 20E0      		ldi r18,lo8(col_pins+18)
 251 0056 30E0      		ldi r19,hi8(col_pins+18)
 252               	.LBE20:
 253               	.LBE22:
 254               	.LBB23:
 255               	.LBB24:
 256               	.LBB25:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 257               		.loc 1 282 38 view .LVU40
 258 0058 41E0      		ldi r20,lo8(1)
 259 005a 50E0      		ldi r21,0
 260               	.L11:
 261               	.LVL11:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 262               		.loc 1 281 9 is_stmt 1 view .LVU41
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 263               		.loc 1 281 17 is_stmt 0 view .LVU42
 264 005c 8991      		ld r24,Y+
 265               	.LVL12:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 266               		.loc 1 282 9 is_stmt 1 view .LVU43
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 267               		.loc 1 282 34 is_stmt 0 view .LVU44
 268 005e E82F      		mov r30,r24
 269 0060 E295      		swap r30
 270 0062 EF70      		andi r30,lo8(15)
 271 0064 A1E2      		ldi r26,lo8(33)
 272 0066 AE0F      		add r26,r30
 273 0068 B0E0      		ldi r27,0
 274 006a FC91      		ld r31,X
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 275               		.loc 1 282 38 view .LVU45
 276 006c 8F70      		andi r24,lo8(15)
 277               	.LVL13:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 278               		.loc 1 282 38 view .LVU46
 279 006e BA01      		movw r22,r20
 280 0070 00C0      		rjmp 2f
 281               		1:
 282 0072 660F      		lsl r22
 283               		2:
 284 0074 8A95      		dec r24
 285 0076 02F4      		brpl 1b
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 286               		.loc 1 282 34 view .LVU47
 287 0078 962F      		mov r25,r22
 288 007a 9095      		com r25
 289 007c 9F23      		and r25,r31
 290 007e 9C93      		st X,r25
 291               	.LVL14:
 283:quantum/matrix.c ****     }
 292               		.loc 1 283 9 is_stmt 1 view .LVU48
 283:quantum/matrix.c ****     }
 293               		.loc 1 283 34 is_stmt 0 view .LVU49
 294 0080 EE5D      		subi r30,lo8(-(34))
 295 0082 F0E0      		ldi r31,0
 296 0084 8081      		ld r24,Z
 297 0086 862B      		or r24,r22
 298 0088 8083      		st Z,r24
 299               	.LBE25:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 300               		.loc 1 280 41 is_stmt 1 view .LVU50
 301               	.LVL15:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 302               		.loc 1 280 24 view .LVU51
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 303               		.loc 1 280 5 is_stmt 0 view .LVU52
 304 008a 2C17      		cp r18,r28
 305 008c 3D07      		cpc r19,r29
 306 008e 01F4      		brne .L11
 307               	.LBE24:
 308               	.LBE23:
 309               	.LBB26:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 310               		.loc 1 168 19 view .LVU53
 311 0090 84E2      		ldi r24,lo8(36)
 312 0092 E0E0      		ldi r30,lo8(matrix)
 313 0094 F0E0      		ldi r31,hi8(matrix)
 314 0096 DF01      		movw r26,r30
 315 0098 982F      		mov r25,r24
 316               		0:
 317 009a 1D92      		st X+,__zero_reg__
 318 009c 9A95      		dec r25
 319 009e 01F4      		brne 0b
 170:quantum/matrix.c ****     }
 320               		.loc 1 170 30 view .LVU54
 321 00a0 E0E0      		ldi r30,lo8(matrix_debouncing)
 322 00a2 F0E0      		ldi r31,hi8(matrix_debouncing)
 323 00a4 DF01      		movw r26,r30
 324               		0:
 325 00a6 1D92      		st X+,__zero_reg__
 326 00a8 8A95      		dec r24
 327 00aa 01F4      		brne 0b
 328               	.LVL16:
 170:quantum/matrix.c ****     }
 329               		.loc 1 170 30 view .LVU55
 330               	.LBE26:
 173:quantum/matrix.c **** }
 331               		.loc 1 173 5 is_stmt 1 view .LVU56
 332               	/* epilogue start */
 174:quantum/matrix.c **** 
 333               		.loc 1 174 1 is_stmt 0 view .LVU57
 334 00ac DF91      		pop r29
 335 00ae CF91      		pop r28
 173:quantum/matrix.c **** }
 336               		.loc 1 173 5 view .LVU58
 337 00b0 0C94 0000 		jmp matrix_init_quantum
 338               	.LVL17:
 339               		.cfi_endproc
 340               	.LFE14:
 342               		.section	.text.matrix_scan,"ax",@progbits
 343               	.global	matrix_scan
 345               	matrix_scan:
 346               	.LFB15:
 177:quantum/matrix.c **** 
 347               		.loc 1 177 1 is_stmt 1 view -0
 348               		.cfi_startproc
 349 0000 2F92      		push r2
 350               	.LCFI2:
 351               		.cfi_def_cfa_offset 3
 352               		.cfi_offset 2, -2
 353 0002 3F92      		push r3
 354               	.LCFI3:
 355               		.cfi_def_cfa_offset 4
 356               		.cfi_offset 3, -3
 357 0004 4F92      		push r4
 358               	.LCFI4:
 359               		.cfi_def_cfa_offset 5
 360               		.cfi_offset 4, -4
 361 0006 5F92      		push r5
 362               	.LCFI5:
 363               		.cfi_def_cfa_offset 6
 364               		.cfi_offset 5, -5
 365 0008 6F92      		push r6
 366               	.LCFI6:
 367               		.cfi_def_cfa_offset 7
 368               		.cfi_offset 6, -6
 369 000a 7F92      		push r7
 370               	.LCFI7:
 371               		.cfi_def_cfa_offset 8
 372               		.cfi_offset 7, -7
 373 000c 8F92      		push r8
 374               	.LCFI8:
 375               		.cfi_def_cfa_offset 9
 376               		.cfi_offset 8, -8
 377 000e 9F92      		push r9
 378               	.LCFI9:
 379               		.cfi_def_cfa_offset 10
 380               		.cfi_offset 9, -9
 381 0010 AF92      		push r10
 382               	.LCFI10:
 383               		.cfi_def_cfa_offset 11
 384               		.cfi_offset 10, -10
 385 0012 BF92      		push r11
 386               	.LCFI11:
 387               		.cfi_def_cfa_offset 12
 388               		.cfi_offset 11, -11
 389 0014 CF92      		push r12
 390               	.LCFI12:
 391               		.cfi_def_cfa_offset 13
 392               		.cfi_offset 12, -12
 393 0016 DF92      		push r13
 394               	.LCFI13:
 395               		.cfi_def_cfa_offset 14
 396               		.cfi_offset 13, -13
 397 0018 EF92      		push r14
 398               	.LCFI14:
 399               		.cfi_def_cfa_offset 15
 400               		.cfi_offset 14, -14
 401 001a FF92      		push r15
 402               	.LCFI15:
 403               		.cfi_def_cfa_offset 16
 404               		.cfi_offset 15, -15
 405 001c 0F93      		push r16
 406               	.LCFI16:
 407               		.cfi_def_cfa_offset 17
 408               		.cfi_offset 16, -16
 409 001e 1F93      		push r17
 410               	.LCFI17:
 411               		.cfi_def_cfa_offset 18
 412               		.cfi_offset 17, -17
 413 0020 CF93      		push r28
 414               	.LCFI18:
 415               		.cfi_def_cfa_offset 19
 416               		.cfi_offset 28, -18
 417 0022 DF93      		push r29
 418               	.LCFI19:
 419               		.cfi_def_cfa_offset 20
 420               		.cfi_offset 29, -19
 421 0024 CDB7      		in r28,__SP_L__
 422 0026 DEB7      		in r29,__SP_H__
 423               	.LCFI20:
 424               		.cfi_def_cfa_register 28
 425 0028 2A97      		sbiw r28,10
 426               	.LCFI21:
 427               		.cfi_def_cfa_offset 30
 428 002a 0FB6      		in __tmp_reg__,__SREG__
 429 002c F894      		cli
 430 002e DEBF      		out __SP_H__,r29
 431 0030 0FBE      		out __SREG__,__tmp_reg__
 432 0032 CDBF      		out __SP_L__,r28
 433               	/* prologue: function */
 434               	/* frame size = 10 */
 435               	/* stack size = 28 */
 436               	.L__stack_usage = 28
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 437               		.loc 1 182 5 view .LVU60
 438               	.LBB40:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 439               		.loc 1 182 10 view .LVU61
 440               	.LVL18:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 441               		.loc 1 182 35 view .LVU62
 442 0034 20E0      		ldi r18,lo8(matrix_debouncing)
 443 0036 30E0      		ldi r19,hi8(matrix_debouncing)
 444 0038 3887      		std Y+8,r19
 445 003a 2F83      		std Y+7,r18
 446 003c 40E0      		ldi r20,lo8(row_pins)
 447 003e 50E0      		ldi r21,hi8(row_pins)
 448 0040 5E83      		std Y+6,r21
 449 0042 4D83      		std Y+5,r20
 450               	.LBB41:
 451               	.LBB42:
 452               	.LBB43:
 453               	.LBB44:
 454               	.LBB45:
 307:quantum/matrix.c ****     }
 455               		.loc 1 307 55 is_stmt 0 view .LVU63
 456 0044 212C      		mov r2,__zero_reg__
 457 0046 312C      		mov r3,__zero_reg__
 458 0048 2101      		movw r4,r2
 459 004a 2394      		inc r2
 460               	.LBE45:
 461               	.LBE44:
 462               	.LBE43:
 463               	.LBE42:
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 464               		.loc 1 187 28 view .LVU64
 465 004c 6624      		clr r6
 466 004e 6394      		inc r6
 467               	.LVL19:
 468               	.L18:
 184:quantum/matrix.c **** 
 469               		.loc 1 184 13 is_stmt 1 view .LVU65
 470               	.LBB61:
 471               	.LBI42:
 287:quantum/matrix.c **** {
 472               		.loc 1 287 13 view .LVU66
 473               	.LBB59:
 290:quantum/matrix.c **** 
 474               		.loc 1 290 5 view .LVU67
 290:quantum/matrix.c **** 
 475               		.loc 1 290 18 is_stmt 0 view .LVU68
 476 0050 EF81      		ldd r30,Y+7
 477 0052 F885      		ldd r31,Y+8
 478 0054 8190      		ld r8,Z+
 479 0056 9190      		ld r9,Z+
 480 0058 A190      		ld r10,Z+
 481 005a B190      		ld r11,Z+
 482 005c F887      		std Y+8,r31
 483 005e EF83      		std Y+7,r30
 484               	.LVL20:
 293:quantum/matrix.c **** 
 485               		.loc 1 293 5 is_stmt 1 view .LVU69
 293:quantum/matrix.c **** 
 486               		.loc 1 293 33 is_stmt 0 view .LVU70
 487 0060 1292      		st -Z,__zero_reg__
 488 0062 1292      		st -Z,__zero_reg__
 489 0064 1292      		st -Z,__zero_reg__
 490 0066 1292      		st -Z,__zero_reg__
 491 0068 CF01      		movw r24,r30
 296:quantum/matrix.c ****     wait_us(30);
 492               		.loc 1 296 5 is_stmt 1 view .LVU71
 493               	.LVL21:
 494               	.LBB48:
 495               	.LBI48:
 316:quantum/matrix.c **** {
 496               		.loc 1 316 13 view .LVU72
 497               	.LBB49:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 498               		.loc 1 318 5 view .LVU73
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 499               		.loc 1 318 13 is_stmt 0 view .LVU74
 500 006a ED81      		ldd r30,Y+5
 501 006c FE81      		ldd r31,Y+6
 502 006e 2191      		ld r18,Z+
 503 0070 FE83      		std Y+6,r31
 504 0072 ED83      		std Y+5,r30
 505               	.LVL22:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 506               		.loc 1 319 5 is_stmt 1 view .LVU75
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 507               		.loc 1 319 30 is_stmt 0 view .LVU76
 508 0074 E22F      		mov r30,r18
 509 0076 E295      		swap r30
 510 0078 EF70      		andi r30,lo8(15)
 511 007a A1E2      		ldi r26,lo8(33)
 512 007c AE0F      		add r26,r30
 513 007e B0E0      		ldi r27,0
 514 0080 3C91      		ld r19,X
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 515               		.loc 1 319 34 view .LVU77
 516 0082 2F70      		andi r18,lo8(15)
 517               	.LVL23:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 518               		.loc 1 319 34 view .LVU78
 519 0084 41E0      		ldi r20,lo8(1)
 520 0086 50E0      		ldi r21,0
 521 0088 00C0      		rjmp 2f
 522               		1:
 523 008a 440F      		lsl r20
 524 008c 551F      		rol r21
 525               		2:
 526 008e 2A95      		dec r18
 527 0090 02F4      		brpl 1b
 528 0092 5A83      		std Y+2,r21
 529 0094 4983      		std Y+1,r20
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 530               		.loc 1 319 30 view .LVU79
 531 0096 242F      		mov r18,r20
 532 0098 232B      		or r18,r19
 533 009a 2C93      		st X,r18
 320:quantum/matrix.c **** }
 534               		.loc 1 320 5 is_stmt 1 view .LVU80
 320:quantum/matrix.c **** }
 535               		.loc 1 320 30 is_stmt 0 view .LVU81
 536 009c EE5D      		subi r30,lo8(-(34))
 537 009e 2E2F      		mov r18,r30
 538 00a0 30E0      		ldi r19,0
 539 00a2 3A87      		std Y+10,r19
 540 00a4 2987      		std Y+9,r18
 541 00a6 F901      		movw r30,r18
 542 00a8 2081      		ld r18,Z
 543 00aa 742E      		mov r7,r20
 544 00ac 7094      		com r7
 545 00ae 2721      		and r18,r7
 546 00b0 2083      		st Z,r18
 320:quantum/matrix.c **** }
 547               		.loc 1 320 30 view .LVU82
 548               	.LBE49:
 549               	.LBE48:
 297:quantum/matrix.c **** 
 550               		.loc 1 297 5 is_stmt 1 view .LVU83
 551               	.LVL24:
 552               	.LBB50:
 553               	.LBI50:
 554               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 555               		.loc 2 255 1 view .LVU84
 556               	.LBB51:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 557               		.loc 2 257 2 view .LVU85
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 558               		.loc 2 261 2 view .LVU86
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 559               		.loc 2 262 2 view .LVU87
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 560               		.loc 2 263 2 view .LVU88
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 561               		.loc 2 273 3 view .LVU89
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 562               		.loc 2 276 2 view .LVU90
 563 00b2 F0EA      		ldi r31,lo8(-96)
 564 00b4 FA95      	1:	dec r31
 565 00b6 01F4      		brne 1b
 566               	.LVL25:
 567               		.loc 2 276 2 is_stmt 0 view .LVU91
 568               	.LBE51:
 569               	.LBE50:
 300:quantum/matrix.c **** 
 570               		.loc 1 300 5 is_stmt 1 view .LVU92
 571               	.LBB53:
 300:quantum/matrix.c **** 
 572               		.loc 1 300 9 view .LVU93
 300:quantum/matrix.c **** 
 573               		.loc 1 300 32 view .LVU94
 574 00b8 20E0      		ldi r18,lo8(col_pins)
 575 00ba 30E0      		ldi r19,hi8(col_pins)
 576 00bc 3C83      		std Y+4,r19
 577 00be 2B83      		std Y+3,r18
 578               	.LBE53:
 579               	.LBB54:
 580               	.LBB52:
 581               		.loc 2 276 2 is_stmt 0 view .LVU95
 582 00c0 10E0      		ldi r17,0
 583 00c2 00E0      		ldi r16,0
 584               	.LVL26:
 585               	.L16:
 586               		.loc 2 276 2 view .LVU96
 587               	.LBE52:
 588               	.LBE54:
 589               	.LBB55:
 590               	.LBB46:
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 591               		.loc 1 303 9 is_stmt 1 view .LVU97
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 592               		.loc 1 303 17 is_stmt 0 view .LVU98
 593 00c4 EB81      		ldd r30,Y+3
 594 00c6 FC81      		ldd r31,Y+4
 595 00c8 4191      		ld r20,Z+
 596 00ca FC83      		std Y+4,r31
 597 00cc EB83      		std Y+3,r30
 598               	.LVL27:
 304:quantum/matrix.c **** 
 599               		.loc 1 304 9 is_stmt 1 view .LVU99
 304:quantum/matrix.c **** 
 600               		.loc 1 304 30 is_stmt 0 view .LVU100
 601 00ce 242F      		mov r18,r20
 602 00d0 2295      		swap r18
 603 00d2 2F70      		andi r18,lo8(15)
 604 00d4 205E      		subi r18,lo8(-(32))
 605 00d6 30E0      		ldi r19,0
 606 00d8 F901      		movw r30,r18
 607 00da 5081      		ld r21,Z
 608               	.LVL28:
 307:quantum/matrix.c ****     }
 609               		.loc 1 307 9 is_stmt 1 view .LVU101
 307:quantum/matrix.c ****     }
 610               		.loc 1 307 37 is_stmt 0 view .LVU102
 611 00dc FC01      		movw r30,r24
 612 00de C080      		ld r12,Z
 613 00e0 D180      		ldd r13,Z+1
 614 00e2 E280      		ldd r14,Z+2
 615 00e4 F380      		ldd r15,Z+3
 304:quantum/matrix.c **** 
 616               		.loc 1 304 51 view .LVU103
 617 00e6 4F70      		andi r20,lo8(15)
 618               	.LVL29:
 304:quantum/matrix.c **** 
 619               		.loc 1 304 51 view .LVU104
 620 00e8 21E0      		ldi r18,lo8(1)
 621 00ea 30E0      		ldi r19,0
 622 00ec 00C0      		rjmp 2f
 623               		1:
 624 00ee 220F      		lsl r18
 625               		2:
 626 00f0 4A95      		dec r20
 627 00f2 02F4      		brpl 1b
 304:quantum/matrix.c **** 
 628               		.loc 1 304 49 view .LVU105
 629 00f4 2523      		and r18,r21
 307:quantum/matrix.c ****     }
 630               		.loc 1 307 55 view .LVU106
 631 00f6 01F0      		breq .+2
 632 00f8 00C0      		rjmp .L22
 633 00fa B201      		movw r22,r4
 634 00fc A101      		movw r20,r2
 635               	.LVL30:
 307:quantum/matrix.c ****     }
 636               		.loc 1 307 55 view .LVU107
 637 00fe 002E      		mov r0,r16
 638 0100 00C0      		rjmp 2f
 639               		1:
 640 0102 440F      		lsl r20
 641 0104 551F      		rol r21
 642 0106 661F      		rol r22
 643 0108 771F      		rol r23
 644               		2:
 645 010a 0A94      		dec r0
 646 010c 02F4      		brpl 1b
 647               	.L15:
 307:quantum/matrix.c ****     }
 648               		.loc 1 307 37 view .LVU108
 649 010e 4C29      		or r20,r12
 650 0110 5D29      		or r21,r13
 651 0112 6E29      		or r22,r14
 652 0114 7F29      		or r23,r15
 653 0116 FC01      		movw r30,r24
 654 0118 4083      		st Z,r20
 655 011a 5183      		std Z+1,r21
 656 011c 6283      		std Z+2,r22
 657 011e 7383      		std Z+3,r23
 658               	.LBE46:
 300:quantum/matrix.c **** 
 659               		.loc 1 300 57 is_stmt 1 view .LVU109
 660               	.LVL31:
 300:quantum/matrix.c **** 
 661               		.loc 1 300 32 view .LVU110
 300:quantum/matrix.c **** 
 662               		.loc 1 300 5 is_stmt 0 view .LVU111
 663 0120 0F5F      		subi r16,-1
 664 0122 1F4F      		sbci r17,-1
 665               	.LVL32:
 300:quantum/matrix.c **** 
 666               		.loc 1 300 5 view .LVU112
 667 0124 0231      		cpi r16,18
 668 0126 1105      		cpc r17,__zero_reg__
 669 0128 01F4      		brne .L16
 670               	.LBE55:
 311:quantum/matrix.c **** 
 671               		.loc 1 311 5 is_stmt 1 view .LVU113
 672               	.LVL33:
 673               	.LBB56:
 674               	.LBI56:
 323:quantum/matrix.c **** {
 675               		.loc 1 323 13 view .LVU114
 676               	.LBB57:
 325:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 677               		.loc 1 325 5 view .LVU115
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 678               		.loc 1 326 5 view .LVU116
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 679               		.loc 1 326 30 is_stmt 0 view .LVU117
 680 012a 2C91      		ld r18,X
 681 012c 7222      		and r7,r18
 682 012e 7C92      		st X,r7
 327:quantum/matrix.c **** }
 683               		.loc 1 327 5 is_stmt 1 view .LVU118
 327:quantum/matrix.c **** }
 684               		.loc 1 327 30 is_stmt 0 view .LVU119
 685 0130 E985      		ldd r30,Y+9
 686 0132 FA85      		ldd r31,Y+10
 687 0134 2081      		ld r18,Z
 688 0136 F981      		ldd r31,Y+1
 689 0138 2F2B      		or r18,r31
 690 013a E985      		ldd r30,Y+9
 691 013c FA85      		ldd r31,Y+10
 692 013e 2083      		st Z,r18
 327:quantum/matrix.c **** }
 693               		.loc 1 327 30 view .LVU120
 694               	.LBE57:
 695               	.LBE56:
 313:quantum/matrix.c **** }
 696               		.loc 1 313 5 is_stmt 1 view .LVU121
 697               	.LVL34:
 313:quantum/matrix.c **** }
 698               		.loc 1 313 5 is_stmt 0 view .LVU122
 699               	.LBE59:
 700               	.LBE61:
 186:quantum/matrix.c ****                 debouncing = true;
 701               		.loc 1 186 13 is_stmt 1 view .LVU123
 186:quantum/matrix.c ****                 debouncing = true;
 702               		.loc 1 186 16 is_stmt 0 view .LVU124
 703 0140 FC01      		movw r30,r24
 704 0142 8081      		ld r24,Z
 705 0144 9181      		ldd r25,Z+1
 706 0146 A281      		ldd r26,Z+2
 707 0148 B381      		ldd r27,Z+3
 708               	.LVL35:
 186:quantum/matrix.c ****                 debouncing = true;
 709               		.loc 1 186 16 view .LVU125
 710 014a 8816      		cp r8,r24
 711 014c 9906      		cpc r9,r25
 712 014e AA06      		cpc r10,r26
 713 0150 BB06      		cpc r11,r27
 714 0152 01F0      		breq .L17
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 715               		.loc 1 187 17 is_stmt 1 view .LVU126
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 716               		.loc 1 187 28 is_stmt 0 view .LVU127
 717 0154 6092 0000 		sts debouncing,r6
 188:quantum/matrix.c ****             }
 718               		.loc 1 188 17 is_stmt 1 view .LVU128
 188:quantum/matrix.c ****             }
 719               		.loc 1 188 35 is_stmt 0 view .LVU129
 720 0158 0E94 0000 		call timer_read
 721               	.LVL36:
 188:quantum/matrix.c ****             }
 722               		.loc 1 188 33 view .LVU130
 723 015c 9093 0000 		sts debouncing_time+1,r25
 724 0160 8093 0000 		sts debouncing_time,r24
 725               	.L17:
 726               	.LBE41:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 727               		.loc 1 182 62 is_stmt 1 discriminator 2 view .LVU131
 728               	.LVL37:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 729               		.loc 1 182 35 discriminator 2 view .LVU132
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 730               		.loc 1 182 5 is_stmt 0 discriminator 2 view .LVU133
 731 0164 20E0      		ldi r18,lo8(matrix_debouncing+36)
 732 0166 30E0      		ldi r19,hi8(matrix_debouncing+36)
 733 0168 4F81      		ldd r20,Y+7
 734 016a 5885      		ldd r21,Y+8
 735 016c 2417      		cp r18,r20
 736 016e 3507      		cpc r19,r21
 737 0170 01F0      		breq .+2
 738 0172 00C0      		rjmp .L18
 739               	.LBE40:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 740               		.loc 1 216 9 is_stmt 1 view .LVU134
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 741               		.loc 1 216 12 is_stmt 0 view .LVU135
 742 0174 8091 0000 		lds r24,debouncing
 743 0178 8823      		tst r24
 744 017a 01F0      		breq .L20
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 745               		.loc 1 216 28 discriminator 1 view .LVU136
 746 017c 8091 0000 		lds r24,debouncing_time
 747 0180 9091 0000 		lds r25,debouncing_time+1
 748 0184 0E94 0000 		call timer_elapsed
 749               	.LVL38:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 750               		.loc 1 216 24 discriminator 1 view .LVU137
 751 0188 0697      		sbiw r24,6
 752 018a 00F0      		brlo .L20
 753               	.LBB64:
 218:quantum/matrix.c ****             }
 754               		.loc 1 218 27 view .LVU138
 755 018c 84E2      		ldi r24,lo8(36)
 756 018e E0E0      		ldi r30,lo8(matrix_debouncing)
 757 0190 F0E0      		ldi r31,hi8(matrix_debouncing)
 758 0192 A0E0      		ldi r26,lo8(matrix)
 759 0194 B0E0      		ldi r27,hi8(matrix)
 760               		0:
 761 0196 0190      		ld r0,Z+
 762 0198 0D92      		st X+,r0
 763 019a 8A95      		dec r24
 764 019c 01F4      		brne 0b
 765               	.LBE64:
 220:quantum/matrix.c ****         }
 766               		.loc 1 220 13 is_stmt 1 view .LVU139
 220:quantum/matrix.c ****         }
 767               		.loc 1 220 24 is_stmt 0 view .LVU140
 768 019e 1092 0000 		sts debouncing,__zero_reg__
 769               	.L20:
 224:quantum/matrix.c ****     return 1;
 770               		.loc 1 224 5 is_stmt 1 view .LVU141
 771 01a2 0E94 0000 		call matrix_scan_quantum
 772               	.LVL39:
 225:quantum/matrix.c **** }
 773               		.loc 1 225 5 view .LVU142
 226:quantum/matrix.c **** 
 774               		.loc 1 226 1 is_stmt 0 view .LVU143
 775 01a6 81E0      		ldi r24,lo8(1)
 776               	/* epilogue start */
 777 01a8 2A96      		adiw r28,10
 778 01aa 0FB6      		in __tmp_reg__,__SREG__
 779 01ac F894      		cli
 780 01ae DEBF      		out __SP_H__,r29
 781 01b0 0FBE      		out __SREG__,__tmp_reg__
 782 01b2 CDBF      		out __SP_L__,r28
 783 01b4 DF91      		pop r29
 784 01b6 CF91      		pop r28
 785 01b8 1F91      		pop r17
 786 01ba 0F91      		pop r16
 787 01bc FF90      		pop r15
 788 01be EF90      		pop r14
 789 01c0 DF90      		pop r13
 790 01c2 CF90      		pop r12
 791 01c4 BF90      		pop r11
 792 01c6 AF90      		pop r10
 793 01c8 9F90      		pop r9
 794 01ca 8F90      		pop r8
 226:quantum/matrix.c **** 
 795               		.loc 1 226 1 view .LVU144
 796 01cc 7F90      		pop r7
 797 01ce 6F90      		pop r6
 798 01d0 5F90      		pop r5
 799 01d2 4F90      		pop r4
 800 01d4 3F90      		pop r3
 801 01d6 2F90      		pop r2
 802 01d8 0895      		ret
 803               	.LVL40:
 804               	.L22:
 805               	.LBB65:
 806               	.LBB63:
 807               	.LBB62:
 808               	.LBB60:
 809               	.LBB58:
 810               	.LBB47:
 307:quantum/matrix.c ****     }
 811               		.loc 1 307 55 view .LVU145
 812 01da 40E0      		ldi r20,0
 813               	.LVL41:
 307:quantum/matrix.c ****     }
 814               		.loc 1 307 55 view .LVU146
 815 01dc 50E0      		ldi r21,0
 816 01de 60E0      		ldi r22,0
 817 01e0 70E0      		ldi r23,0
 818 01e2 00C0      		rjmp .L15
 819               	.LBE47:
 820               	.LBE58:
 821               	.LBE60:
 822               	.LBE62:
 823               	.LBE63:
 824               	.LBE65:
 825               		.cfi_endproc
 826               	.LFE15:
 828               		.section	.text.matrix_is_modified,"ax",@progbits
 829               	.global	matrix_is_modified
 831               	matrix_is_modified:
 832               	.LFB16:
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 833               		.loc 1 229 1 is_stmt 1 view -0
 834               		.cfi_startproc
 835               	/* prologue: function */
 836               	/* frame size = 0 */
 837               	/* stack size = 0 */
 838               	.L__stack_usage = 0
 231:quantum/matrix.c **** #endif
 839               		.loc 1 231 5 view .LVU148
 231:quantum/matrix.c **** #endif
 840               		.loc 1 231 8 is_stmt 0 view .LVU149
 841 0000 9091 0000 		lds r25,debouncing
 234:quantum/matrix.c **** 
 842               		.loc 1 234 1 view .LVU150
 843 0004 81E0      		ldi r24,lo8(1)
 844 0006 8927      		eor r24,r25
 845               	/* epilogue start */
 846 0008 0895      		ret
 847               		.cfi_endproc
 848               	.LFE16:
 850               		.section	.text.matrix_is_on,"ax",@progbits
 851               	.global	matrix_is_on
 853               	matrix_is_on:
 854               	.LVL42:
 855               	.LFB17:
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 856               		.loc 1 238 1 is_stmt 1 view -0
 857               		.cfi_startproc
 858               	/* prologue: function */
 859               	/* frame size = 0 */
 860               	/* stack size = 0 */
 861               	.L__stack_usage = 0
 239:quantum/matrix.c **** }
 862               		.loc 1 239 5 view .LVU152
 239:quantum/matrix.c **** }
 863               		.loc 1 239 19 is_stmt 0 view .LVU153
 864 0000 94E0      		ldi r25,lo8(4)
 865 0002 899F      		mul r24,r25
 866 0004 F001      		movw r30,r0
 867 0006 1124      		clr __zero_reg__
 868 0008 E050      		subi r30,lo8(-(matrix))
 869 000a F040      		sbci r31,hi8(-(matrix))
 239:quantum/matrix.c **** }
 870               		.loc 1 239 43 view .LVU154
 871 000c 81E0      		ldi r24,lo8(1)
 872 000e 90E0      		ldi r25,0
 873 0010 A0E0      		ldi r26,0
 874 0012 B0E0      		ldi r27,0
 875               	.LVL43:
 239:quantum/matrix.c **** }
 876               		.loc 1 239 43 view .LVU155
 877 0014 6230      		cpi r22,lo8(2)
 878 0016 00F4      		brsh .L27
 879 0018 80E0      		ldi r24,0
 880 001a 90E0      		ldi r25,0
 881 001c DC01      		movw r26,r24
 882               	.L27:
 239:quantum/matrix.c **** }
 883               		.loc 1 239 25 view .LVU156
 884 001e 4081      		ld r20,Z
 885 0020 5181      		ldd r21,Z+1
 886 0022 6281      		ldd r22,Z+2
 887 0024 7381      		ldd r23,Z+3
 888 0026 8423      		and r24,r20
 240:quantum/matrix.c **** 
 889               		.loc 1 240 1 view .LVU157
 890 0028 8170      		andi r24,lo8(1)
 891               	/* epilogue start */
 892 002a 0895      		ret
 893               		.cfi_endproc
 894               	.LFE17:
 896               		.section	.text.matrix_get_row,"ax",@progbits
 897               	.global	matrix_get_row
 899               	matrix_get_row:
 900               	.LVL44:
 901               	.LFB18:
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 902               		.loc 1 244 1 is_stmt 1 view -0
 903               		.cfi_startproc
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 904               		.loc 1 244 1 is_stmt 0 view .LVU159
 905 0000 CF93      		push r28
 906               	.LCFI22:
 907               		.cfi_def_cfa_offset 3
 908               		.cfi_offset 28, -2
 909 0002 DF93      		push r29
 910               	.LCFI23:
 911               		.cfi_def_cfa_offset 4
 912               		.cfi_offset 29, -3
 913 0004 00D0      		rcall .
 914 0006 00D0      		rcall .
 915               	.LCFI24:
 916               		.cfi_def_cfa_offset 8
 917 0008 CDB7      		in r28,__SP_L__
 918 000a DEB7      		in r29,__SP_H__
 919               	.LCFI25:
 920               		.cfi_def_cfa_register 28
 921               	/* prologue: function */
 922               	/* frame size = 4 */
 923               	/* stack size = 6 */
 924               	.L__stack_usage = 6
 250:quantum/matrix.c **** #endif
 925               		.loc 1 250 5 is_stmt 1 view .LVU160
 250:quantum/matrix.c **** #endif
 926               		.loc 1 250 18 is_stmt 0 view .LVU161
 927 000c 94E0      		ldi r25,lo8(4)
 928 000e 899F      		mul r24,r25
 929 0010 F001      		movw r30,r0
 930 0012 1124      		clr __zero_reg__
 931 0014 E050      		subi r30,lo8(-(matrix))
 932 0016 F040      		sbci r31,hi8(-(matrix))
 933 0018 8081      		ld r24,Z
 934 001a 9181      		ldd r25,Z+1
 935 001c A281      		ldd r26,Z+2
 936 001e B381      		ldd r27,Z+3
 937               	.LVL45:
 252:quantum/matrix.c **** 
 938               		.loc 1 252 1 view .LVU162
 939 0020 BC01      		movw r22,r24
 940 0022 CD01      		movw r24,r26
 941               	/* epilogue start */
 942 0024 0F90      		pop __tmp_reg__
 943 0026 0F90      		pop __tmp_reg__
 944 0028 0F90      		pop __tmp_reg__
 945 002a 0F90      		pop __tmp_reg__
 946 002c DF91      		pop r29
 947 002e CF91      		pop r28
 948 0030 0895      		ret
 949               		.cfi_endproc
 950               	.LFE18:
 952               		.section	.text.matrix_print,"ax",@progbits
 953               	.global	matrix_print
 955               	matrix_print:
 956               	.LFB19:
 255:quantum/matrix.c ****     print_matrix_header();
 957               		.loc 1 255 1 is_stmt 1 view -0
 958               		.cfi_startproc
 959               	/* prologue: function */
 960               	/* frame size = 0 */
 961               	/* stack size = 0 */
 962               	.L__stack_usage = 0
 256:quantum/matrix.c **** 
 963               		.loc 1 256 26 view .LVU164
 258:quantum/matrix.c ****         phex(row); print(": ");
 964               		.loc 1 258 5 view .LVU165
 258:quantum/matrix.c ****         phex(row); print(": ");
 965               		.loc 1 258 10 view .LVU166
 258:quantum/matrix.c ****         phex(row); print(": ");
 966               		.loc 1 258 27 view .LVU167
 967               	/* epilogue start */
 263:quantum/matrix.c **** 
 968               		.loc 1 263 1 is_stmt 0 view .LVU168
 969 0000 0895      		ret
 970               		.cfi_endproc
 971               	.LFE19:
 973               		.section	.text.matrix_key_count,"ax",@progbits
 974               	.global	matrix_key_count
 976               	matrix_key_count:
 977               	.LFB20:
 266:quantum/matrix.c ****     uint8_t count = 0;
 978               		.loc 1 266 1 is_stmt 1 view -0
 979               		.cfi_startproc
 980 0000 0F93      		push r16
 981               	.LCFI26:
 982               		.cfi_def_cfa_offset 3
 983               		.cfi_offset 16, -2
 984 0002 1F93      		push r17
 985               	.LCFI27:
 986               		.cfi_def_cfa_offset 4
 987               		.cfi_offset 17, -3
 988 0004 CF93      		push r28
 989               	.LCFI28:
 990               		.cfi_def_cfa_offset 5
 991               		.cfi_offset 28, -4
 992 0006 DF93      		push r29
 993               	.LCFI29:
 994               		.cfi_def_cfa_offset 6
 995               		.cfi_offset 29, -5
 996 0008 00D0      		rcall .
 997 000a 00D0      		rcall .
 998 000c 0F92      		push __tmp_reg__
 999               	.LCFI30:
 1000               		.cfi_def_cfa_offset 11
 1001 000e CDB7      		in r28,__SP_L__
 1002 0010 DEB7      		in r29,__SP_H__
 1003               	.LCFI31:
 1004               		.cfi_def_cfa_register 28
 1005               	/* prologue: function */
 1006               	/* frame size = 5 */
 1007               	/* stack size = 9 */
 1008               	.L__stack_usage = 9
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 1009               		.loc 1 267 5 view .LVU170
 1010               	.LVL46:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 1011               		.loc 1 268 5 view .LVU171
 1012               	.LBB66:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 1013               		.loc 1 268 10 view .LVU172
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 1014               		.loc 1 268 25 view .LVU173
 1015 0012 00E0      		ldi r16,lo8(matrix)
 1016 0014 10E0      		ldi r17,hi8(matrix)
 1017               	.LBE66:
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 1018               		.loc 1 267 13 is_stmt 0 view .LVU174
 1019 0016 1D82      		std Y+5,__zero_reg__
 1020               	.LVL47:
 1021               	.L31:
 1022               	.LBB67:
 269:quantum/matrix.c ****     }
 1023               		.loc 1 269 9 is_stmt 1 discriminator 3 view .LVU175
 269:quantum/matrix.c ****     }
 1024               		.loc 1 269 18 is_stmt 0 discriminator 3 view .LVU176
 1025 0018 F801      		movw r30,r16
 1026 001a 8191      		ld r24,Z+
 1027 001c 9191      		ld r25,Z+
 1028 001e A191      		ld r26,Z+
 1029 0020 B191      		ld r27,Z+
 1030 0022 8F01      		movw r16,r30
 1031               	.LVL48:
 269:quantum/matrix.c ****     }
 1032               		.loc 1 269 18 discriminator 3 view .LVU177
 1033 0024 8983      		std Y+1,r24
 1034 0026 9A83      		std Y+2,r25
 1035 0028 AB83      		std Y+3,r26
 1036 002a BC83      		std Y+4,r27
 1037 002c BC01      		movw r22,r24
 1038 002e CD01      		movw r24,r26
 1039 0030 0E94 0000 		call bitpop32
 1040               	.LVL49:
 269:quantum/matrix.c ****     }
 1041               		.loc 1 269 15 discriminator 3 view .LVU178
 1042 0034 FD81      		ldd r31,Y+5
 1043 0036 F80F      		add r31,r24
 1044 0038 FD83      		std Y+5,r31
 1045               	.LVL50:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 1046               		.loc 1 268 42 is_stmt 1 discriminator 3 view .LVU179
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 1047               		.loc 1 268 25 discriminator 3 view .LVU180
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 1048               		.loc 1 268 5 is_stmt 0 discriminator 3 view .LVU181
 1049 003a 80E0      		ldi r24,hi8(matrix+36)
 1050 003c 0030      		cpi r16,lo8(matrix+36)
 1051 003e 1807      		cpc r17,r24
 1052 0040 01F4      		brne .L31
 1053               	.LBE67:
 271:quantum/matrix.c **** }
 1054               		.loc 1 271 5 is_stmt 1 view .LVU182
 272:quantum/matrix.c **** 
 1055               		.loc 1 272 1 is_stmt 0 view .LVU183
 1056 0042 8F2F      		mov r24,r31
 1057               	/* epilogue start */
 1058 0044 0F90      		pop __tmp_reg__
 1059 0046 0F90      		pop __tmp_reg__
 1060 0048 0F90      		pop __tmp_reg__
 1061 004a 0F90      		pop __tmp_reg__
 1062 004c 0F90      		pop __tmp_reg__
 1063 004e DF91      		pop r29
 1064 0050 CF91      		pop r28
 1065 0052 1F91      		pop r17
 1066 0054 0F91      		pop r16
 1067               	.LVL51:
 272:quantum/matrix.c **** 
 1068               		.loc 1 272 1 view .LVU184
 1069 0056 0895      		ret
 1070               		.cfi_endproc
 1071               	.LFE20:
 1073               		.section	.bss.matrix_debouncing,"aw",@nobits
 1076               	matrix_debouncing:
 1077 0000 0000 0000 		.zero	36
 1077      0000 0000 
 1077      0000 0000 
 1077      0000 0000 
 1077      0000 0000 
 1078               		.section	.bss.matrix,"aw",@nobits
 1081               	matrix:
 1082 0000 0000 0000 		.zero	36
 1082      0000 0000 
 1082      0000 0000 
 1082      0000 0000 
 1082      0000 0000 
 1083               		.section	.rodata.col_pins,"a"
 1086               	col_pins:
 1087 0000 6665 6463 		.ascii	"fedcba`\301\300\227\363\225\361\223\222\221\2207"
 1087      6261 60C1 
 1087      C097 F395 
 1087      F193 9291 
 1087      9037 
 1088               		.section	.rodata.row_pins,"a"
 1091               	row_pins:
 1092 0000 C6C7 3031 		.ascii	"\306\3070123456"
 1092      3233 3435 
 1092      36
 1093               		.section	.bss.debouncing,"aw",@nobits
 1096               	debouncing:
 1097 0000 00        		.zero	1
 1098               		.section	.bss.debouncing_time,"aw",@nobits
 1101               	debouncing_time:
 1102 0000 0000      		.zero	2
 1103               		.text
 1104               	.Letext0:
 1105               		.file 3 "/usr/avr/include/stdint.h"
 1106               		.file 4 "./tmk_core/common/matrix.h"
 1107               		.file 5 "./tmk_core/common/util.h"
 1108               		.file 6 "./tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccLjrZ9s.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccLjrZ9s.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccLjrZ9s.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccLjrZ9s.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccLjrZ9s.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccLjrZ9s.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccLjrZ9s.s:14     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccLjrZ9s.s:14     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias
     /tmp/ccLjrZ9s.s:33     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccLjrZ9s.s:50     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccLjrZ9s.s:67     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccLjrZ9s.s:82     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccLjrZ9s.s:99     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccLjrZ9s.s:116    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccLjrZ9s.s:135    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccLjrZ9s.s:154    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccLjrZ9s.s:1091   .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccLjrZ9s.s:1086   .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccLjrZ9s.s:1081   .bss.matrix:0000000000000000 matrix
     /tmp/ccLjrZ9s.s:1076   .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccLjrZ9s.s:345    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccLjrZ9s.s:1096   .bss.debouncing:0000000000000000 debouncing
     /tmp/ccLjrZ9s.s:1101   .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/ccLjrZ9s.s:831    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccLjrZ9s.s:853    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccLjrZ9s.s:899    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccLjrZ9s.s:955    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccLjrZ9s.s:976    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop32
__do_copy_data
__do_clear_bss
