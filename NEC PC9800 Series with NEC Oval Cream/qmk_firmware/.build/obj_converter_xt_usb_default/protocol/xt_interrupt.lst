   1               		.file	"xt_interrupt.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.xt_host_init,"ax",@progbits
  11               	.global	xt_host_init
  13               	xt_host_init:
  14               	.LFB7:
  15               		.file 1 "tmk_core/protocol/xt_interrupt.c"
   1:tmk_core/protocol/xt_interrupt.c **** /*
   2:tmk_core/protocol/xt_interrupt.c **** Copyright 2018 Jun WAKO <wakojun@gmail.com>
   3:tmk_core/protocol/xt_interrupt.c **** Copyright 2016 Ethan Apodaca <papodaca@gmail.com>
   4:tmk_core/protocol/xt_interrupt.c **** 
   5:tmk_core/protocol/xt_interrupt.c **** This software is licensed with a Modified BSD License.
   6:tmk_core/protocol/xt_interrupt.c **** All of this is supposed to be Free Software, Open Source, DFSG-free,
   7:tmk_core/protocol/xt_interrupt.c **** GPL-compatible, and OK to use in both free and proprietary applications.
   8:tmk_core/protocol/xt_interrupt.c **** Additions and corrections to this file are welcome.
   9:tmk_core/protocol/xt_interrupt.c **** 
  10:tmk_core/protocol/xt_interrupt.c **** 
  11:tmk_core/protocol/xt_interrupt.c **** Redistribution and use in source and binary forms, with or without
  12:tmk_core/protocol/xt_interrupt.c **** modification, are permitted provided that the following conditions are met:
  13:tmk_core/protocol/xt_interrupt.c **** 
  14:tmk_core/protocol/xt_interrupt.c **** * Redistributions of source code must retain the above copyright
  15:tmk_core/protocol/xt_interrupt.c ****   notice, this list of conditions and the following disclaimer.
  16:tmk_core/protocol/xt_interrupt.c **** 
  17:tmk_core/protocol/xt_interrupt.c **** * Redistributions in binary form must reproduce the above copyright
  18:tmk_core/protocol/xt_interrupt.c ****   notice, this list of conditions and the following disclaimer in
  19:tmk_core/protocol/xt_interrupt.c ****   the documentation and/or other materials provided with the
  20:tmk_core/protocol/xt_interrupt.c ****   distribution.
  21:tmk_core/protocol/xt_interrupt.c **** 
  22:tmk_core/protocol/xt_interrupt.c **** * Neither the name of the copyright holders nor the names of
  23:tmk_core/protocol/xt_interrupt.c ****   contributors may be used to endorse or promote products derived
  24:tmk_core/protocol/xt_interrupt.c ****   from this software without specific prior written permission.
  25:tmk_core/protocol/xt_interrupt.c **** 
  26:tmk_core/protocol/xt_interrupt.c **** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  27:tmk_core/protocol/xt_interrupt.c **** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  28:tmk_core/protocol/xt_interrupt.c **** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  29:tmk_core/protocol/xt_interrupt.c **** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  30:tmk_core/protocol/xt_interrupt.c **** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  31:tmk_core/protocol/xt_interrupt.c **** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  32:tmk_core/protocol/xt_interrupt.c **** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  33:tmk_core/protocol/xt_interrupt.c **** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  34:tmk_core/protocol/xt_interrupt.c **** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  35:tmk_core/protocol/xt_interrupt.c **** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  36:tmk_core/protocol/xt_interrupt.c **** POSSIBILITY OF SUCH DAMAGE.
  37:tmk_core/protocol/xt_interrupt.c **** */
  38:tmk_core/protocol/xt_interrupt.c **** 
  39:tmk_core/protocol/xt_interrupt.c **** #include <stdbool.h>
  40:tmk_core/protocol/xt_interrupt.c **** #include <avr/interrupt.h>
  41:tmk_core/protocol/xt_interrupt.c **** #include <util/delay.h>
  42:tmk_core/protocol/xt_interrupt.c **** #include "xt.h"
  43:tmk_core/protocol/xt_interrupt.c **** #include "wait.h"
  44:tmk_core/protocol/xt_interrupt.c **** #include "debug.h"
  45:tmk_core/protocol/xt_interrupt.c **** 
  46:tmk_core/protocol/xt_interrupt.c **** static inline uint8_t pbuf_dequeue(void);
  47:tmk_core/protocol/xt_interrupt.c **** static inline void    pbuf_enqueue(uint8_t data);
  48:tmk_core/protocol/xt_interrupt.c **** static inline bool    pbuf_has_data(void);
  49:tmk_core/protocol/xt_interrupt.c **** static inline void    pbuf_clear(void);
  50:tmk_core/protocol/xt_interrupt.c **** 
  51:tmk_core/protocol/xt_interrupt.c **** void xt_host_init(void) {
  16               		.loc 1 51 25 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  52:tmk_core/protocol/xt_interrupt.c ****     XT_INT_INIT();
  22               		.loc 1 52 5 view .LVU1
  23               		.loc 1 52 5 view .LVU2
  24 0000 E9E6      		ldi r30,lo8(105)
  25 0002 F0E0      		ldi r31,0
  26 0004 8081      		ld r24,Z
  27 0006 8860      		ori r24,lo8(8)
  28 0008 8083      		st Z,r24
  53:tmk_core/protocol/xt_interrupt.c ****     XT_INT_OFF();
  29               		.loc 1 53 5 view .LVU3
  30               		.loc 1 53 5 view .LVU4
  31 000a E998      		cbi 0x1d,1
  54:tmk_core/protocol/xt_interrupt.c **** 
  55:tmk_core/protocol/xt_interrupt.c ****     /* hard reset */
  56:tmk_core/protocol/xt_interrupt.c **** #ifdef XT_RESET
  57:tmk_core/protocol/xt_interrupt.c ****     XT_RESET();
  32               		.loc 1 57 5 view .LVU5
  33               		.loc 1 57 5 view .LVU6
  34 000c 5C98      		cbi 0xb,4
  35               		.loc 1 57 5 view .LVU7
  36 000e 549A      		sbi 0xa,4
  37               		.loc 1 57 5 view .LVU8
  38               	.LVL0:
  39               	.LBB6:
  40               	.LBI6:
  41               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
  42               		.loc 2 166 1 view .LVU9
  43               	.LBB7:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
  44               		.loc 2 168 2 view .LVU10
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
  45               		.loc 2 172 2 view .LVU11
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  46               		.loc 2 173 2 view .LVU12
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
  47               		.loc 2 174 2 view .LVU13
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
  48               		.loc 2 184 3 view .LVU14
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  49               		.loc 2 187 2 view .LVU15
  50 0010 2FEF      		ldi r18,lo8(1599999)
  51 0012 89E6      		ldi r24,hi8(1599999)
  52 0014 98E1      		ldi r25,hlo8(1599999)
  53 0016 2150      	1:	subi r18,1
  54 0018 8040      		sbci r24,0
  55 001a 9040      		sbci r25,0
  56 001c 01F4      		brne 1b
  57 001e 00C0      		rjmp .
  58 0020 0000      		nop
  59               	.LVL1:
  60               		.loc 2 187 2 is_stmt 0 view .LVU16
  61               	.LBE7:
  62               	.LBE6:
  63               		.loc 1 57 5 is_stmt 1 view .LVU17
  64 0022 5498      		cbi 0xa,4
  58:tmk_core/protocol/xt_interrupt.c **** #endif
  59:tmk_core/protocol/xt_interrupt.c **** 
  60:tmk_core/protocol/xt_interrupt.c ****     /* soft reset: pull clock line down for 20ms */
  61:tmk_core/protocol/xt_interrupt.c ****     XT_DATA_LO();
  65               		.loc 1 61 5 view .LVU18
  66               		.loc 1 61 5 view .LVU19
  67 0024 5898      		cbi 0xb,0
  68               		.loc 1 61 5 view .LVU20
  69 0026 509A      		sbi 0xa,0
  62:tmk_core/protocol/xt_interrupt.c ****     XT_CLOCK_LO();
  70               		.loc 1 62 5 view .LVU21
  71               		.loc 1 62 5 view .LVU22
  72 0028 5998      		cbi 0xb,1
  73               		.loc 1 62 5 view .LVU23
  74 002a 519A      		sbi 0xa,1
  63:tmk_core/protocol/xt_interrupt.c ****     _delay_ms(20);
  75               		.loc 1 63 5 view .LVU24
  76               	.LVL2:
  77               	.LBB8:
  78               	.LBI8:
 166:/usr/avr/include/util/delay.h **** {
  79               		.loc 2 166 1 view .LVU25
  80               	.LBB9:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  81               		.loc 2 168 2 view .LVU26
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  82               		.loc 2 172 2 view .LVU27
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
  83               		.loc 2 173 2 view .LVU28
 174:/usr/avr/include/util/delay.h **** 
  84               		.loc 2 174 2 view .LVU29
 184:/usr/avr/include/util/delay.h **** 	#endif
  85               		.loc 2 184 3 view .LVU30
  86               		.loc 2 187 2 view .LVU31
  87 002c 2FEF      		ldi r18,lo8(63999)
  88 002e 89EF      		ldi r24,hi8(63999)
  89 0030 90E0      		ldi r25,hlo8(63999)
  90 0032 2150      	1:	subi r18,1
  91 0034 8040      		sbci r24,0
  92 0036 9040      		sbci r25,0
  93 0038 01F4      		brne 1b
  94 003a 00C0      		rjmp .
  95 003c 0000      		nop
  96               	.LVL3:
  97               		.loc 2 187 2 is_stmt 0 view .LVU32
  98               	.LBE9:
  99               	.LBE8:
  64:tmk_core/protocol/xt_interrupt.c **** 
  65:tmk_core/protocol/xt_interrupt.c ****     /* input mode with pullup */
  66:tmk_core/protocol/xt_interrupt.c ****     XT_CLOCK_IN();
 100               		.loc 1 66 5 is_stmt 1 view .LVU33
 101               		.loc 1 66 5 view .LVU34
 102 003e 5198      		cbi 0xa,1
 103               		.loc 1 66 5 view .LVU35
 104 0040 599A      		sbi 0xb,1
  67:tmk_core/protocol/xt_interrupt.c ****     XT_DATA_IN();
 105               		.loc 1 67 5 view .LVU36
 106               		.loc 1 67 5 view .LVU37
 107 0042 5098      		cbi 0xa,0
 108               		.loc 1 67 5 view .LVU38
 109 0044 589A      		sbi 0xb,0
  68:tmk_core/protocol/xt_interrupt.c **** 
  69:tmk_core/protocol/xt_interrupt.c ****     XT_INT_ON();
 110               		.loc 1 69 5 view .LVU39
 111               		.loc 1 69 5 view .LVU40
 112 0046 E19A      		sbi 0x1c,1
 113               		.loc 1 69 5 view .LVU41
 114 0048 E99A      		sbi 0x1d,1
 115               	/* epilogue start */
  70:tmk_core/protocol/xt_interrupt.c **** }
 116               		.loc 1 70 1 is_stmt 0 view .LVU42
 117 004a 0895      		ret
 118               		.cfi_endproc
 119               	.LFE7:
 121               		.section	.text.xt_host_recv,"ax",@progbits
 122               	.global	xt_host_recv
 124               	xt_host_recv:
 125               	.LFB8:
  71:tmk_core/protocol/xt_interrupt.c **** 
  72:tmk_core/protocol/xt_interrupt.c **** /* get data received by interrupt */
  73:tmk_core/protocol/xt_interrupt.c **** uint8_t xt_host_recv(void) {
 126               		.loc 1 73 28 is_stmt 1 view -0
 127               		.cfi_startproc
 128               	/* prologue: function */
 129               	/* frame size = 0 */
 130               	/* stack size = 0 */
 131               	.L__stack_usage = 0
  74:tmk_core/protocol/xt_interrupt.c ****     if (pbuf_has_data()) {
 132               		.loc 1 74 5 view .LVU44
 133               	.LBB14:
 134               	.LBI14:
  75:tmk_core/protocol/xt_interrupt.c ****         return pbuf_dequeue();
  76:tmk_core/protocol/xt_interrupt.c ****     } else {
  77:tmk_core/protocol/xt_interrupt.c ****         return 0;
  78:tmk_core/protocol/xt_interrupt.c ****     }
  79:tmk_core/protocol/xt_interrupt.c **** }
  80:tmk_core/protocol/xt_interrupt.c **** 
  81:tmk_core/protocol/xt_interrupt.c **** ISR(XT_INT_VECT) {
  82:tmk_core/protocol/xt_interrupt.c ****     /*
  83:tmk_core/protocol/xt_interrupt.c ****      * XT signal format consits of 10 or 9 clocks and sends start bits and 8-bit data,
  84:tmk_core/protocol/xt_interrupt.c ****      * which should be read on falling edge of clock.
  85:tmk_core/protocol/xt_interrupt.c ****      *
  86:tmk_core/protocol/xt_interrupt.c ****      *  start(0), start(1), bit0, bit1, bit2, bit3, bit4, bit5, bit6, bit7
  87:tmk_core/protocol/xt_interrupt.c ****      *
  88:tmk_core/protocol/xt_interrupt.c ****      * Original IBM XT keyboard sends start(0) bit while some of clones don't.
  89:tmk_core/protocol/xt_interrupt.c ****      * Start(0) bit is read as low on data line while start(1) as high.
  90:tmk_core/protocol/xt_interrupt.c ****      *
  91:tmk_core/protocol/xt_interrupt.c ****      * https://github.com/tmk/tmk_keyboard/wiki/IBM-PC-XT-Keyboard-Protocol
  92:tmk_core/protocol/xt_interrupt.c ****      */
  93:tmk_core/protocol/xt_interrupt.c ****     static enum { START, BIT0, BIT1, BIT2, BIT3, BIT4, BIT5, BIT6, BIT7 } state = START;
  94:tmk_core/protocol/xt_interrupt.c ****     static uint8_t data                                                         = 0;
  95:tmk_core/protocol/xt_interrupt.c **** 
  96:tmk_core/protocol/xt_interrupt.c ****     uint8_t dbit = XT_DATA_READ();
  97:tmk_core/protocol/xt_interrupt.c **** 
  98:tmk_core/protocol/xt_interrupt.c ****     // This is needed if using PCINT which can be called on both falling and rising edge
  99:tmk_core/protocol/xt_interrupt.c ****     // if (XT_CLOCK_READ()) return;
 100:tmk_core/protocol/xt_interrupt.c **** 
 101:tmk_core/protocol/xt_interrupt.c ****     switch (state) {
 102:tmk_core/protocol/xt_interrupt.c ****         case START:
 103:tmk_core/protocol/xt_interrupt.c ****             // ignore start(0) bit
 104:tmk_core/protocol/xt_interrupt.c ****             if (!dbit) return;
 105:tmk_core/protocol/xt_interrupt.c ****             break;
 106:tmk_core/protocol/xt_interrupt.c ****         case BIT0 ... BIT7:
 107:tmk_core/protocol/xt_interrupt.c ****             data >>= 1;
 108:tmk_core/protocol/xt_interrupt.c ****             if (dbit) data |= 0x80;
 109:tmk_core/protocol/xt_interrupt.c ****             break;
 110:tmk_core/protocol/xt_interrupt.c ****     }
 111:tmk_core/protocol/xt_interrupt.c ****     if (state++ == BIT7) {
 112:tmk_core/protocol/xt_interrupt.c ****         pbuf_enqueue(data);
 113:tmk_core/protocol/xt_interrupt.c ****         state = START;
 114:tmk_core/protocol/xt_interrupt.c ****         data  = 0;
 115:tmk_core/protocol/xt_interrupt.c ****     }
 116:tmk_core/protocol/xt_interrupt.c ****     return;
 117:tmk_core/protocol/xt_interrupt.c **** }
 118:tmk_core/protocol/xt_interrupt.c **** 
 119:tmk_core/protocol/xt_interrupt.c **** /*--------------------------------------------------------------------
 120:tmk_core/protocol/xt_interrupt.c ****  * Ring buffer to store scan codes from keyboard
 121:tmk_core/protocol/xt_interrupt.c ****  *------------------------------------------------------------------*/
 122:tmk_core/protocol/xt_interrupt.c **** #define PBUF_SIZE 32
 123:tmk_core/protocol/xt_interrupt.c **** static uint8_t     pbuf[PBUF_SIZE];
 124:tmk_core/protocol/xt_interrupt.c **** static uint8_t     pbuf_head = 0;
 125:tmk_core/protocol/xt_interrupt.c **** static uint8_t     pbuf_tail = 0;
 126:tmk_core/protocol/xt_interrupt.c **** static inline void pbuf_enqueue(uint8_t data) {
 127:tmk_core/protocol/xt_interrupt.c ****     uint8_t sreg = SREG;
 128:tmk_core/protocol/xt_interrupt.c ****     cli();
 129:tmk_core/protocol/xt_interrupt.c ****     uint8_t next = (pbuf_head + 1) % PBUF_SIZE;
 130:tmk_core/protocol/xt_interrupt.c ****     if (next != pbuf_tail) {
 131:tmk_core/protocol/xt_interrupt.c ****         pbuf[pbuf_head] = data;
 132:tmk_core/protocol/xt_interrupt.c ****         pbuf_head       = next;
 133:tmk_core/protocol/xt_interrupt.c ****     } else {
 134:tmk_core/protocol/xt_interrupt.c ****         dprintf("pbuf: full\n");
 135:tmk_core/protocol/xt_interrupt.c ****     }
 136:tmk_core/protocol/xt_interrupt.c ****     SREG = sreg;
 137:tmk_core/protocol/xt_interrupt.c **** }
 138:tmk_core/protocol/xt_interrupt.c **** static inline uint8_t pbuf_dequeue(void) {
 139:tmk_core/protocol/xt_interrupt.c ****     uint8_t val = 0;
 140:tmk_core/protocol/xt_interrupt.c **** 
 141:tmk_core/protocol/xt_interrupt.c ****     uint8_t sreg = SREG;
 142:tmk_core/protocol/xt_interrupt.c ****     cli();
 143:tmk_core/protocol/xt_interrupt.c ****     if (pbuf_head != pbuf_tail) {
 144:tmk_core/protocol/xt_interrupt.c ****         val       = pbuf[pbuf_tail];
 145:tmk_core/protocol/xt_interrupt.c ****         pbuf_tail = (pbuf_tail + 1) % PBUF_SIZE;
 146:tmk_core/protocol/xt_interrupt.c ****     }
 147:tmk_core/protocol/xt_interrupt.c ****     SREG = sreg;
 148:tmk_core/protocol/xt_interrupt.c **** 
 149:tmk_core/protocol/xt_interrupt.c ****     return val;
 150:tmk_core/protocol/xt_interrupt.c **** }
 151:tmk_core/protocol/xt_interrupt.c **** static inline bool pbuf_has_data(void) {
 135               		.loc 1 151 20 view .LVU45
 136               	.LBB15:
 152:tmk_core/protocol/xt_interrupt.c ****     uint8_t sreg = SREG;
 137               		.loc 1 152 5 view .LVU46
 138               		.loc 1 152 13 is_stmt 0 view .LVU47
 139 0000 2FB7      		in r18,__SREG__
 140               	.LVL4:
 153:tmk_core/protocol/xt_interrupt.c ****     cli();
 141               		.loc 1 153 5 is_stmt 1 view .LVU48
 142               	/* #APP */
 143               	 ;  153 "tmk_core/protocol/xt_interrupt.c" 1
 144 0002 F894      		cli
 145               	 ;  0 "" 2
 154:tmk_core/protocol/xt_interrupt.c ****     bool has_data = (pbuf_head != pbuf_tail);
 146               		.loc 1 154 5 view .LVU49
 147               		.loc 1 154 32 is_stmt 0 view .LVU50
 148               	/* #NOAPP */
 149 0004 9091 0000 		lds r25,pbuf_head
 150 0008 8091 0000 		lds r24,pbuf_tail
 151               	.LVL5:
 155:tmk_core/protocol/xt_interrupt.c ****     SREG          = sreg;
 152               		.loc 1 155 5 is_stmt 1 view .LVU51
 153               		.loc 1 155 19 is_stmt 0 view .LVU52
 154 000c 2FBF      		out __SREG__,r18
 156:tmk_core/protocol/xt_interrupt.c ****     return has_data;
 155               		.loc 1 156 5 is_stmt 1 view .LVU53
 156               	.LVL6:
 157               		.loc 1 156 5 is_stmt 0 view .LVU54
 158               	.LBE15:
 159               	.LBE14:
  74:tmk_core/protocol/xt_interrupt.c ****         return pbuf_dequeue();
 160               		.loc 1 74 8 view .LVU55
 161 000e 9817      		cp r25,r24
 162 0010 01F0      		breq .L5
  75:tmk_core/protocol/xt_interrupt.c ****     } else {
 163               		.loc 1 75 9 is_stmt 1 view .LVU56
 164               	.LBB16:
 165               	.LBI16:
 138:tmk_core/protocol/xt_interrupt.c ****     uint8_t val = 0;
 166               		.loc 1 138 23 view .LVU57
 167               	.LBB17:
 139:tmk_core/protocol/xt_interrupt.c **** 
 168               		.loc 1 139 5 view .LVU58
 169               	.LVL7:
 141:tmk_core/protocol/xt_interrupt.c ****     cli();
 170               		.loc 1 141 5 view .LVU59
 141:tmk_core/protocol/xt_interrupt.c ****     cli();
 171               		.loc 1 141 13 is_stmt 0 view .LVU60
 172 0012 9FB7      		in r25,__SREG__
 173               	.LVL8:
 142:tmk_core/protocol/xt_interrupt.c ****     if (pbuf_head != pbuf_tail) {
 174               		.loc 1 142 5 is_stmt 1 view .LVU61
 175               	/* #APP */
 176               	 ;  142 "tmk_core/protocol/xt_interrupt.c" 1
 177 0014 F894      		cli
 178               	 ;  0 "" 2
 143:tmk_core/protocol/xt_interrupt.c ****         val       = pbuf[pbuf_tail];
 179               		.loc 1 143 5 view .LVU62
 143:tmk_core/protocol/xt_interrupt.c ****         val       = pbuf[pbuf_tail];
 180               		.loc 1 143 19 is_stmt 0 view .LVU63
 181               	/* #NOAPP */
 182 0016 2091 0000 		lds r18,pbuf_tail
 143:tmk_core/protocol/xt_interrupt.c ****         val       = pbuf[pbuf_tail];
 183               		.loc 1 143 8 view .LVU64
 184 001a 8091 0000 		lds r24,pbuf_head
 185 001e 8217      		cp r24,r18
 186 0020 01F0      		breq .L6
 144:tmk_core/protocol/xt_interrupt.c ****         pbuf_tail = (pbuf_tail + 1) % PBUF_SIZE;
 187               		.loc 1 144 9 is_stmt 1 view .LVU65
 144:tmk_core/protocol/xt_interrupt.c ****         pbuf_tail = (pbuf_tail + 1) % PBUF_SIZE;
 188               		.loc 1 144 25 is_stmt 0 view .LVU66
 189 0022 30E0      		ldi r19,0
 144:tmk_core/protocol/xt_interrupt.c ****         pbuf_tail = (pbuf_tail + 1) % PBUF_SIZE;
 190               		.loc 1 144 19 view .LVU67
 191 0024 F901      		movw r30,r18
 192 0026 E050      		subi r30,lo8(-(pbuf))
 193 0028 F040      		sbci r31,hi8(-(pbuf))
 194 002a 8081      		ld r24,Z
 195               	.LVL9:
 145:tmk_core/protocol/xt_interrupt.c ****     }
 196               		.loc 1 145 9 is_stmt 1 view .LVU68
 145:tmk_core/protocol/xt_interrupt.c ****     }
 197               		.loc 1 145 32 is_stmt 0 view .LVU69
 198 002c 2F5F      		subi r18,-1
 199 002e 3F4F      		sbci r19,-1
 145:tmk_core/protocol/xt_interrupt.c ****     }
 200               		.loc 1 145 37 view .LVU70
 201 0030 2F71      		andi r18,31
 202 0032 3327      		clr r19
 145:tmk_core/protocol/xt_interrupt.c ****     }
 203               		.loc 1 145 19 view .LVU71
 204 0034 2093 0000 		sts pbuf_tail,r18
 205               	.LVL10:
 206               	.L4:
 147:tmk_core/protocol/xt_interrupt.c **** 
 207               		.loc 1 147 5 is_stmt 1 view .LVU72
 147:tmk_core/protocol/xt_interrupt.c **** 
 208               		.loc 1 147 10 is_stmt 0 view .LVU73
 209 0038 9FBF      		out __SREG__,r25
 149:tmk_core/protocol/xt_interrupt.c **** }
 210               		.loc 1 149 5 is_stmt 1 view .LVU74
 211               	.LVL11:
 149:tmk_core/protocol/xt_interrupt.c **** }
 212               		.loc 1 149 5 is_stmt 0 view .LVU75
 213               	.LBE17:
 214               	.LBE16:
  75:tmk_core/protocol/xt_interrupt.c ****     } else {
 215               		.loc 1 75 16 view .LVU76
 216 003a 0895      		ret
 217               	.LVL12:
 218               	.L6:
 219               	.LBB19:
 220               	.LBB18:
 139:tmk_core/protocol/xt_interrupt.c **** 
 221               		.loc 1 139 13 view .LVU77
 222 003c 80E0      		ldi r24,0
 223 003e 00C0      		rjmp .L4
 224               	.LVL13:
 225               	.L5:
 139:tmk_core/protocol/xt_interrupt.c **** 
 226               		.loc 1 139 13 view .LVU78
 227               	.LBE18:
 228               	.LBE19:
  77:tmk_core/protocol/xt_interrupt.c ****     }
 229               		.loc 1 77 16 view .LVU79
 230 0040 80E0      		ldi r24,0
 231               	/* epilogue start */
  79:tmk_core/protocol/xt_interrupt.c **** 
 232               		.loc 1 79 1 view .LVU80
 233 0042 0895      		ret
 234               		.cfi_endproc
 235               	.LFE8:
 237               		.section	.text.__vector_2,"ax",@progbits
 238               	.global	__vector_2
 240               	__vector_2:
 241               	.LFB9:
  81:tmk_core/protocol/xt_interrupt.c ****     /*
 242               		.loc 1 81 18 is_stmt 1 view -0
 243               		.cfi_startproc
 244 0000 1F92      		push r1
 245               	.LCFI0:
 246               		.cfi_def_cfa_offset 3
 247               		.cfi_offset 1, -2
 248 0002 0F92      		push r0
 249               	.LCFI1:
 250               		.cfi_def_cfa_offset 4
 251               		.cfi_offset 0, -3
 252 0004 0FB6      		in r0,__SREG__
 253 0006 0F92      		push r0
 254 0008 1124      		clr __zero_reg__
 255 000a 2F93      		push r18
 256               	.LCFI2:
 257               		.cfi_def_cfa_offset 5
 258               		.cfi_offset 18, -4
 259 000c 3F93      		push r19
 260               	.LCFI3:
 261               		.cfi_def_cfa_offset 6
 262               		.cfi_offset 19, -5
 263 000e 4F93      		push r20
 264               	.LCFI4:
 265               		.cfi_def_cfa_offset 7
 266               		.cfi_offset 20, -6
 267 0010 5F93      		push r21
 268               	.LCFI5:
 269               		.cfi_def_cfa_offset 8
 270               		.cfi_offset 21, -7
 271 0012 6F93      		push r22
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 9
 274               		.cfi_offset 22, -8
 275 0014 7F93      		push r23
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 10
 278               		.cfi_offset 23, -9
 279 0016 8F93      		push r24
 280               	.LCFI8:
 281               		.cfi_def_cfa_offset 11
 282               		.cfi_offset 24, -10
 283 0018 9F93      		push r25
 284               	.LCFI9:
 285               		.cfi_def_cfa_offset 12
 286               		.cfi_offset 25, -11
 287 001a AF93      		push r26
 288               	.LCFI10:
 289               		.cfi_def_cfa_offset 13
 290               		.cfi_offset 26, -12
 291 001c BF93      		push r27
 292               	.LCFI11:
 293               		.cfi_def_cfa_offset 14
 294               		.cfi_offset 27, -13
 295 001e CF93      		push r28
 296               	.LCFI12:
 297               		.cfi_def_cfa_offset 15
 298               		.cfi_offset 28, -14
 299 0020 EF93      		push r30
 300               	.LCFI13:
 301               		.cfi_def_cfa_offset 16
 302               		.cfi_offset 30, -15
 303 0022 FF93      		push r31
 304               	.LCFI14:
 305               		.cfi_def_cfa_offset 17
 306               		.cfi_offset 31, -16
 307               	/* prologue: Signal */
 308               	/* frame size = 0 */
 309               	/* stack size = 16 */
 310               	.L__stack_usage = 16
  93:tmk_core/protocol/xt_interrupt.c ****     static uint8_t data                                                         = 0;
 311               		.loc 1 93 5 view .LVU82
  94:tmk_core/protocol/xt_interrupt.c **** 
 312               		.loc 1 94 5 view .LVU83
  96:tmk_core/protocol/xt_interrupt.c **** 
 313               		.loc 1 96 5 view .LVU84
  96:tmk_core/protocol/xt_interrupt.c **** 
 314               		.loc 1 96 20 is_stmt 0 view .LVU85
 315 0024 29B1      		in r18,0x9
  96:tmk_core/protocol/xt_interrupt.c **** 
 316               		.loc 1 96 13 view .LVU86
 317 0026 2170      		andi r18,lo8(1)
 318               	.LVL14:
 101:tmk_core/protocol/xt_interrupt.c ****         case START:
 319               		.loc 1 101 5 is_stmt 1 view .LVU87
 320 0028 9091 0000 		lds r25,state.1911
 321 002c 9923      		tst r25
 322 002e 01F0      		breq .L8
 323 0030 9930      		cpi r25,lo8(9)
 324 0032 00F4      		brsh .L9
 107:tmk_core/protocol/xt_interrupt.c ****             if (dbit) data |= 0x80;
 325               		.loc 1 107 13 view .LVU88
 107:tmk_core/protocol/xt_interrupt.c ****             if (dbit) data |= 0x80;
 326               		.loc 1 107 18 is_stmt 0 view .LVU89
 327 0034 8091 0000 		lds r24,data.1912
 328 0038 8695      		lsr r24
 108:tmk_core/protocol/xt_interrupt.c ****             break;
 329               		.loc 1 108 13 is_stmt 1 view .LVU90
 108:tmk_core/protocol/xt_interrupt.c ****             break;
 330               		.loc 1 108 16 is_stmt 0 view .LVU91
 331 003a 2111      		cpse r18,__zero_reg__
 332 003c 00C0      		rjmp .L13
 333               	.L24:
 108:tmk_core/protocol/xt_interrupt.c ****             break;
 334               		.loc 1 108 28 discriminator 1 view .LVU92
 335 003e 8093 0000 		sts data.1912,r24
 336               	.L9:
 111:tmk_core/protocol/xt_interrupt.c ****         pbuf_enqueue(data);
 337               		.loc 1 111 5 is_stmt 1 view .LVU93
 111:tmk_core/protocol/xt_interrupt.c ****         pbuf_enqueue(data);
 338               		.loc 1 111 14 is_stmt 0 view .LVU94
 339 0042 81E0      		ldi r24,lo8(1)
 340 0044 890F      		add r24,r25
 341 0046 8093 0000 		sts state.1911,r24
 111:tmk_core/protocol/xt_interrupt.c ****         pbuf_enqueue(data);
 342               		.loc 1 111 8 view .LVU95
 343 004a 9830      		cpi r25,lo8(8)
 344 004c 01F4      		brne .L7
 112:tmk_core/protocol/xt_interrupt.c ****         state = START;
 345               		.loc 1 112 9 is_stmt 1 view .LVU96
 346 004e 4091 0000 		lds r20,data.1912
 347               	.LVL15:
 348               	.LBB23:
 349               	.LBI23:
 126:tmk_core/protocol/xt_interrupt.c ****     uint8_t sreg = SREG;
 350               		.loc 1 126 20 view .LVU97
 351               	.LBB24:
 127:tmk_core/protocol/xt_interrupt.c ****     cli();
 352               		.loc 1 127 5 view .LVU98
 127:tmk_core/protocol/xt_interrupt.c ****     cli();
 353               		.loc 1 127 13 is_stmt 0 view .LVU99
 354 0052 CFB7      		in r28,__SREG__
 355               	.LVL16:
 128:tmk_core/protocol/xt_interrupt.c ****     uint8_t next = (pbuf_head + 1) % PBUF_SIZE;
 356               		.loc 1 128 5 is_stmt 1 view .LVU100
 357               	/* #APP */
 358               	 ;  128 "tmk_core/protocol/xt_interrupt.c" 1
 359 0054 F894      		cli
 360               	 ;  0 "" 2
 129:tmk_core/protocol/xt_interrupt.c ****     if (next != pbuf_tail) {
 361               		.loc 1 129 5 view .LVU101
 129:tmk_core/protocol/xt_interrupt.c ****     if (next != pbuf_tail) {
 362               		.loc 1 129 31 is_stmt 0 view .LVU102
 363               	/* #NOAPP */
 364 0056 8091 0000 		lds r24,pbuf_head
 365 005a 90E0      		ldi r25,0
 366 005c 9C01      		movw r18,r24
 367               	.LVL17:
 129:tmk_core/protocol/xt_interrupt.c ****     if (next != pbuf_tail) {
 368               		.loc 1 129 31 view .LVU103
 369 005e 2F5F      		subi r18,-1
 370 0060 3F4F      		sbci r19,-1
 129:tmk_core/protocol/xt_interrupt.c ****     if (next != pbuf_tail) {
 371               		.loc 1 129 36 view .LVU104
 372 0062 2F71      		andi r18,31
 373 0064 3327      		clr r19
 374               	.LVL18:
 130:tmk_core/protocol/xt_interrupt.c ****         pbuf[pbuf_head] = data;
 375               		.loc 1 130 5 is_stmt 1 view .LVU105
 130:tmk_core/protocol/xt_interrupt.c ****         pbuf[pbuf_head] = data;
 376               		.loc 1 130 8 is_stmt 0 view .LVU106
 377 0066 5091 0000 		lds r21,pbuf_tail
 378 006a 5217      		cp r21,r18
 379 006c 01F0      		breq .L15
 131:tmk_core/protocol/xt_interrupt.c ****         pbuf_head       = next;
 380               		.loc 1 131 9 is_stmt 1 view .LVU107
 131:tmk_core/protocol/xt_interrupt.c ****         pbuf_head       = next;
 381               		.loc 1 131 25 is_stmt 0 view .LVU108
 382 006e 8050      		subi r24,lo8(-(pbuf))
 383 0070 9040      		sbci r25,hi8(-(pbuf))
 384 0072 FC01      		movw r30,r24
 385 0074 4083      		st Z,r20
 132:tmk_core/protocol/xt_interrupt.c ****     } else {
 386               		.loc 1 132 9 is_stmt 1 view .LVU109
 132:tmk_core/protocol/xt_interrupt.c ****     } else {
 387               		.loc 1 132 25 is_stmt 0 view .LVU110
 388 0076 2093 0000 		sts pbuf_head,r18
 389               	.LVL19:
 390               	.L16:
 136:tmk_core/protocol/xt_interrupt.c **** }
 391               		.loc 1 136 5 is_stmt 1 view .LVU111
 136:tmk_core/protocol/xt_interrupt.c **** }
 392               		.loc 1 136 10 is_stmt 0 view .LVU112
 393 007a CFBF      		out __SREG__,r28
 394               	.LVL20:
 136:tmk_core/protocol/xt_interrupt.c **** }
 395               		.loc 1 136 10 view .LVU113
 396               	.LBE24:
 397               	.LBE23:
 113:tmk_core/protocol/xt_interrupt.c ****         data  = 0;
 398               		.loc 1 113 9 is_stmt 1 view .LVU114
 113:tmk_core/protocol/xt_interrupt.c ****         data  = 0;
 399               		.loc 1 113 15 is_stmt 0 view .LVU115
 400 007c 1092 0000 		sts state.1911,__zero_reg__
 114:tmk_core/protocol/xt_interrupt.c ****     }
 401               		.loc 1 114 9 is_stmt 1 view .LVU116
 114:tmk_core/protocol/xt_interrupt.c ****     }
 402               		.loc 1 114 15 is_stmt 0 view .LVU117
 403 0080 1092 0000 		sts data.1912,__zero_reg__
 404 0084 00C0      		rjmp .L7
 405               	.LVL21:
 406               	.L8:
 104:tmk_core/protocol/xt_interrupt.c ****             break;
 407               		.loc 1 104 13 is_stmt 1 view .LVU118
 104:tmk_core/protocol/xt_interrupt.c ****             break;
 408               		.loc 1 104 16 is_stmt 0 view .LVU119
 409 0086 2111      		cpse r18,__zero_reg__
 410 0088 00C0      		rjmp .L9
 411               	.LVL22:
 412               	.L7:
 413               	/* epilogue start */
 117:tmk_core/protocol/xt_interrupt.c **** 
 414               		.loc 1 117 1 view .LVU120
 415 008a FF91      		pop r31
 416 008c EF91      		pop r30
 417 008e CF91      		pop r28
 418 0090 BF91      		pop r27
 419 0092 AF91      		pop r26
 420 0094 9F91      		pop r25
 421 0096 8F91      		pop r24
 422 0098 7F91      		pop r23
 423 009a 6F91      		pop r22
 424 009c 5F91      		pop r21
 425 009e 4F91      		pop r20
 426 00a0 3F91      		pop r19
 427 00a2 2F91      		pop r18
 428 00a4 0F90      		pop r0
 429 00a6 0FBE      		out __SREG__,r0
 430 00a8 0F90      		pop r0
 431 00aa 1F90      		pop r1
 432 00ac 1895      		reti
 433               	.LVL23:
 434               	.L13:
 108:tmk_core/protocol/xt_interrupt.c ****             break;
 435               		.loc 1 108 23 is_stmt 1 discriminator 1 view .LVU121
 108:tmk_core/protocol/xt_interrupt.c ****             break;
 436               		.loc 1 108 28 is_stmt 0 discriminator 1 view .LVU122
 437 00ae 8068      		ori r24,lo8(-128)
 438 00b0 00C0      		rjmp .L24
 439               	.LVL24:
 440               	.L15:
 441               	.LBB27:
 442               	.LBB25:
 134:tmk_core/protocol/xt_interrupt.c ****     }
 443               		.loc 1 134 9 is_stmt 1 view .LVU123
 134:tmk_core/protocol/xt_interrupt.c ****     }
 444               		.loc 1 134 9 view .LVU124
 445 00b2 8091 0000 		lds r24,debug_config
 446 00b6 80FF      		sbrs r24,0
 447 00b8 00C0      		rjmp .L16
 134:tmk_core/protocol/xt_interrupt.c ****     }
 448               		.loc 1 134 9 view .LVU125
 449               	.LBE25:
 450               	.LBE27:
 134:tmk_core/protocol/xt_interrupt.c ****     }
 451               		.loc 1 134 9 view .LVU126
 134:tmk_core/protocol/xt_interrupt.c ****     }
 452               		.loc 1 134 9 view .LVU127
 453               	.LBB28:
 454               	.LBB26:
 455 00ba 80E0      		ldi r24,lo8(__c.1925)
 456 00bc 90E0      		ldi r25,hi8(__c.1925)
 457 00be 9F93      		push r25
 458               	.LCFI15:
 459               		.cfi_def_cfa_offset 18
 460 00c0 8F93      		push r24
 461               	.LCFI16:
 462               		.cfi_def_cfa_offset 19
 463 00c2 0E94 0000 		call __xprintf
 464               	.LVL25:
 134:tmk_core/protocol/xt_interrupt.c ****     }
 465               		.loc 1 134 9 is_stmt 0 view .LVU128
 466 00c6 0F90      		pop __tmp_reg__
 467 00c8 0F90      		pop __tmp_reg__
 468               	.LCFI17:
 469               		.cfi_def_cfa_offset 17
 470 00ca 00C0      		rjmp .L16
 471               	.LBE26:
 472               	.LBE28:
 473               		.cfi_endproc
 474               	.LFE9:
 476               		.section	.progmem.data.__c.1925,"a"
 479               	__c.1925:
 480 0000 7062 7566 		.string	"pbuf: full\n"
 480      3A20 6675 
 480      6C6C 0A00 
 481               		.section	.bss.data.1912,"aw",@nobits
 484               	data.1912:
 485 0000 00        		.zero	1
 486               		.section	.bss.state.1911,"aw",@nobits
 489               	state.1911:
 490 0000 00        		.zero	1
 491               		.section	.bss.pbuf_tail,"aw",@nobits
 494               	pbuf_tail:
 495 0000 00        		.zero	1
 496               		.section	.bss.pbuf_head,"aw",@nobits
 499               	pbuf_head:
 500 0000 00        		.zero	1
 501               		.section	.bss.pbuf,"aw",@nobits
 504               	pbuf:
 505 0000 0000 0000 		.zero	32
 505      0000 0000 
 505      0000 0000 
 505      0000 0000 
 505      0000 0000 
 506               		.text
 507               	.Letext0:
 508               		.file 3 "/usr/avr/include/stdint.h"
 509               		.file 4 "tmk_core/common/debug.h"
 510               		.file 5 "tmk_core/common/avr/xprintf.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 xt_interrupt.c
     /tmp/ccJzhfPt.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccJzhfPt.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccJzhfPt.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccJzhfPt.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccJzhfPt.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccJzhfPt.s:13     .text.xt_host_init:0000000000000000 xt_host_init
     /tmp/ccJzhfPt.s:124    .text.xt_host_recv:0000000000000000 xt_host_recv
     /tmp/ccJzhfPt.s:499    .bss.pbuf_head:0000000000000000 pbuf_head
     /tmp/ccJzhfPt.s:494    .bss.pbuf_tail:0000000000000000 pbuf_tail
     /tmp/ccJzhfPt.s:504    .bss.pbuf:0000000000000000 pbuf
     /tmp/ccJzhfPt.s:240    .text.__vector_2:0000000000000000 __vector_2
     /tmp/ccJzhfPt.s:489    .bss.state.1911:0000000000000000 state.1911
     /tmp/ccJzhfPt.s:484    .bss.data.1912:0000000000000000 data.1912
     /tmp/ccJzhfPt.s:479    .progmem.data.__c.1925:0000000000000000 __c.1925

UNDEFINED SYMBOLS
debug_config
__xprintf
__do_clear_bss
