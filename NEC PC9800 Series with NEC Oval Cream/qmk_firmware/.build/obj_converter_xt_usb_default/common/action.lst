   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB15:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:tmk_core/common/action.c **** #    include "pointing_device.h"
  42:tmk_core/common/action.c **** #endif
  43:tmk_core/common/action.c **** 
  44:tmk_core/common/action.c **** int tp_buttons;
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  51:tmk_core/common/action.c **** #    include "fauxclicky.h"
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  55:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** 
  58:tmk_core/common/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  59:tmk_core/common/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  60:tmk_core/common/action.c **** #endif
  61:tmk_core/common/action.c **** 
  62:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  63:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  64:tmk_core/common/action.c **** #endif
  65:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  66:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  67:tmk_core/common/action.c **** #endif
  68:tmk_core/common/action.c **** /** \brief Called to execute an action.
  69:tmk_core/common/action.c ****  *
  70:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  71:tmk_core/common/action.c ****  */
  72:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 72 36 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  73:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 73 5 view .LVU1
  74:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  75:tmk_core/common/action.c ****         dprint("EVENT: ");
  76:tmk_core/common/action.c ****         debug_event(event);
  77:tmk_core/common/action.c ****         dprintln();
  49               		.loc 1 77 19 view .LVU2
  78:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  79:tmk_core/common/action.c ****         retro_tapping_counter++;
  80:tmk_core/common/action.c **** #endif
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c **** 
  83:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  84:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  85:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  86:tmk_core/common/action.c ****     }
  87:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  88:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  89:tmk_core/common/action.c ****     }
  90:tmk_core/common/action.c ****     fauxclicky_check();
  91:tmk_core/common/action.c **** #endif
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  94:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  95:tmk_core/common/action.c ****         process_hand_swap(&event);
  96:tmk_core/common/action.c ****     }
  97:tmk_core/common/action.c **** #endif
  98:tmk_core/common/action.c **** 
  99:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  50               		.loc 1 99 5 view .LVU3
  51               		.loc 1 99 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
 100:tmk_core/common/action.c **** 
 101:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 102:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
 103:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
 104:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 105:tmk_core/common/action.c ****     }
 106:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
 107:tmk_core/common/action.c ****         clear_oneshot_mods();
 108:tmk_core/common/action.c ****     }
 109:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 110:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 111:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 112:tmk_core/common/action.c ****     }
 113:tmk_core/common/action.c **** #        endif
 114:tmk_core/common/action.c **** #    endif
 115:tmk_core/common/action.c **** #endif
 116:tmk_core/common/action.c **** 
 117:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 118:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 118 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 118 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 118 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
 119:tmk_core/common/action.c **** #else
 120:tmk_core/common/action.c ****     process_record(&record);
 121:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 122:tmk_core/common/action.c ****         dprint("processed: ");
 123:tmk_core/common/action.c ****         debug_record(record);
 124:tmk_core/common/action.c ****         dprintln();
 125:tmk_core/common/action.c ****     }
 126:tmk_core/common/action.c **** #endif
 127:tmk_core/common/action.c **** }
  76               		.loc 1 127 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
 118:tmk_core/common/action.c **** #else
  85               		.loc 1 118 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE15:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB17:
 128:tmk_core/common/action.c **** 
 129:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 130:tmk_core/common/action.c **** bool swap_hands = false;
 131:tmk_core/common/action.c **** bool swap_held  = false;
 132:tmk_core/common/action.c **** 
 133:tmk_core/common/action.c **** /** \brief Process Hand Swap
 134:tmk_core/common/action.c ****  *
 135:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 136:tmk_core/common/action.c ****  */
 137:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 138:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 139:tmk_core/common/action.c **** 
 140:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 141:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 142:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 143:tmk_core/common/action.c **** 
 144:tmk_core/common/action.c ****     if (do_swap) {
 145:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 146:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 147:tmk_core/common/action.c ****     } else {
 148:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 149:tmk_core/common/action.c ****     }
 150:tmk_core/common/action.c **** }
 151:tmk_core/common/action.c **** #endif
 152:tmk_core/common/action.c **** 
 153:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 154:tmk_core/common/action.c **** bool disable_action_cache = false;
 155:tmk_core/common/action.c **** 
 156:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 157:tmk_core/common/action.c ****     disable_action_cache = true;
 158:tmk_core/common/action.c ****     process_record(record);
 159:tmk_core/common/action.c ****     disable_action_cache = false;
 160:tmk_core/common/action.c **** }
 161:tmk_core/common/action.c **** #else
 162:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 163:tmk_core/common/action.c **** #endif
 164:tmk_core/common/action.c **** 
 165:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  97               		.loc 1 165 72 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 103               		.loc 1 165 74 view .LVU11
 104               		.loc 1 165 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 165 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE17:
 113               		.section	.text.post_process_record_quantum,"ax",@progbits
 114               		.weak	post_process_record_quantum
 116               	post_process_record_quantum:
 117               	.LVL6:
 118               	.LFB18:
 166:tmk_core/common/action.c **** 
 167:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 119               		.loc 1 167 77 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 125               		.loc 1 167 78 view .LVU15
 126               	/* epilogue start */
 127               		.loc 1 167 1 is_stmt 0 view .LVU16
 128 0000 0895      		ret
 129               		.cfi_endproc
 130               	.LFE18:
 132               		.section	.text.process_record_tap_hint,"ax",@progbits
 133               	.global	process_record_tap_hint
 135               	process_record_tap_hint:
 136               	.LVL7:
 137               	.LFB19:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 170:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 171:tmk_core/common/action.c ****  *
 172:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 173:tmk_core/common/action.c ****  */
 174:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 138               		.loc 1 174 51 is_stmt 1 view -0
 139               		.cfi_startproc
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 175:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 144               		.loc 1 175 5 view .LVU18
 145               		.loc 1 175 23 is_stmt 0 view .LVU19
 146 0000 FC01      		movw r30,r24
 147 0002 8081      		ld r24,Z
 148 0004 9181      		ldd r25,Z+1
 149               	.LVL8:
 150               		.loc 1 175 23 view .LVU20
 151 0006 0C94 0000 		jmp layer_switch_get_action
 152               	.LVL9:
 153               		.loc 1 175 23 view .LVU21
 154               		.cfi_endproc
 155               	.LFE19:
 157               		.section	.text.register_code,"ax",@progbits
 158               	.global	register_code
 160               	register_code:
 161               	.LVL10:
 162               	.LFB23:
 176:tmk_core/common/action.c **** 
 177:tmk_core/common/action.c ****     switch (action.kind.id) {
 178:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 179:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 180:tmk_core/common/action.c ****             switch (action.swap.code) {
 181:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 182:tmk_core/common/action.c ****                     break;
 183:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 184:tmk_core/common/action.c ****                 default:
 185:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 186:tmk_core/common/action.c ****                     swap_held  = true;
 187:tmk_core/common/action.c ****             }
 188:tmk_core/common/action.c ****             break;
 189:tmk_core/common/action.c **** #    endif
 190:tmk_core/common/action.c ****     }
 191:tmk_core/common/action.c **** }
 192:tmk_core/common/action.c **** #endif
 193:tmk_core/common/action.c **** 
 194:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 195:tmk_core/common/action.c ****  *
 196:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 197:tmk_core/common/action.c ****  */
 198:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 199:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 200:tmk_core/common/action.c ****         return;
 201:tmk_core/common/action.c ****     }
 202:tmk_core/common/action.c **** 
 203:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 204:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 205:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 206:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 207:tmk_core/common/action.c ****         }
 208:tmk_core/common/action.c **** #endif
 209:tmk_core/common/action.c ****         return;
 210:tmk_core/common/action.c ****     }
 211:tmk_core/common/action.c **** 
 212:tmk_core/common/action.c ****     process_record_handler(record);
 213:tmk_core/common/action.c ****     post_process_record_quantum(record);
 214:tmk_core/common/action.c **** }
 215:tmk_core/common/action.c **** 
 216:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 217:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 218:tmk_core/common/action.c ****     dprint("ACTION: ");
 219:tmk_core/common/action.c ****     debug_action(action);
 220:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 221:tmk_core/common/action.c ****     dprint(" layer_state: ");
 222:tmk_core/common/action.c ****     layer_debug();
 223:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 224:tmk_core/common/action.c ****     default_layer_debug();
 225:tmk_core/common/action.c **** #endif
 226:tmk_core/common/action.c ****     dprintln();
 227:tmk_core/common/action.c **** 
 228:tmk_core/common/action.c ****     process_action(record, action);
 229:tmk_core/common/action.c **** }
 230:tmk_core/common/action.c **** 
 231:tmk_core/common/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 232:tmk_core/common/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 233:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 234:tmk_core/common/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 235:tmk_core/common/action.c **** #    endif
 236:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 237:tmk_core/common/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 238:tmk_core/common/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 239:tmk_core/common/action.c ****     pointing_device_set_report(currentReport);
 240:tmk_core/common/action.c **** #    endif
 241:tmk_core/common/action.c **** }
 242:tmk_core/common/action.c **** #endif
 243:tmk_core/common/action.c **** 
 244:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 245:tmk_core/common/action.c ****  *
 246:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 247:tmk_core/common/action.c ****  */
 248:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 249:tmk_core/common/action.c ****     keyevent_t event = record->event;
 250:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 251:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 252:tmk_core/common/action.c **** #endif
 253:tmk_core/common/action.c **** 
 254:tmk_core/common/action.c ****     if (event.pressed) {
 255:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 256:tmk_core/common/action.c ****         clear_weak_mods();
 257:tmk_core/common/action.c ****     }
 258:tmk_core/common/action.c **** 
 259:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 260:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 261:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 262:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 263:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 264:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 265:tmk_core/common/action.c **** #    endif
 266:tmk_core/common/action.c ****     ) {
 267:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 268:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 269:tmk_core/common/action.c ****     }
 270:tmk_core/common/action.c **** #endif
 271:tmk_core/common/action.c **** 
 272:tmk_core/common/action.c ****     switch (action.kind.id) {
 273:tmk_core/common/action.c ****         /* Key and Mods */
 274:tmk_core/common/action.c ****         case ACT_LMODS:
 275:tmk_core/common/action.c ****         case ACT_RMODS: {
 276:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 277:tmk_core/common/action.c ****             if (event.pressed) {
 278:tmk_core/common/action.c ****                 if (mods) {
 279:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 280:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 281:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 282:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 283:tmk_core/common/action.c ****                         add_mods(mods);
 284:tmk_core/common/action.c ****                     } else {
 285:tmk_core/common/action.c ****                         add_weak_mods(mods);
 286:tmk_core/common/action.c ****                     }
 287:tmk_core/common/action.c ****                     send_keyboard_report();
 288:tmk_core/common/action.c ****                 }
 289:tmk_core/common/action.c ****                 register_code(action.key.code);
 290:tmk_core/common/action.c ****             } else {
 291:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 292:tmk_core/common/action.c ****                 if (mods) {
 293:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 294:tmk_core/common/action.c ****                         del_mods(mods);
 295:tmk_core/common/action.c ****                     } else {
 296:tmk_core/common/action.c ****                         del_weak_mods(mods);
 297:tmk_core/common/action.c ****                     }
 298:tmk_core/common/action.c ****                     send_keyboard_report();
 299:tmk_core/common/action.c ****                 }
 300:tmk_core/common/action.c ****             }
 301:tmk_core/common/action.c ****         } break;
 302:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 303:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 304:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 305:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 306:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 307:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 308:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 309:tmk_core/common/action.c ****                     // Oneshot modifier
 310:tmk_core/common/action.c ****                     if (event.pressed) {
 311:tmk_core/common/action.c ****                         if (tap_count == 0) {
 312:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 313:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 314:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 315:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 316:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 317:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 318:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 319:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 320:tmk_core/common/action.c ****                             clear_oneshot_mods();
 321:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 322:tmk_core/common/action.c ****                             register_mods(mods);
 323:tmk_core/common/action.c **** #        endif
 324:tmk_core/common/action.c ****                         } else {
 325:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 326:tmk_core/common/action.c ****                         }
 327:tmk_core/common/action.c ****                     } else {
 328:tmk_core/common/action.c ****                         if (tap_count == 0) {
 329:tmk_core/common/action.c ****                             clear_oneshot_mods();
 330:tmk_core/common/action.c ****                             unregister_mods(mods);
 331:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 332:tmk_core/common/action.c ****                             // Retain Oneshot mods
 333:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 334:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 335:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 336:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 337:tmk_core/common/action.c ****                                 unregister_mods(mods);
 338:tmk_core/common/action.c ****                             }
 339:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 340:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 341:tmk_core/common/action.c **** #        endif
 342:tmk_core/common/action.c ****                         } else {
 343:tmk_core/common/action.c ****                             clear_oneshot_mods();
 344:tmk_core/common/action.c ****                             unregister_mods(mods);
 345:tmk_core/common/action.c ****                         }
 346:tmk_core/common/action.c ****                     }
 347:tmk_core/common/action.c ****                     break;
 348:tmk_core/common/action.c **** #    endif
 349:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 350:tmk_core/common/action.c ****                     if (event.pressed) {
 351:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 352:tmk_core/common/action.c ****                             register_mods(mods);
 353:tmk_core/common/action.c ****                         }
 354:tmk_core/common/action.c ****                     } else {
 355:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 356:tmk_core/common/action.c ****                             unregister_mods(mods);
 357:tmk_core/common/action.c ****                         }
 358:tmk_core/common/action.c ****                     }
 359:tmk_core/common/action.c ****                     break;
 360:tmk_core/common/action.c ****                 default:
 361:tmk_core/common/action.c ****                     if (event.pressed) {
 362:tmk_core/common/action.c ****                         if (tap_count > 0) {
 363:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 364:tmk_core/common/action.c ****                             if (
 365:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 366:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 367:tmk_core/common/action.c **** #        endif
 368:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 369:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 370:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 371:tmk_core/common/action.c ****                                 record->tap.count = 0;
 372:tmk_core/common/action.c ****                                 register_mods(mods);
 373:tmk_core/common/action.c ****                             } else
 374:tmk_core/common/action.c **** #    endif
 375:tmk_core/common/action.c ****                             {
 376:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 377:tmk_core/common/action.c ****                                 register_code(action.key.code);
 378:tmk_core/common/action.c ****                             }
 379:tmk_core/common/action.c ****                         } else {
 380:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 381:tmk_core/common/action.c ****                             register_mods(mods);
 382:tmk_core/common/action.c ****                         }
 383:tmk_core/common/action.c ****                     } else {
 384:tmk_core/common/action.c ****                         if (tap_count > 0) {
 385:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 386:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 387:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 388:tmk_core/common/action.c ****                             } else {
 389:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 390:tmk_core/common/action.c ****                             }
 391:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 392:tmk_core/common/action.c ****                         } else {
 393:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 394:tmk_core/common/action.c ****                             unregister_mods(mods);
 395:tmk_core/common/action.c ****                         }
 396:tmk_core/common/action.c ****                     }
 397:tmk_core/common/action.c ****                     break;
 398:tmk_core/common/action.c ****             }
 399:tmk_core/common/action.c ****         } break;
 400:tmk_core/common/action.c **** #endif
 401:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 402:tmk_core/common/action.c ****         /* other HID usage */
 403:tmk_core/common/action.c ****         case ACT_USAGE:
 404:tmk_core/common/action.c ****             switch (action.usage.page) {
 405:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 406:tmk_core/common/action.c ****                     if (event.pressed) {
 407:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 408:tmk_core/common/action.c ****                     } else {
 409:tmk_core/common/action.c ****                         host_system_send(0);
 410:tmk_core/common/action.c ****                     }
 411:tmk_core/common/action.c ****                     break;
 412:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 413:tmk_core/common/action.c ****                     if (event.pressed) {
 414:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 415:tmk_core/common/action.c ****                     } else {
 416:tmk_core/common/action.c ****                         host_consumer_send(0);
 417:tmk_core/common/action.c ****                     }
 418:tmk_core/common/action.c ****                     break;
 419:tmk_core/common/action.c ****             }
 420:tmk_core/common/action.c ****             break;
 421:tmk_core/common/action.c **** #endif
 422:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 423:tmk_core/common/action.c ****         /* Mouse key */
 424:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 425:tmk_core/common/action.c ****             if (event.pressed) {
 426:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 427:tmk_core/common/action.c ****                 switch (action.key.code) {
 428:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 429:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 430:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN1);
 431:tmk_core/common/action.c ****                         break;
 432:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 433:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN2);
 434:tmk_core/common/action.c ****                         break;
 435:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 436:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN3);
 437:tmk_core/common/action.c ****                         break;
 438:tmk_core/common/action.c **** #    endif
 439:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 440:tmk_core/common/action.c ****                     case KC_MS_BTN4:
 441:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN4);
 442:tmk_core/common/action.c ****                         break;
 443:tmk_core/common/action.c ****                     case KC_MS_BTN5:
 444:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN5);
 445:tmk_core/common/action.c ****                         break;
 446:tmk_core/common/action.c **** #    endif
 447:tmk_core/common/action.c ****                     default:
 448:tmk_core/common/action.c ****                         mousekey_send();
 449:tmk_core/common/action.c ****                         break;
 450:tmk_core/common/action.c ****                 }
 451:tmk_core/common/action.c ****             } else {
 452:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 453:tmk_core/common/action.c ****                 switch (action.key.code) {
 454:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 455:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 456:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN1);
 457:tmk_core/common/action.c ****                         break;
 458:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 459:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN2);
 460:tmk_core/common/action.c ****                         break;
 461:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 462:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN3);
 463:tmk_core/common/action.c ****                         break;
 464:tmk_core/common/action.c **** #    endif
 465:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 466:tmk_core/common/action.c ****                     case KC_MS_BTN4:
 467:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN4);
 468:tmk_core/common/action.c ****                         break;
 469:tmk_core/common/action.c ****                     case KC_MS_BTN5:
 470:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN5);
 471:tmk_core/common/action.c ****                         break;
 472:tmk_core/common/action.c **** #    endif
 473:tmk_core/common/action.c ****                     default:
 474:tmk_core/common/action.c ****                         mousekey_send();
 475:tmk_core/common/action.c ****                         break;
 476:tmk_core/common/action.c ****                 }
 477:tmk_core/common/action.c ****             }
 478:tmk_core/common/action.c ****             break;
 479:tmk_core/common/action.c **** #endif
 480:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 481:tmk_core/common/action.c ****         case ACT_LAYER:
 482:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 483:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 484:tmk_core/common/action.c ****                 if (!event.pressed) {
 485:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 486:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 487:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 488:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 489:tmk_core/common/action.c ****                         case OP_BIT_AND:
 490:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 491:tmk_core/common/action.c ****                             break;
 492:tmk_core/common/action.c ****                         case OP_BIT_OR:
 493:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 494:tmk_core/common/action.c ****                             break;
 495:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 496:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 497:tmk_core/common/action.c ****                             break;
 498:tmk_core/common/action.c ****                         case OP_BIT_SET:
 499:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 500:tmk_core/common/action.c ****                             break;
 501:tmk_core/common/action.c ****                     }
 502:tmk_core/common/action.c ****                 }
 503:tmk_core/common/action.c ****             } else {
 504:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 505:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 506:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 507:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 508:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 509:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 510:tmk_core/common/action.c ****                         case OP_BIT_AND:
 511:tmk_core/common/action.c ****                             layer_and(bits | mask);
 512:tmk_core/common/action.c ****                             break;
 513:tmk_core/common/action.c ****                         case OP_BIT_OR:
 514:tmk_core/common/action.c ****                             layer_or(bits | mask);
 515:tmk_core/common/action.c ****                             break;
 516:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 517:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 518:tmk_core/common/action.c ****                             break;
 519:tmk_core/common/action.c ****                         case OP_BIT_SET:
 520:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 521:tmk_core/common/action.c ****                             break;
 522:tmk_core/common/action.c ****                     }
 523:tmk_core/common/action.c ****                 }
 524:tmk_core/common/action.c ****             }
 525:tmk_core/common/action.c ****             break;
 526:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 527:tmk_core/common/action.c ****             if (event.pressed) {
 528:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 529:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 530:tmk_core/common/action.c ****             } else {
 531:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 532:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 533:tmk_core/common/action.c ****             }
 534:tmk_core/common/action.c ****             break;
 535:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 536:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 537:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 538:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 539:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 540:tmk_core/common/action.c ****                     /* tap toggle */
 541:tmk_core/common/action.c ****                     if (event.pressed) {
 542:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 543:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 544:tmk_core/common/action.c ****                         }
 545:tmk_core/common/action.c ****                     } else {
 546:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 547:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 548:tmk_core/common/action.c ****                         }
 549:tmk_core/common/action.c ****                     }
 550:tmk_core/common/action.c ****                     break;
 551:tmk_core/common/action.c ****                 case OP_ON_OFF:
 552:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 553:tmk_core/common/action.c ****                     break;
 554:tmk_core/common/action.c ****                 case OP_OFF_ON:
 555:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 556:tmk_core/common/action.c ****                     break;
 557:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 558:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 559:tmk_core/common/action.c ****                     break;
 560:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 561:tmk_core/common/action.c ****                 case OP_ONESHOT:
 562:tmk_core/common/action.c ****                     // Oneshot modifier
 563:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 564:tmk_core/common/action.c ****                     do_release_oneshot = false;
 565:tmk_core/common/action.c ****                     if (event.pressed) {
 566:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 567:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 568:tmk_core/common/action.c ****                             reset_oneshot_layer();
 569:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 570:tmk_core/common/action.c ****                             break;
 571:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 572:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 573:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 574:tmk_core/common/action.c ****                         }
 575:tmk_core/common/action.c ****                     } else {
 576:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 577:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 578:tmk_core/common/action.c ****                             reset_oneshot_layer();
 579:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 580:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 581:tmk_core/common/action.c ****                         } else {
 582:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 583:tmk_core/common/action.c ****                         }
 584:tmk_core/common/action.c ****                     }
 585:tmk_core/common/action.c **** #            else
 586:tmk_core/common/action.c ****                     if (event.pressed) {
 587:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 588:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 589:tmk_core/common/action.c ****                     } else {
 590:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 591:tmk_core/common/action.c ****                         if (tap_count > 1) {
 592:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 593:tmk_core/common/action.c ****                         }
 594:tmk_core/common/action.c ****                     }
 595:tmk_core/common/action.c **** #            endif
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c **** #        endif
 598:tmk_core/common/action.c ****                 default:
 599:tmk_core/common/action.c ****                     /* tap key */
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         if (tap_count > 0) {
 602:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 603:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 604:tmk_core/common/action.c ****                         } else {
 605:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 606:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 607:tmk_core/common/action.c ****                         }
 608:tmk_core/common/action.c ****                     } else {
 609:tmk_core/common/action.c ****                         if (tap_count > 0) {
 610:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 611:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 612:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 613:tmk_core/common/action.c ****                             } else {
 614:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 615:tmk_core/common/action.c ****                             }
 616:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 617:tmk_core/common/action.c ****                         } else {
 618:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 619:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 620:tmk_core/common/action.c ****                         }
 621:tmk_core/common/action.c ****                     }
 622:tmk_core/common/action.c ****                     break;
 623:tmk_core/common/action.c ****             }
 624:tmk_core/common/action.c ****             break;
 625:tmk_core/common/action.c **** #    endif
 626:tmk_core/common/action.c **** #endif
 627:tmk_core/common/action.c ****             /* Extentions */
 628:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 629:tmk_core/common/action.c ****         case ACT_MACRO:
 630:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 631:tmk_core/common/action.c ****             break;
 632:tmk_core/common/action.c **** #endif
 633:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 634:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 635:tmk_core/common/action.c ****             switch (action.swap.code) {
 636:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 637:tmk_core/common/action.c ****                     if (event.pressed) {
 638:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 639:tmk_core/common/action.c ****                     }
 640:tmk_core/common/action.c ****                     break;
 641:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 642:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 643:tmk_core/common/action.c ****                     break;
 644:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 645:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 646:tmk_core/common/action.c ****                     break;
 647:tmk_core/common/action.c ****                 case OP_SH_ON:
 648:tmk_core/common/action.c ****                     if (!event.pressed) {
 649:tmk_core/common/action.c ****                         swap_hands = true;
 650:tmk_core/common/action.c ****                     }
 651:tmk_core/common/action.c ****                     break;
 652:tmk_core/common/action.c ****                 case OP_SH_OFF:
 653:tmk_core/common/action.c ****                     if (!event.pressed) {
 654:tmk_core/common/action.c ****                         swap_hands = false;
 655:tmk_core/common/action.c ****                     }
 656:tmk_core/common/action.c ****                     break;
 657:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 658:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 659:tmk_core/common/action.c ****                     if (event.pressed) {
 660:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 661:tmk_core/common/action.c ****                     } else {
 662:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 663:tmk_core/common/action.c ****                     }
 664:tmk_core/common/action.c ****                     break;
 665:tmk_core/common/action.c **** #    endif
 666:tmk_core/common/action.c **** 
 667:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 668:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 669:tmk_core/common/action.c ****                     /* tap toggle */
 670:tmk_core/common/action.c **** 
 671:tmk_core/common/action.c ****                     if (event.pressed) {
 672:tmk_core/common/action.c ****                         if (swap_held) {
 673:tmk_core/common/action.c ****                             swap_held = false;
 674:tmk_core/common/action.c ****                         } else {
 675:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 676:tmk_core/common/action.c ****                         }
 677:tmk_core/common/action.c ****                     } else {
 678:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 679:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 680:tmk_core/common/action.c ****                         }
 681:tmk_core/common/action.c ****                     }
 682:tmk_core/common/action.c ****                     break;
 683:tmk_core/common/action.c ****                 default:
 684:tmk_core/common/action.c ****                     /* tap key */
 685:tmk_core/common/action.c ****                     if (tap_count > 0) {
 686:tmk_core/common/action.c ****                         if (swap_held) {
 687:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 688:tmk_core/common/action.c ****                             swap_held  = false;
 689:tmk_core/common/action.c ****                         }
 690:tmk_core/common/action.c ****                         if (event.pressed) {
 691:tmk_core/common/action.c ****                             register_code(action.swap.code);
 692:tmk_core/common/action.c ****                         } else {
 693:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 694:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 695:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 696:tmk_core/common/action.c ****                         }
 697:tmk_core/common/action.c ****                     } else {
 698:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 699:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 700:tmk_core/common/action.c ****                             swap_held  = false;
 701:tmk_core/common/action.c ****                         }
 702:tmk_core/common/action.c ****                     }
 703:tmk_core/common/action.c **** #    endif
 704:tmk_core/common/action.c ****             }
 705:tmk_core/common/action.c **** #endif
 706:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 707:tmk_core/common/action.c ****         case ACT_FUNCTION:
 708:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 709:tmk_core/common/action.c ****             break;
 710:tmk_core/common/action.c **** #endif
 711:tmk_core/common/action.c ****         default:
 712:tmk_core/common/action.c ****             break;
 713:tmk_core/common/action.c ****     }
 714:tmk_core/common/action.c **** 
 715:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 716:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 717:tmk_core/common/action.c ****     switch (action.kind.id) {
 718:tmk_core/common/action.c ****         case ACT_LAYER:
 719:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 720:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 721:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 722:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 723:tmk_core/common/action.c **** #    endif
 724:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 725:tmk_core/common/action.c ****             break;
 726:tmk_core/common/action.c ****         default:
 727:tmk_core/common/action.c ****             break;
 728:tmk_core/common/action.c ****     }
 729:tmk_core/common/action.c **** #endif
 730:tmk_core/common/action.c **** 
 731:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 732:tmk_core/common/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 733:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 734:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 735:tmk_core/common/action.c ****     } else {
 736:tmk_core/common/action.c ****         if (event.pressed) {
 737:tmk_core/common/action.c ****             if (tap_count > 0) {
 738:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 739:tmk_core/common/action.c ****             }
 740:tmk_core/common/action.c ****         } else {
 741:tmk_core/common/action.c ****             if (tap_count > 0) {
 742:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 743:tmk_core/common/action.c ****             } else {
 744:tmk_core/common/action.c ****                 if (
 745:tmk_core/common/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 746:tmk_core/common/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 747:tmk_core/common/action.c **** #        endif
 748:tmk_core/common/action.c ****                     retro_tapping_counter == 2) {
 749:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 750:tmk_core/common/action.c ****                 }
 751:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 752:tmk_core/common/action.c ****             }
 753:tmk_core/common/action.c ****         }
 754:tmk_core/common/action.c ****     }
 755:tmk_core/common/action.c **** #    endif
 756:tmk_core/common/action.c **** #endif
 757:tmk_core/common/action.c **** 
 758:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 759:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 760:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 761:tmk_core/common/action.c ****         use_oneshot_swaphands();
 762:tmk_core/common/action.c ****     }
 763:tmk_core/common/action.c **** #    endif
 764:tmk_core/common/action.c **** #endif
 765:tmk_core/common/action.c **** 
 766:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 767:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 768:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 769:tmk_core/common/action.c ****      */
 770:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 771:tmk_core/common/action.c ****         record->event.pressed = false;
 772:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 773:tmk_core/common/action.c ****         process_record(record);
 774:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 775:tmk_core/common/action.c ****     }
 776:tmk_core/common/action.c **** #endif
 777:tmk_core/common/action.c **** }
 778:tmk_core/common/action.c **** 
 779:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 780:tmk_core/common/action.c ****  *
 781:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 782:tmk_core/common/action.c ****  */
 783:tmk_core/common/action.c **** void register_code(uint8_t code) {
 163               		.loc 1 783 34 is_stmt 1 view -0
 164               		.cfi_startproc
 165               		.loc 1 783 34 is_stmt 0 view .LVU23
 166 0000 CF93      		push r28
 167               	.LCFI4:
 168               		.cfi_def_cfa_offset 3
 169               		.cfi_offset 28, -2
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 172               	/* stack size = 1 */
 173               	.L__stack_usage = 1
 174 0002 C82F      		mov r28,r24
 784:tmk_core/common/action.c ****     if (code == KC_NO) {
 175               		.loc 1 784 5 is_stmt 1 view .LVU24
 176               		.loc 1 784 8 is_stmt 0 view .LVU25
 177 0004 8823      		tst r24
 178 0006 01F4      		brne .+2
 179 0008 00C0      		rjmp .L5
 785:tmk_core/common/action.c ****         return;
 786:tmk_core/common/action.c ****     }
 787:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 788:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 789:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 790:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 791:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 792:tmk_core/common/action.c **** #    endif
 793:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 794:tmk_core/common/action.c ****         send_keyboard_report();
 795:tmk_core/common/action.c ****         wait_ms(100);
 796:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 797:tmk_core/common/action.c ****         send_keyboard_report();
 798:tmk_core/common/action.c ****     }
 799:tmk_core/common/action.c **** 
 800:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 801:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 802:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 803:tmk_core/common/action.c **** #    endif
 804:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:tmk_core/common/action.c ****         send_keyboard_report();
 806:tmk_core/common/action.c ****         wait_ms(100);
 807:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 808:tmk_core/common/action.c ****         send_keyboard_report();
 809:tmk_core/common/action.c ****     }
 810:tmk_core/common/action.c **** 
 811:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 812:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 813:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 814:tmk_core/common/action.c **** #    endif
 815:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 816:tmk_core/common/action.c ****         send_keyboard_report();
 817:tmk_core/common/action.c ****         wait_ms(100);
 818:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 819:tmk_core/common/action.c ****         send_keyboard_report();
 820:tmk_core/common/action.c ****     }
 821:tmk_core/common/action.c **** #endif
 822:tmk_core/common/action.c **** 
 823:tmk_core/common/action.c ****     else if
 180               		.loc 1 823 10 is_stmt 1 view .LVU26
 824:tmk_core/common/action.c ****         IS_KEY(code) {
 181               		.loc 1 824 9 is_stmt 0 view .LVU27
 182 000a 8CEF      		ldi r24,lo8(-4)
 183               	.LVL11:
 184               		.loc 1 824 9 view .LVU28
 185 000c 8C0F      		add r24,r28
 186 000e 813A      		cpi r24,lo8(-95)
 187 0010 00F4      		brsh .L8
 825:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 826:tmk_core/common/action.c ****             if (command_proc(code)) return;
 188               		.loc 1 826 13 is_stmt 1 view .LVU29
 189               		.loc 1 826 17 is_stmt 0 view .LVU30
 190 0012 8C2F      		mov r24,r28
 191 0014 0E94 0000 		call command_proc
 192               	.LVL12:
 193               		.loc 1 826 16 view .LVU31
 194 0018 8111      		cpse r24,__zero_reg__
 195 001a 00C0      		rjmp .L5
 827:tmk_core/common/action.c **** 
 828:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 829:tmk_core/common/action.c **** /* TODO: remove
 830:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 831:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 832:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 833:tmk_core/common/action.c **** 
 834:tmk_core/common/action.c ****             add_key(code);
 835:tmk_core/common/action.c ****             send_keyboard_report();
 836:tmk_core/common/action.c **** 
 837:tmk_core/common/action.c ****             set_mods(tmp_mods);
 838:tmk_core/common/action.c ****             send_keyboard_report();
 839:tmk_core/common/action.c ****             oneshot_cancel();
 840:tmk_core/common/action.c ****         } else
 841:tmk_core/common/action.c **** */
 842:tmk_core/common/action.c **** #endif
 843:tmk_core/common/action.c ****             {
 844:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 845:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 846:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 847:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 196               		.loc 1 847 17 is_stmt 1 view .LVU32
 197               		.loc 1 847 21 is_stmt 0 view .LVU33
 198 001c 6C2F      		mov r22,r28
 199 001e 8091 0000 		lds r24,keyboard_report
 200 0022 9091 0000 		lds r25,keyboard_report+1
 201 0026 0E94 0000 		call is_key_pressed
 202               	.LVL13:
 203               		.loc 1 847 20 view .LVU34
 204 002a 8823      		tst r24
 205 002c 01F0      		breq .L10
 848:tmk_core/common/action.c ****                     del_key(code);
 206               		.loc 1 848 21 is_stmt 1 view .LVU35
 207 002e 8C2F      		mov r24,r28
 208 0030 0E94 0000 		call del_key
 209               	.LVL14:
 849:tmk_core/common/action.c ****                     send_keyboard_report();
 210               		.loc 1 849 21 view .LVU36
 211 0034 0E94 0000 		call send_keyboard_report
 212               	.LVL15:
 213               	.L10:
 850:tmk_core/common/action.c ****                 }
 851:tmk_core/common/action.c ****                 add_key(code);
 214               		.loc 1 851 17 view .LVU37
 215 0038 8C2F      		mov r24,r28
 216 003a 0E94 0000 		call add_key
 217               	.LVL16:
 852:tmk_core/common/action.c ****                 send_keyboard_report();
 218               		.loc 1 852 17 view .LVU38
 219               	.L17:
 853:tmk_core/common/action.c ****             }
 854:tmk_core/common/action.c ****         }
 855:tmk_core/common/action.c ****     else if
 856:tmk_core/common/action.c ****         IS_MOD(code) {
 857:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 858:tmk_core/common/action.c ****             send_keyboard_report();
 220               		.loc 1 858 13 view .LVU39
 221               	/* epilogue start */
 859:tmk_core/common/action.c ****         }
 860:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 861:tmk_core/common/action.c ****     else if
 862:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 863:tmk_core/common/action.c ****     else if
 864:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 865:tmk_core/common/action.c **** #endif
 866:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 867:tmk_core/common/action.c ****     else if
 868:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 869:tmk_core/common/action.c ****             mousekey_on(code);
 870:tmk_core/common/action.c ****             mousekey_send();
 871:tmk_core/common/action.c ****         }
 872:tmk_core/common/action.c **** #endif
 873:tmk_core/common/action.c **** }
 222               		.loc 1 873 1 is_stmt 0 view .LVU40
 223 003e CF91      		pop r28
 858:tmk_core/common/action.c ****         }
 224               		.loc 1 858 13 view .LVU41
 225 0040 0C94 0000 		jmp send_keyboard_report
 226               	.LVL17:
 227               	.L8:
 855:tmk_core/common/action.c ****         IS_MOD(code) {
 228               		.loc 1 855 10 is_stmt 1 view .LVU42
 856:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 229               		.loc 1 856 9 is_stmt 0 view .LVU43
 230 0044 80E2      		ldi r24,lo8(32)
 231 0046 8C0F      		add r24,r28
 232 0048 8830      		cpi r24,lo8(8)
 233 004a 00F4      		brsh .L11
 857:tmk_core/common/action.c ****             send_keyboard_report();
 234               		.loc 1 857 13 is_stmt 1 view .LVU44
 857:tmk_core/common/action.c ****             send_keyboard_report();
 235               		.loc 1 857 22 is_stmt 0 view .LVU45
 236 004c C770      		andi r28,lo8(7)
 237               	.LVL18:
 857:tmk_core/common/action.c ****             send_keyboard_report();
 238               		.loc 1 857 13 view .LVU46
 239 004e 81E0      		ldi r24,lo8(1)
 240 0050 00C0      		rjmp 2f
 241               		1:
 242 0052 880F      		lsl r24
 243               		2:
 244 0054 CA95      		dec r28
 245 0056 02F4      		brpl 1b
 246 0058 0E94 0000 		call add_mods
 247               	.LVL19:
 248 005c 00C0      		rjmp .L17
 249               	.LVL20:
 250               	.L11:
 861:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 251               		.loc 1 861 10 is_stmt 1 view .LVU47
 862:tmk_core/common/action.c ****     else if
 252               		.loc 1 862 9 is_stmt 0 view .LVU48
 253 005e EBE5      		ldi r30,lo8(91)
 254 0060 EC0F      		add r30,r28
 255 0062 E330      		cpi r30,lo8(3)
 256 0064 00F4      		brsh .L12
 862:tmk_core/common/action.c ****     else if
 257               		.loc 1 862 27 is_stmt 1 view .LVU49
 258               	.LVL21:
 259               	.LBB22:
 260               	.LBI22:
 261               		.file 2 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK
  34:tmk_core/common/report.h **** };
  35:tmk_core/common/report.h **** 
  36:tmk_core/common/report.h **** /* Mouse buttons */
  37:tmk_core/common/report.h **** enum mouse_buttons {
  38:tmk_core/common/report.h ****     MOUSE_BTN1 = (1 << 0),
  39:tmk_core/common/report.h ****     MOUSE_BTN2 = (1 << 1),
  40:tmk_core/common/report.h ****     MOUSE_BTN3 = (1 << 2),
  41:tmk_core/common/report.h ****     MOUSE_BTN4 = (1 << 3),
  42:tmk_core/common/report.h ****     MOUSE_BTN5 = (1 << 4)
  43:tmk_core/common/report.h **** };
  44:tmk_core/common/report.h **** 
  45:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  46:tmk_core/common/report.h ****  *
  47:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  48:tmk_core/common/report.h ****  */
  49:tmk_core/common/report.h **** enum consumer_usages {
  50:tmk_core/common/report.h ****     // 15.5 Display Controls
  51:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  52:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  53:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  54:tmk_core/common/report.h ****     // 15.7 Transport Controls
  55:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  56:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  57:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  58:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  59:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  60:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  61:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  62:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  63:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  64:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  65:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  66:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  67:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  68:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  69:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  70:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  71:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  72:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  73:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  74:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  75:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  76:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  77:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  78:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  79:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  80:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  81:tmk_core/common/report.h ****     AC_HOME                = 0x223,
  82:tmk_core/common/report.h ****     AC_BACK                = 0x224,
  83:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
  84:tmk_core/common/report.h ****     AC_STOP                = 0x226,
  85:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
  86:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
  87:tmk_core/common/report.h **** };
  88:tmk_core/common/report.h **** 
  89:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
  90:tmk_core/common/report.h ****  *
  91:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
  92:tmk_core/common/report.h ****  */
  93:tmk_core/common/report.h **** enum desktop_usages {
  94:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
  95:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN = 0x81,
  96:tmk_core/common/report.h ****     SYSTEM_SLEEP      = 0x82,
  97:tmk_core/common/report.h ****     SYSTEM_WAKE_UP    = 0x83
  98:tmk_core/common/report.h **** };
  99:tmk_core/common/report.h **** 
 100:tmk_core/common/report.h **** // clang-format on
 101:tmk_core/common/report.h **** 
 102:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 103:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 104:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 105:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 106:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 107:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 108:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 109:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 110:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 111:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 112:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 113:tmk_core/common/report.h **** #    else
 114:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 115:tmk_core/common/report.h **** #    endif
 116:tmk_core/common/report.h **** #endif
 117:tmk_core/common/report.h **** 
 118:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 119:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 120:tmk_core/common/report.h **** #else
 121:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 122:tmk_core/common/report.h **** #endif
 123:tmk_core/common/report.h **** 
 124:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 125:tmk_core/common/report.h **** 
 126:tmk_core/common/report.h **** /* VUSB hardcodes keyboard and mouse+extrakey only */
 127:tmk_core/common/report.h **** #if defined(PROTOCOL_VUSB)
 128:tmk_core/common/report.h **** #    undef KEYBOARD_SHARED_EP
 129:tmk_core/common/report.h **** #    undef MOUSE_SHARED_EP
 130:tmk_core/common/report.h **** #endif
 131:tmk_core/common/report.h **** 
 132:tmk_core/common/report.h **** #ifdef __cplusplus
 133:tmk_core/common/report.h **** extern "C" {
 134:tmk_core/common/report.h **** #endif
 135:tmk_core/common/report.h **** 
 136:tmk_core/common/report.h **** /*
 137:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 138:tmk_core/common/report.h ****  *
 139:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 140:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 141:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 142:tmk_core/common/report.h ****  *
 143:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 144:tmk_core/common/report.h ****  *
 145:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 146:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 147:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 148:tmk_core/common/report.h ****  *
 149:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 150:tmk_core/common/report.h ****  *
 151:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 152:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 153:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 154:tmk_core/common/report.h ****  *
 155:tmk_core/common/report.h ****  */
 156:tmk_core/common/report.h **** typedef union {
 157:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 158:tmk_core/common/report.h ****     struct {
 159:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 160:tmk_core/common/report.h ****         uint8_t report_id;
 161:tmk_core/common/report.h **** #endif
 162:tmk_core/common/report.h ****         uint8_t mods;
 163:tmk_core/common/report.h ****         uint8_t reserved;
 164:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 165:tmk_core/common/report.h ****     };
 166:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 167:tmk_core/common/report.h ****     struct nkro_report {
 168:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 169:tmk_core/common/report.h ****         uint8_t report_id;
 170:tmk_core/common/report.h **** #    endif
 171:tmk_core/common/report.h ****         uint8_t mods;
 172:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 173:tmk_core/common/report.h ****     } nkro;
 174:tmk_core/common/report.h **** #endif
 175:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 176:tmk_core/common/report.h **** 
 177:tmk_core/common/report.h **** typedef struct {
 178:tmk_core/common/report.h ****     uint8_t  report_id;
 179:tmk_core/common/report.h ****     uint16_t usage;
 180:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 181:tmk_core/common/report.h **** 
 182:tmk_core/common/report.h **** typedef struct {
 183:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 184:tmk_core/common/report.h ****     uint8_t report_id;
 185:tmk_core/common/report.h **** #endif
 186:tmk_core/common/report.h ****     uint8_t buttons;
 187:tmk_core/common/report.h ****     int8_t  x;
 188:tmk_core/common/report.h ****     int8_t  y;
 189:tmk_core/common/report.h ****     int8_t  v;
 190:tmk_core/common/report.h ****     int8_t  h;
 191:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 192:tmk_core/common/report.h **** 
 193:tmk_core/common/report.h **** typedef struct {
 194:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 195:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 196:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 197:tmk_core/common/report.h **** #    else
 198:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 199:tmk_core/common/report.h **** #    endif
 200:tmk_core/common/report.h **** #endif
 201:tmk_core/common/report.h **** 
 202:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 203:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 204:tmk_core/common/report.h **** #endif
 205:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 206:tmk_core/common/report.h **** 
 207:tmk_core/common/report.h **** /* keycode to system usage */
 208:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 262               		.loc 2 208 24 view .LVU50
 263               	.LBE22:
 209:tmk_core/common/report.h ****     switch (key) {
 264               		.loc 2 209 5 view .LVU51
 862:tmk_core/common/action.c ****     else if
 265               		.loc 1 862 27 is_stmt 0 view .LVU52
 266 0066 F0E0      		ldi r31,0
 267 0068 E050      		subi r30,lo8(-(CSWTCH.10))
 268 006a F040      		sbci r31,hi8(-(CSWTCH.10))
 269 006c 8081      		ld r24,Z
 270 006e 90E0      		ldi r25,0
 271               	/* epilogue start */
 272               		.loc 1 873 1 view .LVU53
 273 0070 CF91      		pop r28
 274               	.LVL22:
 862:tmk_core/common/action.c ****     else if
 275               		.loc 1 862 27 view .LVU54
 276 0072 0C94 0000 		jmp host_system_send
 277               	.LVL23:
 278               	.L12:
 863:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 279               		.loc 1 863 10 is_stmt 1 view .LVU55
 864:tmk_core/common/action.c **** #endif
 280               		.loc 1 864 9 is_stmt 0 view .LVU56
 281 0076 E8E5      		ldi r30,lo8(88)
 282 0078 EC0F      		add r30,r28
 283 007a E731      		cpi r30,lo8(23)
 284 007c 00F4      		brsh .L13
 864:tmk_core/common/action.c **** #endif
 285               		.loc 1 864 29 is_stmt 1 view .LVU57
 286               	.LVL24:
 287               	.LBB23:
 288               	.LBI23:
 210:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 211:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 212:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 213:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 214:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 215:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 216:tmk_core/common/report.h ****         default:
 217:tmk_core/common/report.h ****             return 0;
 218:tmk_core/common/report.h ****     }
 219:tmk_core/common/report.h **** }
 220:tmk_core/common/report.h **** 
 221:tmk_core/common/report.h **** /* keycode to consumer usage */
 222:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 289               		.loc 2 222 24 view .LVU58
 290               	.LBE23:
 223:tmk_core/common/report.h ****     switch (key) {
 291               		.loc 2 223 5 view .LVU59
 864:tmk_core/common/action.c **** #endif
 292               		.loc 1 864 29 is_stmt 0 view .LVU60
 293 007e F0E0      		ldi r31,0
 294 0080 EE0F      		lsl r30
 295 0082 FF1F      		rol r31
 296 0084 E050      		subi r30,lo8(-(CSWTCH.11))
 297 0086 F040      		sbci r31,hi8(-(CSWTCH.11))
 298 0088 8081      		ld r24,Z
 299 008a 9181      		ldd r25,Z+1
 300               	/* epilogue start */
 301               		.loc 1 873 1 view .LVU61
 302 008c CF91      		pop r28
 303               	.LVL25:
 864:tmk_core/common/action.c **** #endif
 304               		.loc 1 864 29 view .LVU62
 305 008e 0C94 0000 		jmp host_consumer_send
 306               	.LVL26:
 307               	.L13:
 867:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 308               		.loc 1 867 10 is_stmt 1 view .LVU63
 868:tmk_core/common/action.c ****             mousekey_on(code);
 309               		.loc 1 868 9 is_stmt 0 view .LVU64
 310 0092 C03F      		cpi r28,lo8(-16)
 311 0094 00F0      		brlo .L5
 869:tmk_core/common/action.c ****             mousekey_send();
 312               		.loc 1 869 13 is_stmt 1 view .LVU65
 313 0096 8C2F      		mov r24,r28
 314 0098 0E94 0000 		call mousekey_on
 315               	.LVL27:
 870:tmk_core/common/action.c ****         }
 316               		.loc 1 870 13 view .LVU66
 317               	/* epilogue start */
 318               		.loc 1 873 1 is_stmt 0 view .LVU67
 319 009c CF91      		pop r28
 320               	.LVL28:
 870:tmk_core/common/action.c ****         }
 321               		.loc 1 870 13 view .LVU68
 322 009e 0C94 0000 		jmp mousekey_send
 323               	.LVL29:
 324               	.L5:
 325               	/* epilogue start */
 326               		.loc 1 873 1 view .LVU69
 327 00a2 CF91      		pop r28
 328               	.LVL30:
 329               		.loc 1 873 1 view .LVU70
 330 00a4 0895      		ret
 331               		.cfi_endproc
 332               	.LFE23:
 334               		.section	.text.unregister_code,"ax",@progbits
 335               	.global	unregister_code
 337               	unregister_code:
 338               	.LVL31:
 339               	.LFB24:
 874:tmk_core/common/action.c **** 
 875:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 876:tmk_core/common/action.c ****  *
 877:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 878:tmk_core/common/action.c ****  */
 879:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 340               		.loc 1 879 36 is_stmt 1 view -0
 341               		.cfi_startproc
 342               	/* prologue: function */
 343               	/* frame size = 0 */
 344               	/* stack size = 0 */
 345               	.L__stack_usage = 0
 880:tmk_core/common/action.c ****     if (code == KC_NO) {
 346               		.loc 1 880 5 view .LVU72
 347               		.loc 1 880 8 is_stmt 0 view .LVU73
 348 0000 8823      		tst r24
 349 0002 01F0      		breq .L18
 881:tmk_core/common/action.c ****         return;
 882:tmk_core/common/action.c ****     }
 883:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 884:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 885:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 886:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 887:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 888:tmk_core/common/action.c **** #    endif
 889:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 890:tmk_core/common/action.c ****         send_keyboard_report();
 891:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 892:tmk_core/common/action.c ****         send_keyboard_report();
 893:tmk_core/common/action.c ****     }
 894:tmk_core/common/action.c **** 
 895:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 896:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 897:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 898:tmk_core/common/action.c **** #    endif
 899:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 900:tmk_core/common/action.c ****         send_keyboard_report();
 901:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 902:tmk_core/common/action.c ****         send_keyboard_report();
 903:tmk_core/common/action.c ****     }
 904:tmk_core/common/action.c **** 
 905:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 906:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 907:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 908:tmk_core/common/action.c **** #    endif
 909:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 910:tmk_core/common/action.c ****         send_keyboard_report();
 911:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 912:tmk_core/common/action.c ****         send_keyboard_report();
 913:tmk_core/common/action.c ****     }
 914:tmk_core/common/action.c **** #endif
 915:tmk_core/common/action.c **** 
 916:tmk_core/common/action.c ****     else if
 350               		.loc 1 916 10 is_stmt 1 view .LVU74
 917:tmk_core/common/action.c ****         IS_KEY(code) {
 351               		.loc 1 917 9 is_stmt 0 view .LVU75
 352 0004 9CEF      		ldi r25,lo8(-4)
 353 0006 980F      		add r25,r24
 354 0008 913A      		cpi r25,lo8(-95)
 355 000a 00F4      		brsh .L20
 918:tmk_core/common/action.c ****             del_key(code);
 356               		.loc 1 918 13 is_stmt 1 view .LVU76
 357 000c 0E94 0000 		call del_key
 358               	.LVL32:
 919:tmk_core/common/action.c ****             send_keyboard_report();
 359               		.loc 1 919 13 view .LVU77
 360               	.L27:
 920:tmk_core/common/action.c ****         }
 921:tmk_core/common/action.c ****     else if
 922:tmk_core/common/action.c ****         IS_MOD(code) {
 923:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 924:tmk_core/common/action.c ****             send_keyboard_report();
 361               		.loc 1 924 13 view .LVU78
 362 0010 0C94 0000 		jmp send_keyboard_report
 363               	.LVL33:
 364               	.L20:
 921:tmk_core/common/action.c ****         IS_MOD(code) {
 365               		.loc 1 921 10 view .LVU79
 922:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 366               		.loc 1 922 9 is_stmt 0 view .LVU80
 367 0014 90E2      		ldi r25,lo8(32)
 368 0016 980F      		add r25,r24
 369 0018 9830      		cpi r25,lo8(8)
 370 001a 00F4      		brsh .L21
 923:tmk_core/common/action.c ****             send_keyboard_report();
 371               		.loc 1 923 13 is_stmt 1 view .LVU81
 923:tmk_core/common/action.c ****             send_keyboard_report();
 372               		.loc 1 923 22 is_stmt 0 view .LVU82
 373 001c 8770      		andi r24,lo8(7)
 374               	.LVL34:
 923:tmk_core/common/action.c ****             send_keyboard_report();
 375               		.loc 1 923 13 view .LVU83
 376 001e 91E0      		ldi r25,lo8(1)
 377 0020 00C0      		rjmp 2f
 378               		1:
 379 0022 990F      		lsl r25
 380               		2:
 381 0024 8A95      		dec r24
 382 0026 02F4      		brpl 1b
 383 0028 892F      		mov r24,r25
 384 002a 0E94 0000 		call del_mods
 385               	.LVL35:
 386 002e 00C0      		rjmp .L27
 387               	.LVL36:
 388               	.L21:
 925:tmk_core/common/action.c ****         }
 926:tmk_core/common/action.c ****     else if
 389               		.loc 1 926 10 is_stmt 1 view .LVU84
 927:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 390               		.loc 1 927 9 is_stmt 0 view .LVU85
 391 0030 9BE5      		ldi r25,lo8(91)
 392 0032 980F      		add r25,r24
 393 0034 9330      		cpi r25,lo8(3)
 394 0036 00F4      		brsh .L22
 395               		.loc 1 927 27 is_stmt 1 discriminator 1 view .LVU86
 396 0038 90E0      		ldi r25,0
 397 003a 80E0      		ldi r24,0
 398               	.LVL37:
 399               		.loc 1 927 27 is_stmt 0 discriminator 1 view .LVU87
 400 003c 0C94 0000 		jmp host_system_send
 401               	.LVL38:
 402               	.L22:
 928:tmk_core/common/action.c ****     else if
 403               		.loc 1 928 10 is_stmt 1 view .LVU88
 929:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 404               		.loc 1 929 9 is_stmt 0 view .LVU89
 405 0040 98E5      		ldi r25,lo8(88)
 406 0042 980F      		add r25,r24
 407 0044 9731      		cpi r25,lo8(23)
 408 0046 00F4      		brsh .L23
 409               		.loc 1 929 29 is_stmt 1 discriminator 1 view .LVU90
 410 0048 90E0      		ldi r25,0
 411 004a 80E0      		ldi r24,0
 412               	.LVL39:
 413               		.loc 1 929 29 is_stmt 0 discriminator 1 view .LVU91
 414 004c 0C94 0000 		jmp host_consumer_send
 415               	.LVL40:
 416               	.L23:
 930:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 931:tmk_core/common/action.c ****     else if
 417               		.loc 1 931 10 is_stmt 1 view .LVU92
 932:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 418               		.loc 1 932 9 is_stmt 0 view .LVU93
 419 0050 803F      		cpi r24,lo8(-16)
 420 0052 00F0      		brlo .L18
 933:tmk_core/common/action.c ****             mousekey_off(code);
 421               		.loc 1 933 13 is_stmt 1 view .LVU94
 422 0054 0E94 0000 		call mousekey_off
 423               	.LVL41:
 934:tmk_core/common/action.c ****             mousekey_send();
 424               		.loc 1 934 13 view .LVU95
 425 0058 0C94 0000 		jmp mousekey_send
 426               	.LVL42:
 427               	.L18:
 428               	/* epilogue start */
 935:tmk_core/common/action.c ****         }
 936:tmk_core/common/action.c **** #endif
 937:tmk_core/common/action.c **** }
 429               		.loc 1 937 1 is_stmt 0 view .LVU96
 430 005c 0895      		ret
 431               		.cfi_endproc
 432               	.LFE24:
 434               		.section	.text.tap_code,"ax",@progbits
 435               	.global	tap_code
 437               	tap_code:
 438               	.LVL43:
 439               	.LFB25:
 938:tmk_core/common/action.c **** 
 939:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 940:tmk_core/common/action.c ****  *
 941:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 942:tmk_core/common/action.c ****  */
 943:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 440               		.loc 1 943 29 is_stmt 1 view -0
 441               		.cfi_startproc
 442               		.loc 1 943 29 is_stmt 0 view .LVU98
 443 0000 CF93      		push r28
 444               	.LCFI5:
 445               		.cfi_def_cfa_offset 3
 446               		.cfi_offset 28, -2
 447               	/* prologue: function */
 448               	/* frame size = 0 */
 449               	/* stack size = 1 */
 450               	.L__stack_usage = 1
 451 0002 C82F      		mov r28,r24
 944:tmk_core/common/action.c ****     register_code(code);
 452               		.loc 1 944 5 is_stmt 1 view .LVU99
 453 0004 0E94 0000 		call register_code
 454               	.LVL44:
 945:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 455               		.loc 1 945 5 view .LVU100
 456               		.loc 1 945 8 is_stmt 0 view .LVU101
 457 0008 C933      		cpi r28,lo8(57)
 458 000a 01F4      		brne .L30
 946:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 459               		.loc 1 946 9 is_stmt 1 view .LVU102
 460               	.LVL45:
 461               	.LBB24:
 462               	.LBI24:
 463               		.file 3 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 464               		.loc 3 166 1 view .LVU103
 465               	.LBB25:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 466               		.loc 3 168 2 view .LVU104
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 467               		.loc 3 172 2 view .LVU105
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 468               		.loc 3 173 2 view .LVU106
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 469               		.loc 3 174 2 view .LVU107
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 470               		.loc 3 184 3 view .LVU108
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 471               		.loc 3 187 2 view .LVU109
 472 000c 2FEF      		ldi r18,lo8(255999)
 473 000e 87EE      		ldi r24,hi8(255999)
 474 0010 93E0      		ldi r25,hlo8(255999)
 475 0012 2150      	1:	subi r18,1
 476 0014 8040      		sbci r24,0
 477 0016 9040      		sbci r25,0
 478 0018 01F4      		brne 1b
 479 001a 00C0      		rjmp .
 480 001c 0000      		nop
 481               	.LVL46:
 482               	.L30:
 483               		.loc 3 187 2 is_stmt 0 view .LVU110
 484               	.LBE25:
 485               	.LBE24:
 947:tmk_core/common/action.c ****     } else {
 948:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 949:tmk_core/common/action.c ****     }
 950:tmk_core/common/action.c ****     unregister_code(code);
 486               		.loc 1 950 5 is_stmt 1 view .LVU111
 487 001e 8C2F      		mov r24,r28
 488               	/* epilogue start */
 951:tmk_core/common/action.c **** }
 489               		.loc 1 951 1 is_stmt 0 view .LVU112
 490 0020 CF91      		pop r28
 491               	.LVL47:
 950:tmk_core/common/action.c **** }
 492               		.loc 1 950 5 view .LVU113
 493 0022 0C94 0000 		jmp unregister_code
 494               	.LVL48:
 950:tmk_core/common/action.c **** }
 495               		.loc 1 950 5 view .LVU114
 496               		.cfi_endproc
 497               	.LFE25:
 499               		.section	.text.register_mods,"ax",@progbits
 500               	.global	register_mods
 502               	register_mods:
 503               	.LVL49:
 504               	.LFB26:
 952:tmk_core/common/action.c **** 
 953:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 954:tmk_core/common/action.c ****  *
 955:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 956:tmk_core/common/action.c ****  */
 957:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 505               		.loc 1 957 34 is_stmt 1 view -0
 506               		.cfi_startproc
 507               	/* prologue: function */
 508               	/* frame size = 0 */
 509               	/* stack size = 0 */
 510               	.L__stack_usage = 0
 958:tmk_core/common/action.c ****     if (mods) {
 511               		.loc 1 958 5 view .LVU116
 512               		.loc 1 958 8 is_stmt 0 view .LVU117
 513 0000 8823      		tst r24
 514 0002 01F0      		breq .L31
 959:tmk_core/common/action.c ****         add_mods(mods);
 515               		.loc 1 959 9 is_stmt 1 view .LVU118
 516 0004 0E94 0000 		call add_mods
 517               	.LVL50:
 960:tmk_core/common/action.c ****         send_keyboard_report();
 518               		.loc 1 960 9 view .LVU119
 519 0008 0C94 0000 		jmp send_keyboard_report
 520               	.LVL51:
 521               	.L31:
 522               	/* epilogue start */
 961:tmk_core/common/action.c ****     }
 962:tmk_core/common/action.c **** }
 523               		.loc 1 962 1 is_stmt 0 view .LVU120
 524 000c 0895      		ret
 525               		.cfi_endproc
 526               	.LFE26:
 528               		.section	.text.unregister_mods,"ax",@progbits
 529               	.global	unregister_mods
 531               	unregister_mods:
 532               	.LVL52:
 533               	.LFB27:
 963:tmk_core/common/action.c **** 
 964:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 965:tmk_core/common/action.c ****  *
 966:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 967:tmk_core/common/action.c ****  */
 968:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 534               		.loc 1 968 36 is_stmt 1 view -0
 535               		.cfi_startproc
 536               	/* prologue: function */
 537               	/* frame size = 0 */
 538               	/* stack size = 0 */
 539               	.L__stack_usage = 0
 969:tmk_core/common/action.c ****     if (mods) {
 540               		.loc 1 969 5 view .LVU122
 541               		.loc 1 969 8 is_stmt 0 view .LVU123
 542 0000 8823      		tst r24
 543 0002 01F0      		breq .L33
 970:tmk_core/common/action.c ****         del_mods(mods);
 544               		.loc 1 970 9 is_stmt 1 view .LVU124
 545 0004 0E94 0000 		call del_mods
 546               	.LVL53:
 971:tmk_core/common/action.c ****         send_keyboard_report();
 547               		.loc 1 971 9 view .LVU125
 548 0008 0C94 0000 		jmp send_keyboard_report
 549               	.LVL54:
 550               	.L33:
 551               	/* epilogue start */
 972:tmk_core/common/action.c ****     }
 973:tmk_core/common/action.c **** }
 552               		.loc 1 973 1 is_stmt 0 view .LVU126
 553 000c 0895      		ret
 554               		.cfi_endproc
 555               	.LFE27:
 557               		.section	.text.process_action,"ax",@progbits
 558               	.global	process_action
 560               	process_action:
 561               	.LVL55:
 562               	.LFB22:
 248:tmk_core/common/action.c ****     keyevent_t event = record->event;
 563               		.loc 1 248 59 is_stmt 1 view -0
 564               		.cfi_startproc
 248:tmk_core/common/action.c ****     keyevent_t event = record->event;
 565               		.loc 1 248 59 is_stmt 0 view .LVU128
 566 0000 BF92      		push r11
 567               	.LCFI6:
 568               		.cfi_def_cfa_offset 3
 569               		.cfi_offset 11, -2
 570 0002 CF92      		push r12
 571               	.LCFI7:
 572               		.cfi_def_cfa_offset 4
 573               		.cfi_offset 12, -3
 574 0004 DF92      		push r13
 575               	.LCFI8:
 576               		.cfi_def_cfa_offset 5
 577               		.cfi_offset 13, -4
 578 0006 EF92      		push r14
 579               	.LCFI9:
 580               		.cfi_def_cfa_offset 6
 581               		.cfi_offset 14, -5
 582 0008 FF92      		push r15
 583               	.LCFI10:
 584               		.cfi_def_cfa_offset 7
 585               		.cfi_offset 15, -6
 586 000a 0F93      		push r16
 587               	.LCFI11:
 588               		.cfi_def_cfa_offset 8
 589               		.cfi_offset 16, -7
 590 000c 1F93      		push r17
 591               	.LCFI12:
 592               		.cfi_def_cfa_offset 9
 593               		.cfi_offset 17, -8
 594 000e CF93      		push r28
 595               	.LCFI13:
 596               		.cfi_def_cfa_offset 10
 597               		.cfi_offset 28, -9
 598 0010 DF93      		push r29
 599               	.LCFI14:
 600               		.cfi_def_cfa_offset 11
 601               		.cfi_offset 29, -10
 602               	/* prologue: function */
 603               	/* frame size = 0 */
 604               	/* stack size = 9 */
 605               	.L__stack_usage = 9
 606 0012 6C01      		movw r12,r24
 607 0014 D62F      		mov r29,r22
 248:tmk_core/common/action.c ****     keyevent_t event = record->event;
 608               		.loc 1 248 59 view .LVU129
 609 0016 C72F      		mov r28,r23
 249:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 610               		.loc 1 249 5 is_stmt 1 view .LVU130
 611               	.LVL56:
 251:tmk_core/common/action.c **** #endif
 612               		.loc 1 251 5 view .LVU131
 251:tmk_core/common/action.c **** #endif
 613               		.loc 1 251 36 is_stmt 0 view .LVU132
 614 0018 FC01      		movw r30,r24
 615 001a 0581      		ldd r16,Z+5
 616 001c 0295      		swap r16
 617 001e 0F70      		andi r16,lo8(15)
 618               	.LVL57:
 254:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 619               		.loc 1 254 5 is_stmt 1 view .LVU133
 254:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 620               		.loc 1 254 14 is_stmt 0 view .LVU134
 621 0020 1281      		ldd r17,Z+2
 254:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 622               		.loc 1 254 8 view .LVU135
 623 0022 1111      		cpse r17,__zero_reg__
 256:tmk_core/common/action.c ****     }
 624               		.loc 1 256 9 is_stmt 1 view .LVU136
 625 0024 0E94 0000 		call clear_weak_mods
 626               	.LVL58:
 627               	.L36:
 260:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 628               		.loc 1 260 5 view .LVU137
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 629               		.loc 1 262 5 view .LVU138
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 630               		.loc 1 262 9 is_stmt 0 view .LVU139
 631 0028 0E94 0000 		call is_oneshot_layer_active
 632               	.LVL59:
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 633               		.loc 1 262 9 view .LVU140
 634 002c E82E      		mov r14,r24
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 635               		.loc 1 262 8 view .LVU141
 636 002e 8823      		tst r24
 637 0030 01F0      		breq .L37
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 638               		.loc 1 262 35 discriminator 1 view .LVU142
 639 0032 1123      		tst r17
 640 0034 01F0      		breq .L116
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 641               		.loc 1 262 71 discriminator 2 view .LVU143
 642 0036 8C2F      		mov r24,r28
 643 0038 807F      		andi r24,lo8(-16)
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 644               		.loc 1 262 52 discriminator 2 view .LVU144
 645 003a 8034      		cpi r24,lo8(64)
 646 003c 01F0      		breq .L38
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 647               		.loc 1 262 87 discriminator 3 view .LVU145
 648 003e 80E2      		ldi r24,lo8(32)
 649               	.LVL60:
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 650               		.loc 1 262 87 discriminator 3 view .LVU146
 651 0040 8D0F      		add r24,r29
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 652               		.loc 1 262 84 discriminator 3 view .LVU147
 653 0042 8830      		cpi r24,lo8(8)
 654 0044 00F0      		brlo .L116
 655               	.L38:
 267:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 656               		.loc 1 267 9 is_stmt 1 view .LVU148
 657 0046 82E0      		ldi r24,lo8(2)
 658 0048 0E94 0000 		call clear_oneshot_layer_state
 659               	.LVL61:
 268:tmk_core/common/action.c ****     }
 660               		.loc 1 268 9 view .LVU149
 268:tmk_core/common/action.c ****     }
 661               		.loc 1 268 31 is_stmt 0 view .LVU150
 662 004c 0E94 0000 		call is_oneshot_layer_active
 663               	.LVL62:
 268:tmk_core/common/action.c ****     }
 664               		.loc 1 268 9 view .LVU151
 665 0050 91E0      		ldi r25,lo8(1)
 666 0052 E82E      		mov r14,r24
 667 0054 E926      		eor r14,r25
 668               	.LVL63:
 669               	.L37:
 272:tmk_core/common/action.c ****         /* Key and Mods */
 670               		.loc 1 272 5 is_stmt 1 view .LVU152
 272:tmk_core/common/action.c ****         /* Key and Mods */
 671               		.loc 1 272 24 is_stmt 0 view .LVU153
 672 0056 BC2E      		mov r11,r28
 673 0058 B294      		swap r11
 674 005a 9FE0      		ldi r25,lo8(15)
 675 005c B922      		and r11,r25
 272:tmk_core/common/action.c ****         /* Key and Mods */
 676               		.loc 1 272 5 view .LVU154
 677 005e EB2D      		mov r30,r11
 678 0060 F0E0      		ldi r31,0
 679 0062 E050      		subi r30,lo8(-(gs(.L41)))
 680 0064 F040      		sbci r31,hi8(-(gs(.L41)))
 681 0066 0C94 0000 		jmp __tablejump2__
 682               		.section	.jumptables.gcc.process_action,"a",@progbits
 683               		.p2align	1
 684               	.L41:
 685 0000 0000      		.word gs(.L49)
 686 0002 0000      		.word gs(.L49)
 687 0004 0000      		.word gs(.L48)
 688 0006 0000      		.word gs(.L48)
 689 0008 0000      		.word gs(.L47)
 690 000a 0000      		.word gs(.L46)
 691 000c 0000      		.word gs(.L39)
 692 000e 0000      		.word gs(.L39)
 693 0010 0000      		.word gs(.L45)
 694 0012 0000      		.word gs(.L44)
 695 0014 0000      		.word gs(.L43)
 696 0016 0000      		.word gs(.L43)
 697 0018 0000      		.word gs(.L42)
 698 001a 0000      		.word gs(.L39)
 699 001c 0000      		.word gs(.L39)
 700 001e 0000      		.word gs(.L40)
 701               		.section	.text.process_action
 702               	.LVL64:
 703               	.L116:
 260:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 704               		.loc 1 260 10 view .LVU155
 705 006a E12C      		mov r14,__zero_reg__
 706 006c 00C0      		rjmp .L37
 707               	.LVL65:
 708               	.L49:
 709               	.LBB26:
 276:tmk_core/common/action.c ****             if (event.pressed) {
 710               		.loc 1 276 13 is_stmt 1 view .LVU156
 711 006e 0C2F      		mov r16,r28
 712               	.LVL66:
 276:tmk_core/common/action.c ****             if (event.pressed) {
 713               		.loc 1 276 13 is_stmt 0 view .LVU157
 714 0070 0F70      		andi r16,lo8(15)
 276:tmk_core/common/action.c ****             if (event.pressed) {
 715               		.loc 1 276 44 view .LVU158
 716 0072 C07F      		andi r28,lo8(-16)
 717               	.LVL67:
 276:tmk_core/common/action.c ****             if (event.pressed) {
 718               		.loc 1 276 21 view .LVU159
 719 0074 01F0      		breq .L50
 276:tmk_core/common/action.c ****             if (event.pressed) {
 720               		.loc 1 276 21 discriminator 2 view .LVU160
 721 0076 0295      		swap r16
 722 0078 007F      		andi r16,lo8(-16)
 723               	.L50:
 724               	.LVL68:
 277:tmk_core/common/action.c ****                 if (mods) {
 725               		.loc 1 277 13 is_stmt 1 discriminator 4 view .LVU161
 277:tmk_core/common/action.c ****                 if (mods) {
 726               		.loc 1 277 16 is_stmt 0 discriminator 4 view .LVU162
 727 007a 1123      		tst r17
 728 007c 01F0      		breq .L51
 278:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 729               		.loc 1 278 17 is_stmt 1 view .LVU163
 278:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 730               		.loc 1 278 20 is_stmt 0 view .LVU164
 731 007e 0023      		tst r16
 732 0080 01F0      		breq .L149
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 733               		.loc 1 279 21 is_stmt 1 view .LVU165
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 734               		.loc 1 279 25 is_stmt 0 view .LVU166
 735 0082 80E2      		ldi r24,lo8(32)
 736 0084 8D0F      		add r24,r29
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 737               		.loc 1 279 24 view .LVU167
 738 0086 8830      		cpi r24,lo8(8)
 739 0088 00F0      		brlo .L53
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 740               		.loc 1 279 49 discriminator 1 view .LVU168
 741 008a D111      		cpse r29,__zero_reg__
 742 008c 00C0      		rjmp .L54
 743               	.L53:
 283:tmk_core/common/action.c ****                     } else {
 744               		.loc 1 283 25 is_stmt 1 view .LVU169
 745 008e 802F      		mov r24,r16
 746 0090 0E94 0000 		call add_mods
 747               	.LVL69:
 748               	.L55:
 287:tmk_core/common/action.c ****                 }
 749               		.loc 1 287 21 view .LVU170
 750 0094 0E94 0000 		call send_keyboard_report
 751               	.LVL70:
 289:tmk_core/common/action.c ****             } else {
 752               		.loc 1 289 17 view .LVU171
 753               	.L149:
 289:tmk_core/common/action.c ****             } else {
 754               		.loc 1 289 17 is_stmt 0 view .LVU172
 755               	.LBE26:
 602:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 756               		.loc 1 602 75 is_stmt 1 view .LVU173
 603:tmk_core/common/action.c ****                         } else {
 757               		.loc 1 603 29 view .LVU174
 758 0098 8D2F      		mov r24,r29
 759 009a 0E94 0000 		call register_code
 760               	.LVL71:
 761 009e 00C0      		rjmp .L39
 762               	.LVL72:
 763               	.L54:
 764               	.LBB27:
 285:tmk_core/common/action.c ****                     }
 765               		.loc 1 285 25 view .LVU175
 766 00a0 802F      		mov r24,r16
 767 00a2 0E94 0000 		call add_weak_mods
 768               	.LVL73:
 769 00a6 00C0      		rjmp .L55
 770               	.L51:
 291:tmk_core/common/action.c ****                 if (mods) {
 771               		.loc 1 291 17 view .LVU176
 772 00a8 8D2F      		mov r24,r29
 773 00aa 0E94 0000 		call unregister_code
 774               	.LVL74:
 292:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 775               		.loc 1 292 17 view .LVU177
 292:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 776               		.loc 1 292 20 is_stmt 0 view .LVU178
 777 00ae 0023      		tst r16
 778 00b0 01F0      		breq .L39
 293:tmk_core/common/action.c ****                         del_mods(mods);
 779               		.loc 1 293 21 is_stmt 1 view .LVU179
 293:tmk_core/common/action.c ****                         del_mods(mods);
 780               		.loc 1 293 25 is_stmt 0 view .LVU180
 781 00b2 80E2      		ldi r24,lo8(32)
 782 00b4 8D0F      		add r24,r29
 293:tmk_core/common/action.c ****                         del_mods(mods);
 783               		.loc 1 293 24 view .LVU181
 784 00b6 8830      		cpi r24,lo8(8)
 785 00b8 00F0      		brlo .L57
 293:tmk_core/common/action.c ****                         del_mods(mods);
 786               		.loc 1 293 49 discriminator 1 view .LVU182
 787 00ba D111      		cpse r29,__zero_reg__
 788 00bc 00C0      		rjmp .L58
 789               	.L57:
 294:tmk_core/common/action.c ****                     } else {
 790               		.loc 1 294 25 is_stmt 1 view .LVU183
 791 00be 802F      		mov r24,r16
 792 00c0 0E94 0000 		call del_mods
 793               	.LVL75:
 794               	.L59:
 298:tmk_core/common/action.c ****                 }
 795               		.loc 1 298 21 view .LVU184
 796 00c4 0E94 0000 		call send_keyboard_report
 797               	.LVL76:
 798               	.L39:
 298:tmk_core/common/action.c ****                 }
 799               		.loc 1 298 21 is_stmt 0 view .LVU185
 800               	.LBE27:
 717:tmk_core/common/action.c ****         case ACT_LAYER:
 801               		.loc 1 717 5 is_stmt 1 view .LVU186
 802 00c8 2B2D      		mov r18,r11
 803 00ca 2850      		subi r18,8
 804 00cc 330B      		sbc r19,r19
 805 00ce 2430      		cpi r18,4
 806 00d0 3105      		cpc r19,__zero_reg__
 807 00d2 00F4      		brsh .L111
 724:tmk_core/common/action.c ****             break;
 808               		.loc 1 724 13 view .LVU187
 809 00d4 0E94 0000 		call host_keyboard_leds
 810               	.LVL77:
 811 00d8 0E94 0000 		call led_set
 812               	.LVL78:
 725:tmk_core/common/action.c ****         default:
 813               		.loc 1 725 13 view .LVU188
 814               	.L111:
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 815               		.loc 1 770 5 view .LVU189
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 816               		.loc 1 770 8 is_stmt 0 view .LVU190
 817 00dc EE20      		tst r14
 818 00de 01F4      		brne .+2
 819 00e0 00C0      		rjmp .L35
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 820               		.loc 1 770 33 discriminator 1 view .LVU191
 821 00e2 0E94 0000 		call get_oneshot_layer_state
 822               	.LVL79:
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 823               		.loc 1 770 28 discriminator 1 view .LVU192
 824 00e6 80FD      		sbrc r24,0
 825 00e8 00C0      		rjmp .L35
 771:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 826               		.loc 1 771 9 is_stmt 1 view .LVU193
 771:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 827               		.loc 1 771 31 is_stmt 0 view .LVU194
 828 00ea F601      		movw r30,r12
 829 00ec 1282      		std Z+2,__zero_reg__
 772:tmk_core/common/action.c ****         process_record(record);
 830               		.loc 1 772 9 is_stmt 1 view .LVU195
 831 00ee 0E94 0000 		call get_oneshot_layer
 832               	.LVL80:
 833 00f2 0E94 0000 		call layer_on
 834               	.LVL81:
 773:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 835               		.loc 1 773 9 view .LVU196
 836 00f6 C601      		movw r24,r12
 837 00f8 0E94 0000 		call process_record
 838               	.LVL82:
 774:tmk_core/common/action.c ****     }
 839               		.loc 1 774 9 view .LVU197
 840 00fc 0E94 0000 		call get_oneshot_layer
 841               	.LVL83:
 842               	/* epilogue start */
 777:tmk_core/common/action.c **** 
 843               		.loc 1 777 1 is_stmt 0 view .LVU198
 844 0100 DF91      		pop r29
 845               	.LVL84:
 777:tmk_core/common/action.c **** 
 846               		.loc 1 777 1 view .LVU199
 847 0102 CF91      		pop r28
 777:tmk_core/common/action.c **** 
 848               		.loc 1 777 1 view .LVU200
 849 0104 1F91      		pop r17
 850 0106 0F91      		pop r16
 851 0108 FF90      		pop r15
 852 010a EF90      		pop r14
 853               	.LVL85:
 777:tmk_core/common/action.c **** 
 854               		.loc 1 777 1 view .LVU201
 855 010c DF90      		pop r13
 856 010e CF90      		pop r12
 857               	.LVL86:
 777:tmk_core/common/action.c **** 
 858               		.loc 1 777 1 view .LVU202
 859 0110 BF90      		pop r11
 774:tmk_core/common/action.c ****     }
 860               		.loc 1 774 9 view .LVU203
 861 0112 0C94 0000 		jmp layer_off
 862               	.LVL87:
 863               	.L58:
 864               	.LBB28:
 296:tmk_core/common/action.c ****                     }
 865               		.loc 1 296 25 is_stmt 1 view .LVU204
 866 0116 802F      		mov r24,r16
 867 0118 0E94 0000 		call del_weak_mods
 868               	.LVL88:
 869 011c 00C0      		rjmp .L59
 870               	.LVL89:
 871               	.L48:
 296:tmk_core/common/action.c ****                     }
 872               		.loc 1 296 25 is_stmt 0 view .LVU205
 873               	.LBE28:
 874               	.LBB29:
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 875               		.loc 1 305 13 is_stmt 1 view .LVU206
 876 011e FC2F      		mov r31,r28
 877 0120 FF70      		andi r31,lo8(15)
 878 0122 FF2E      		mov r15,r31
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 879               		.loc 1 305 44 is_stmt 0 view .LVU207
 880 0124 C07F      		andi r28,lo8(-16)
 881               	.LVL90:
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 882               		.loc 1 305 21 view .LVU208
 883 0126 C032      		cpi r28,lo8(32)
 884 0128 01F0      		breq .L60
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 885               		.loc 1 305 21 discriminator 2 view .LVU209
 886 012a F294      		swap r15
 887 012c 80EF      		ldi r24,lo8(-16)
 888 012e F822      		and r15,r24
 889               	.L60:
 890               	.LVL91:
 306:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 891               		.loc 1 306 13 is_stmt 1 discriminator 4 view .LVU210
 892 0130 DD23      		tst r29
 893 0132 01F0      		breq .L61
 894 0134 D130      		cpi r29,lo8(1)
 895 0136 01F0      		breq .L62
 361:tmk_core/common/action.c ****                         if (tap_count > 0) {
 896               		.loc 1 361 21 view .LVU211
 361:tmk_core/common/action.c ****                         if (tap_count > 0) {
 897               		.loc 1 361 24 is_stmt 0 view .LVU212
 898 0138 1123      		tst r17
 899 013a 01F0      		breq .L70
 362:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 900               		.loc 1 362 25 is_stmt 1 view .LVU213
 362:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 901               		.loc 1 362 28 is_stmt 0 view .LVU214
 902 013c 0023      		tst r16
 903 013e 01F0      		breq .L71
 364:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 904               		.loc 1 364 29 is_stmt 1 view .LVU215
 368:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 905               		.loc 1 368 33 is_stmt 0 view .LVU216
 906 0140 F601      		movw r30,r12
 907 0142 8581      		ldd r24,Z+5
 364:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 908               		.loc 1 364 32 view .LVU217
 909 0144 80FF      		sbrs r24,0
 910 0146 00C0      		rjmp .L149
 369:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 911               		.loc 1 369 76 is_stmt 1 view .LVU218
 371:tmk_core/common/action.c ****                                 register_mods(mods);
 912               		.loc 1 371 33 view .LVU219
 371:tmk_core/common/action.c ****                                 register_mods(mods);
 913               		.loc 1 371 51 is_stmt 0 view .LVU220
 914 0148 8F70      		andi r24,lo8(15)
 915 014a 8583      		std Z+5,r24
 372:tmk_core/common/action.c ****                             } else
 916               		.loc 1 372 33 is_stmt 1 view .LVU221
 917 014c 00C0      		rjmp .L71
 918               	.L61:
 310:tmk_core/common/action.c ****                         if (tap_count == 0) {
 919               		.loc 1 310 21 view .LVU222
 310:tmk_core/common/action.c ****                         if (tap_count == 0) {
 920               		.loc 1 310 24 is_stmt 0 view .LVU223
 921 014e 1123      		tst r17
 922 0150 01F0      		breq .L64
 311:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 923               		.loc 1 311 25 is_stmt 1 view .LVU224
 311:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 924               		.loc 1 311 28 is_stmt 0 view .LVU225
 925 0152 0111      		cpse r16,__zero_reg__
 926 0154 00C0      		rjmp .L65
 927               	.L66:
 325:tmk_core/common/action.c ****                         }
 928               		.loc 1 325 29 is_stmt 1 view .LVU226
 325:tmk_core/common/action.c ****                         }
 929               		.loc 1 325 50 is_stmt 0 view .LVU227
 930 0156 0E94 0000 		call get_oneshot_mods
 931               	.LVL92:
 325:tmk_core/common/action.c ****                         }
 932               		.loc 1 325 29 view .LVU228
 933 015a 8F29      		or r24,r15
 934               	.LVL93:
 935               	.L148:
 325:tmk_core/common/action.c ****                         }
 936               		.loc 1 325 29 view .LVU229
 937               	.LBE29:
 529:tmk_core/common/action.c ****             } else {
 938               		.loc 1 529 17 view .LVU230
 939 015c 0E94 0000 		call register_mods
 940               	.LVL94:
 941 0160 00C0      		rjmp .L39
 942               	.LVL95:
 943               	.L65:
 944               	.LBB32:
 314:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 945               		.loc 1 314 32 is_stmt 1 view .LVU231
 314:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 946               		.loc 1 314 35 is_stmt 0 view .LVU232
 947 0162 0130      		cpi r16,lo8(1)
 948 0164 01F4      		brne .L66
 315:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 949               		.loc 1 315 65 is_stmt 1 view .LVU233
 316:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 950               		.loc 1 316 29 view .LVU234
 316:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 951               		.loc 1 316 53 is_stmt 0 view .LVU235
 952 0166 0E94 0000 		call get_oneshot_mods
 953               	.LVL96:
 316:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 954               		.loc 1 316 29 view .LVU236
 955 016a 8F29      		or r24,r15
 956 016c 0E94 0000 		call set_oneshot_mods
 957               	.LVL97:
 958 0170 00C0      		rjmp .L39
 959               	.L64:
 328:tmk_core/common/action.c ****                             clear_oneshot_mods();
 960               		.loc 1 328 25 is_stmt 1 view .LVU237
 328:tmk_core/common/action.c ****                             clear_oneshot_mods();
 961               		.loc 1 328 28 is_stmt 0 view .LVU238
 962 0172 0111      		cpse r16,__zero_reg__
 963 0174 00C0      		rjmp .L67
 964               	.L151:
 343:tmk_core/common/action.c ****                             unregister_mods(mods);
 965               		.loc 1 343 29 is_stmt 1 view .LVU239
 966 0176 0E94 0000 		call clear_oneshot_mods
 967               	.LVL98:
 344:tmk_core/common/action.c ****                         }
 968               		.loc 1 344 29 view .LVU240
 969               	.L73:
 393:tmk_core/common/action.c ****                             unregister_mods(mods);
 970               		.loc 1 393 67 view .LVU241
 394:tmk_core/common/action.c ****                         }
 971               		.loc 1 394 29 view .LVU242
 972 017a 8F2D      		mov r24,r15
 973 017c 0E94 0000 		call unregister_mods
 974               	.LVL99:
 975 0180 00C0      		rjmp .L39
 976               	.L67:
 331:tmk_core/common/action.c ****                             // Retain Oneshot mods
 977               		.loc 1 331 32 view .LVU243
 331:tmk_core/common/action.c ****                             // Retain Oneshot mods
 978               		.loc 1 331 35 is_stmt 0 view .LVU244
 979 0182 0130      		cpi r16,lo8(1)
 980 0184 01F4      		brne .+2
 981 0186 00C0      		rjmp .L39
 982 0188 00C0      		rjmp .L151
 983               	.L62:
 350:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 984               		.loc 1 350 21 is_stmt 1 view .LVU245
 350:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 985               		.loc 1 350 24 is_stmt 0 view .LVU246
 986 018a 1123      		tst r17
 987 018c 01F0      		breq .L69
 351:tmk_core/common/action.c ****                             register_mods(mods);
 988               		.loc 1 351 25 is_stmt 1 view .LVU247
 351:tmk_core/common/action.c ****                             register_mods(mods);
 989               		.loc 1 351 28 is_stmt 0 view .LVU248
 990 018e 0630      		cpi r16,lo8(6)
 991 0190 00F0      		brlo .+2
 992 0192 00C0      		rjmp .L39
 993               	.L71:
 380:tmk_core/common/action.c ****                             register_mods(mods);
 994               		.loc 1 380 67 is_stmt 1 view .LVU249
 381:tmk_core/common/action.c ****                         }
 995               		.loc 1 381 29 view .LVU250
 996 0194 8F2D      		mov r24,r15
 997 0196 00C0      		rjmp .L148
 998               	.L69:
 355:tmk_core/common/action.c ****                             unregister_mods(mods);
 999               		.loc 1 355 25 view .LVU251
 355:tmk_core/common/action.c ****                             unregister_mods(mods);
 1000               		.loc 1 355 28 is_stmt 0 view .LVU252
 1001 0198 0530      		cpi r16,lo8(5)
 1002 019a 00F0      		brlo .+2
 1003 019c 00C0      		rjmp .L39
 1004 019e 00C0      		rjmp .L73
 1005               	.L70:
 384:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1006               		.loc 1 384 25 is_stmt 1 view .LVU253
 384:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1007               		.loc 1 384 28 is_stmt 0 view .LVU254
 1008 01a0 0023      		tst r16
 1009 01a2 01F0      		breq .L73
 385:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1010               		.loc 1 385 71 is_stmt 1 view .LVU255
 386:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1011               		.loc 1 386 29 view .LVU256
 386:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1012               		.loc 1 386 32 is_stmt 0 view .LVU257
 1013 01a4 D933      		cpi r29,lo8(57)
 1014 01a6 01F4      		brne .L110
 387:tmk_core/common/action.c ****                             } else {
 1015               		.loc 1 387 33 is_stmt 1 view .LVU258
 1016               	.LVL100:
 1017               	.LBB30:
 1018               	.LBI30:
 166:/usr/avr/include/util/delay.h **** {
 1019               		.loc 3 166 1 view .LVU259
 1020               	.LBB31:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1021               		.loc 3 168 2 view .LVU260
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1022               		.loc 3 172 2 view .LVU261
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1023               		.loc 3 173 2 view .LVU262
 174:/usr/avr/include/util/delay.h **** 
 1024               		.loc 3 174 2 view .LVU263
 184:/usr/avr/include/util/delay.h **** 	#endif
 1025               		.loc 3 184 3 view .LVU264
 1026               		.loc 3 187 2 view .LVU265
 1027 01a8 FFEF      		ldi r31,lo8(255999)
 1028 01aa 27EE      		ldi r18,hi8(255999)
 1029 01ac 33E0      		ldi r19,hlo8(255999)
 1030 01ae F150      	1:	subi r31,1
 1031 01b0 2040      		sbci r18,0
 1032 01b2 3040      		sbci r19,0
 1033 01b4 01F4      		brne 1b
 1034               	.LVL101:
 1035               	.L152:
 1036               		.loc 3 187 2 is_stmt 0 view .LVU266
 1037               	.LBE31:
 1038               	.LBE30:
 1039               	.LBE32:
 1040               	.LBB33:
 1041               	.LBB34:
 1042 01b6 00C0      		rjmp .
 1043 01b8 0000      		nop
 1044               	.L110:
 1045               	.LBE34:
 1046               	.LBE33:
 616:tmk_core/common/action.c ****                         } else {
 1047               		.loc 1 616 29 is_stmt 1 view .LVU267
 1048 01ba 8D2F      		mov r24,r29
 1049 01bc 0E94 0000 		call unregister_code
 1050               	.LVL102:
 1051 01c0 00C0      		rjmp .L39
 1052               	.L47:
 404:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1053               		.loc 1 404 13 view .LVU268
 404:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1054               		.loc 1 404 33 is_stmt 0 view .LVU269
 1055 01c2 8C2F      		mov r24,r28
 1056 01c4 8695      		lsr r24
 1057 01c6 8695      		lsr r24
 1058 01c8 8370      		andi r24,lo8(3)
 1059 01ca 01F0      		breq .L76
 1060 01cc 8130      		cpi r24,lo8(1)
 1061 01ce 01F0      		breq .+2
 1062 01d0 00C0      		rjmp .L39
 413:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1063               		.loc 1 413 21 is_stmt 1 view .LVU270
 414:tmk_core/common/action.c ****                     } else {
 1064               		.loc 1 414 25 is_stmt 0 view .LVU271
 1065 01d2 8D2F      		mov r24,r29
 1066 01d4 9C2F      		mov r25,r28
 1067 01d6 9370      		andi r25,lo8(3)
 413:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1068               		.loc 1 413 24 view .LVU272
 1069 01d8 1111      		cpse r17,__zero_reg__
 1070 01da 00C0      		rjmp .L150
 416:tmk_core/common/action.c ****                     }
 1071               		.loc 1 416 25 is_stmt 1 view .LVU273
 1072 01dc 90E0      		ldi r25,0
 1073 01de 80E0      		ldi r24,0
 1074               	.L150:
 1075 01e0 0E94 0000 		call host_consumer_send
 1076               	.LVL103:
 1077 01e4 00C0      		rjmp .L39
 1078               	.L76:
 406:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1079               		.loc 1 406 21 view .LVU274
 407:tmk_core/common/action.c ****                     } else {
 1080               		.loc 1 407 25 is_stmt 0 view .LVU275
 1081 01e6 8D2F      		mov r24,r29
 1082 01e8 9C2F      		mov r25,r28
 1083 01ea 9370      		andi r25,lo8(3)
 406:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1084               		.loc 1 406 24 view .LVU276
 1085 01ec 1111      		cpse r17,__zero_reg__
 1086 01ee 00C0      		rjmp .L145
 409:tmk_core/common/action.c ****                     }
 1087               		.loc 1 409 25 is_stmt 1 view .LVU277
 1088 01f0 90E0      		ldi r25,0
 1089 01f2 80E0      		ldi r24,0
 1090               	.L145:
 1091 01f4 0E94 0000 		call host_system_send
 1092               	.LVL104:
 1093 01f8 00C0      		rjmp .L39
 1094               	.L46:
 425:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1095               		.loc 1 425 13 view .LVU278
 426:tmk_core/common/action.c ****                 switch (action.key.code) {
 1096               		.loc 1 426 17 is_stmt 0 view .LVU279
 1097 01fa 8D2F      		mov r24,r29
 425:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1098               		.loc 1 425 16 view .LVU280
 1099 01fc 1123      		tst r17
 1100 01fe 01F0      		breq .L80
 426:tmk_core/common/action.c ****                 switch (action.key.code) {
 1101               		.loc 1 426 17 is_stmt 1 view .LVU281
 1102 0200 0E94 0000 		call mousekey_on
 1103               	.LVL105:
 427:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 1104               		.loc 1 427 17 view .LVU282
 448:tmk_core/common/action.c ****                         break;
 1105               		.loc 1 448 25 view .LVU283
 1106               	.L146:
 453:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 1107               		.loc 1 453 17 view .LVU284
 474:tmk_core/common/action.c ****                         break;
 1108               		.loc 1 474 25 view .LVU285
 1109 0204 0E94 0000 		call mousekey_send
 1110               	.LVL106:
 475:tmk_core/common/action.c ****                 }
 1111               		.loc 1 475 25 view .LVU286
 1112 0208 00C0      		rjmp .L39
 1113               	.L80:
 452:tmk_core/common/action.c ****                 switch (action.key.code) {
 1114               		.loc 1 452 17 view .LVU287
 1115 020a 0E94 0000 		call mousekey_off
 1116               	.LVL107:
 1117 020e 00C0      		rjmp .L146
 1118               	.L45:
 482:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1119               		.loc 1 482 13 view .LVU288
 482:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1120               		.loc 1 482 39 is_stmt 0 view .LVU289
 1121 0210 8C2F      		mov r24,r28
 1122 0212 8370      		andi r24,lo8(3)
 482:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1123               		.loc 1 482 16 view .LVU290
 1124 0214 01F0      		breq .+2
 1125 0216 00C0      		rjmp .L81
 484:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1126               		.loc 1 484 17 is_stmt 1 view .LVU291
 484:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1127               		.loc 1 484 20 is_stmt 0 view .LVU292
 1128 0218 1111      		cpse r17,__zero_reg__
 1129 021a 00C0      		rjmp .L39
 1130               	.LBB36:
 485:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1131               		.loc 1 485 21 is_stmt 1 view .LVU293
 1132               	.LVL108:
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1133               		.loc 1 486 21 view .LVU294
 485:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1134               		.loc 1 485 61 is_stmt 0 view .LVU295
 1135 021c 4D2F      		mov r20,r29
 1136 021e 4295      		swap r20
 1137 0220 4695      		lsr r20
 1138 0222 4770      		andi r20,lo8(7)
 485:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1139               		.loc 1 485 35 view .LVU296
 1140 0224 440F      		lsl r20
 1141 0226 440F      		lsl r20
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1142               		.loc 1 486 77 view .LVU297
 1143 0228 0D2F      		mov r16,r29
 1144               	.LVL109:
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1145               		.loc 1 486 77 view .LVU298
 1146 022a 0F70      		andi r16,lo8(15)
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1147               		.loc 1 486 44 view .LVU299
 1148 022c 10E0      		ldi r17,0
 1149               	.LVL110:
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1150               		.loc 1 486 44 view .LVU300
 1151 022e 30E0      		ldi r19,0
 1152 0230 20E0      		ldi r18,0
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1153               		.loc 1 486 35 view .LVU301
 1154 0232 042E      		mov r0,r20
 1155 0234 00C0      		rjmp 2f
 1156               		1:
 1157 0236 000F      		lsl r16
 1158 0238 111F      		rol r17
 1159 023a 221F      		rol r18
 1160 023c 331F      		rol r19
 1161               		2:
 1162 023e 0A94      		dec r0
 1163 0240 02F4      		brpl 1b
 1164               	.LVL111:
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1165               		.loc 1 487 21 is_stmt 1 view .LVU302
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1166               		.loc 1 487 104 is_stmt 0 view .LVU303
 1167 0242 60E0      		ldi r22,0
 1168 0244 70E0      		ldi r23,0
 1169 0246 CB01      		movw r24,r22
 1170 0248 D4FF      		sbrs r29,4
 1171 024a 00C0      		rjmp .L82
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1172               		.loc 1 487 94 discriminator 1 view .LVU304
 1173 024c 6FE0      		ldi r22,lo8(15)
 1174 024e 70E0      		ldi r23,0
 1175 0250 80E0      		ldi r24,0
 1176 0252 90E0      		ldi r25,0
 1177 0254 00C0      		rjmp 2f
 1178               		1:
 1179 0256 660F      		lsl r22
 1180 0258 771F      		rol r23
 1181 025a 881F      		rol r24
 1182 025c 991F      		rol r25
 1183               		2:
 1184 025e 4A95      		dec r20
 1185 0260 02F4      		brpl 1b
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1186               		.loc 1 487 104 discriminator 1 view .LVU305
 1187 0262 6095      		com r22
 1188 0264 7095      		com r23
 1189 0266 8095      		com r24
 1190 0268 9095      		com r25
 1191               	.L82:
 1192               	.LVL112:
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1193               		.loc 1 488 21 is_stmt 1 discriminator 4 view .LVU306
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1194               		.loc 1 488 47 is_stmt 0 discriminator 4 view .LVU307
 1195 026a C695      		lsr r28
 1196 026c C695      		lsr r28
 1197               	.LVL113:
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1198               		.loc 1 488 47 discriminator 4 view .LVU308
 1199 026e C370      		andi r28,lo8(3)
 1200 0270 602B      		or r22,r16
 1201               	.LVL114:
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1202               		.loc 1 488 47 discriminator 4 view .LVU309
 1203 0272 712B      		or r23,r17
 1204 0274 822B      		or r24,r18
 1205 0276 932B      		or r25,r19
 1206 0278 C230      		cpi r28,lo8(2)
 1207 027a 01F0      		breq .L83
 1208 027c 00F4      		brsh .L84
 1209 027e C130      		cpi r28,lo8(1)
 1210 0280 01F0      		breq .L85
 490:tmk_core/common/action.c ****                             break;
 1211               		.loc 1 490 29 is_stmt 1 view .LVU310
 1212 0282 0E94 0000 		call default_layer_and
 1213               	.LVL115:
 491:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1214               		.loc 1 491 29 view .LVU311
 1215 0286 00C0      		rjmp .L39
 1216               	.L85:
 493:tmk_core/common/action.c ****                             break;
 1217               		.loc 1 493 29 view .LVU312
 1218 0288 0E94 0000 		call default_layer_or
 1219               	.LVL116:
 494:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1220               		.loc 1 494 29 view .LVU313
 1221 028c 00C0      		rjmp .L39
 1222               	.L83:
 496:tmk_core/common/action.c ****                             break;
 1223               		.loc 1 496 29 view .LVU314
 1224 028e 0E94 0000 		call default_layer_xor
 1225               	.LVL117:
 497:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1226               		.loc 1 497 29 view .LVU315
 1227 0292 00C0      		rjmp .L39
 1228               	.L84:
 499:tmk_core/common/action.c ****                             break;
 1229               		.loc 1 499 29 view .LVU316
 1230 0294 0E94 0000 		call default_layer_set
 1231               	.LVL118:
 500:tmk_core/common/action.c ****                     }
 1232               		.loc 1 500 29 view .LVU317
 1233 0298 00C0      		rjmp .L39
 1234               	.LVL119:
 1235               	.L81:
 500:tmk_core/common/action.c ****                     }
 1236               		.loc 1 500 29 is_stmt 0 view .LVU318
 1237               	.LBE36:
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1238               		.loc 1 505 17 is_stmt 1 view .LVU319
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1239               		.loc 1 505 21 is_stmt 0 view .LVU320
 1240 029a 8695      		lsr r24
 1241 029c 1123      		tst r17
 1242 029e 01F0      		breq .L87
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1243               		.loc 1 505 21 discriminator 1 view .LVU321
 1244 02a0 8C2F      		mov r24,r28
 1245 02a2 8170      		andi r24,lo8(1)
 1246               	.L87:
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1247               		.loc 1 505 20 discriminator 4 view .LVU322
 1248 02a4 8823      		tst r24
 1249 02a6 01F4      		brne .+2
 1250 02a8 00C0      		rjmp .L39
 1251               	.LBB37:
 506:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1252               		.loc 1 506 21 is_stmt 1 view .LVU323
 1253               	.LVL120:
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1254               		.loc 1 507 21 view .LVU324
 506:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1255               		.loc 1 506 61 is_stmt 0 view .LVU325
 1256 02aa 4D2F      		mov r20,r29
 1257 02ac 4295      		swap r20
 1258 02ae 4695      		lsr r20
 1259 02b0 4770      		andi r20,lo8(7)
 506:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1260               		.loc 1 506 35 view .LVU326
 1261 02b2 440F      		lsl r20
 1262 02b4 440F      		lsl r20
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1263               		.loc 1 507 77 view .LVU327
 1264 02b6 0D2F      		mov r16,r29
 1265               	.LVL121:
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1266               		.loc 1 507 77 view .LVU328
 1267 02b8 0F70      		andi r16,lo8(15)
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1268               		.loc 1 507 44 view .LVU329
 1269 02ba 10E0      		ldi r17,0
 1270               	.LVL122:
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1271               		.loc 1 507 44 view .LVU330
 1272 02bc 30E0      		ldi r19,0
 1273 02be 20E0      		ldi r18,0
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1274               		.loc 1 507 35 view .LVU331
 1275 02c0 042E      		mov r0,r20
 1276 02c2 00C0      		rjmp 2f
 1277               		1:
 1278 02c4 000F      		lsl r16
 1279 02c6 111F      		rol r17
 1280 02c8 221F      		rol r18
 1281 02ca 331F      		rol r19
 1282               		2:
 1283 02cc 0A94      		dec r0
 1284 02ce 02F4      		brpl 1b
 1285               	.LVL123:
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1286               		.loc 1 508 21 is_stmt 1 view .LVU332
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1287               		.loc 1 508 104 is_stmt 0 view .LVU333
 1288 02d0 60E0      		ldi r22,0
 1289 02d2 70E0      		ldi r23,0
 1290 02d4 CB01      		movw r24,r22
 1291 02d6 D4FF      		sbrs r29,4
 1292 02d8 00C0      		rjmp .L88
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1293               		.loc 1 508 94 discriminator 1 view .LVU334
 1294 02da 6FE0      		ldi r22,lo8(15)
 1295 02dc 70E0      		ldi r23,0
 1296 02de 80E0      		ldi r24,0
 1297 02e0 90E0      		ldi r25,0
 1298 02e2 00C0      		rjmp 2f
 1299               		1:
 1300 02e4 660F      		lsl r22
 1301 02e6 771F      		rol r23
 1302 02e8 881F      		rol r24
 1303 02ea 991F      		rol r25
 1304               		2:
 1305 02ec 4A95      		dec r20
 1306 02ee 02F4      		brpl 1b
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1307               		.loc 1 508 104 discriminator 1 view .LVU335
 1308 02f0 6095      		com r22
 1309 02f2 7095      		com r23
 1310 02f4 8095      		com r24
 1311 02f6 9095      		com r25
 1312               	.L88:
 1313               	.LVL124:
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1314               		.loc 1 509 21 is_stmt 1 discriminator 4 view .LVU336
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1315               		.loc 1 509 47 is_stmt 0 discriminator 4 view .LVU337
 1316 02f8 C695      		lsr r28
 1317 02fa C695      		lsr r28
 1318               	.LVL125:
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1319               		.loc 1 509 47 discriminator 4 view .LVU338
 1320 02fc C370      		andi r28,lo8(3)
 1321 02fe 602B      		or r22,r16
 1322               	.LVL126:
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1323               		.loc 1 509 47 discriminator 4 view .LVU339
 1324 0300 712B      		or r23,r17
 1325 0302 822B      		or r24,r18
 1326 0304 932B      		or r25,r19
 1327 0306 C230      		cpi r28,lo8(2)
 1328 0308 01F0      		breq .L89
 1329 030a 00F4      		brsh .L90
 1330 030c C130      		cpi r28,lo8(1)
 1331 030e 01F0      		breq .L91
 511:tmk_core/common/action.c ****                             break;
 1332               		.loc 1 511 29 is_stmt 1 view .LVU340
 1333 0310 0E94 0000 		call layer_and
 1334               	.LVL127:
 512:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1335               		.loc 1 512 29 view .LVU341
 1336 0314 00C0      		rjmp .L39
 1337               	.L91:
 514:tmk_core/common/action.c ****                             break;
 1338               		.loc 1 514 29 view .LVU342
 1339 0316 0E94 0000 		call layer_or
 1340               	.LVL128:
 515:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1341               		.loc 1 515 29 view .LVU343
 1342 031a 00C0      		rjmp .L39
 1343               	.L89:
 517:tmk_core/common/action.c ****                             break;
 1344               		.loc 1 517 29 view .LVU344
 1345 031c 0E94 0000 		call layer_xor
 1346               	.LVL129:
 518:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1347               		.loc 1 518 29 view .LVU345
 1348 0320 00C0      		rjmp .L39
 1349               	.L90:
 520:tmk_core/common/action.c ****                             break;
 1350               		.loc 1 520 29 view .LVU346
 1351 0322 0E94 0000 		call layer_state_set
 1352               	.LVL130:
 521:tmk_core/common/action.c ****                     }
 1353               		.loc 1 521 29 view .LVU347
 1354 0326 00C0      		rjmp .L39
 1355               	.LVL131:
 1356               	.L44:
 521:tmk_core/common/action.c ****                     }
 1357               		.loc 1 521 29 is_stmt 0 view .LVU348
 1358               	.LBE37:
 527:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1359               		.loc 1 527 13 is_stmt 1 view .LVU349
 1360 0328 CF70      		andi r28,lo8(15)
 1361               	.LVL132:
 527:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1362               		.loc 1 527 16 is_stmt 0 view .LVU350
 1363 032a 1123      		tst r17
 1364 032c 01F0      		breq .L92
 528:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1365               		.loc 1 528 17 is_stmt 1 view .LVU351
 1366 032e 8C2F      		mov r24,r28
 1367 0330 0E94 0000 		call layer_on
 1368               	.LVL133:
 529:tmk_core/common/action.c ****             } else {
 1369               		.loc 1 529 17 view .LVU352
 1370 0334 8D2F      		mov r24,r29
 1371 0336 00C0      		rjmp .L148
 1372               	.L92:
 531:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1373               		.loc 1 531 17 view .LVU353
 1374 0338 8D2F      		mov r24,r29
 1375 033a 0E94 0000 		call unregister_mods
 1376               	.LVL134:
 532:tmk_core/common/action.c ****             }
 1377               		.loc 1 532 17 view .LVU354
 1378 033e 8C2F      		mov r24,r28
 1379               	.LVL135:
 1380               	.L144:
 619:tmk_core/common/action.c ****                         }
 1381               		.loc 1 619 29 is_stmt 0 view .LVU355
 1382 0340 0E94 0000 		call layer_off
 1383               	.LVL136:
 1384 0344 00C0      		rjmp .L39
 1385               	.L43:
 538:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1386               		.loc 1 538 13 is_stmt 1 view .LVU356
 1387 0346 D23F      		cpi r29,lo8(-14)
 1388 0348 01F0      		breq .L93
 1389 034a 00F4      		brsh .L94
 1390 034c D03F      		cpi r29,lo8(-16)
 1391 034e 01F0      		breq .L95
 1392 0350 D13F      		cpi r29,lo8(-15)
 1393 0352 01F0      		breq .L96
 1394               	.L97:
 600:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1395               		.loc 1 600 21 view .LVU357
 600:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1396               		.loc 1 600 24 is_stmt 0 view .LVU358
 1397 0354 1123      		tst r17
 1398 0356 01F4      		brne .+2
 1399 0358 00C0      		rjmp .L106
 601:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1400               		.loc 1 601 25 is_stmt 1 view .LVU359
 601:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1401               		.loc 1 601 28 is_stmt 0 view .LVU360
 1402 035a 0111      		cpse r16,__zero_reg__
 1403 035c 00C0      		rjmp .L149
 605:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1404               		.loc 1 605 76 is_stmt 1 view .LVU361
 606:tmk_core/common/action.c ****                         }
 1405               		.loc 1 606 29 view .LVU362
 1406 035e 8C2F      		mov r24,r28
 1407 0360 8F71      		andi r24,lo8(31)
 1408 0362 00C0      		rjmp .L147
 1409               	.L94:
 1410 0364 D33F      		cpi r29,lo8(-13)
 1411 0366 01F0      		breq .L98
 1412 0368 D43F      		cpi r29,lo8(-12)
 1413 036a 01F4      		brne .L97
 586:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1414               		.loc 1 586 21 view .LVU363
 586:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1415               		.loc 1 586 24 is_stmt 0 view .LVU364
 1416 036c 1123      		tst r17
 1417 036e 01F0      		breq .L105
 587:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1418               		.loc 1 587 25 is_stmt 1 view .LVU365
 587:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1419               		.loc 1 587 50 is_stmt 0 view .LVU366
 1420 0370 CF71      		andi r28,lo8(31)
 1421               	.LVL137:
 587:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1422               		.loc 1 587 25 view .LVU367
 1423 0372 8C2F      		mov r24,r28
 1424 0374 0E94 0000 		call layer_on
 1425               	.LVL138:
 588:tmk_core/common/action.c ****                     } else {
 1426               		.loc 1 588 25 is_stmt 1 view .LVU368
 1427 0378 63E0      		ldi r22,lo8(3)
 1428 037a 8C2F      		mov r24,r28
 1429 037c 0E94 0000 		call set_oneshot_layer
 1430               	.LVL139:
 1431 0380 00C0      		rjmp .L39
 1432               	.LVL140:
 1433               	.L95:
 541:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1434               		.loc 1 541 21 view .LVU369
 541:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1435               		.loc 1 541 24 is_stmt 0 view .LVU370
 1436 0382 1123      		tst r17
 1437 0384 01F0      		breq .L100
 542:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1438               		.loc 1 542 25 is_stmt 1 view .LVU371
 542:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1439               		.loc 1 542 28 is_stmt 0 view .LVU372
 1440 0386 0530      		cpi r16,lo8(5)
 1441 0388 00F0      		brlo .+2
 1442 038a 00C0      		rjmp .L39
 1443               	.L101:
 543:tmk_core/common/action.c ****                         }
 1444               		.loc 1 543 29 is_stmt 1 view .LVU373
 1445 038c 8C2F      		mov r24,r28
 1446 038e 8F71      		andi r24,lo8(31)
 1447 0390 0E94 0000 		call layer_invert
 1448               	.LVL141:
 1449 0394 00C0      		rjmp .L39
 1450               	.L100:
 546:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1451               		.loc 1 546 25 view .LVU374
 546:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1452               		.loc 1 546 28 is_stmt 0 view .LVU375
 1453 0396 0630      		cpi r16,lo8(6)
 1454 0398 00F0      		brlo .+2
 1455 039a 00C0      		rjmp .L39
 1456 039c 00C0      		rjmp .L101
 1457               	.L96:
 552:tmk_core/common/action.c ****                     break;
 1458               		.loc 1 552 21 is_stmt 1 view .LVU376
 1459 039e 8C2F      		mov r24,r28
 1460 03a0 8F71      		andi r24,lo8(31)
 552:tmk_core/common/action.c ****                     break;
 1461               		.loc 1 552 68 is_stmt 0 view .LVU377
 1462 03a2 1123      		tst r17
 1463 03a4 01F0      		breq .L144
 1464               	.L147:
 606:tmk_core/common/action.c ****                         }
 1465               		.loc 1 606 29 view .LVU378
 1466 03a6 0E94 0000 		call layer_on
 1467               	.LVL142:
 1468 03aa 00C0      		rjmp .L39
 1469               	.L93:
 555:tmk_core/common/action.c ****                     break;
 1470               		.loc 1 555 21 is_stmt 1 view .LVU379
 1471 03ac 8C2F      		mov r24,r28
 1472 03ae 8F71      		andi r24,lo8(31)
 555:tmk_core/common/action.c ****                     break;
 1473               		.loc 1 555 69 is_stmt 0 view .LVU380
 1474 03b0 1123      		tst r17
 1475 03b2 01F0      		breq .L147
 1476 03b4 00C0      		rjmp .L144
 1477               	.L98:
 558:tmk_core/common/action.c ****                     break;
 1478               		.loc 1 558 21 is_stmt 1 view .LVU381
 558:tmk_core/common/action.c ****                     break;
 1479               		.loc 1 558 70 is_stmt 0 view .LVU382
 1480 03b6 1123      		tst r17
 1481 03b8 01F0      		breq .L104
 558:tmk_core/common/action.c ****                     break;
 1482               		.loc 1 558 37 discriminator 1 view .LVU383
 1483 03ba 8C2F      		mov r24,r28
 1484 03bc 8F71      		andi r24,lo8(31)
 1485 03be 0E94 0000 		call layer_move
 1486               	.LVL143:
 1487 03c2 00C0      		rjmp .L39
 1488               	.L104:
 558:tmk_core/common/action.c ****                     break;
 1489               		.loc 1 558 72 discriminator 2 view .LVU384
 1490 03c4 0E94 0000 		call layer_clear
 1491               	.LVL144:
 1492 03c8 00C0      		rjmp .L39
 1493               	.L105:
 590:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1494               		.loc 1 590 25 is_stmt 1 view .LVU385
 1495 03ca 81E0      		ldi r24,lo8(1)
 1496 03cc 0E94 0000 		call clear_oneshot_layer_state
 1497               	.LVL145:
 591:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1498               		.loc 1 591 25 view .LVU386
 591:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1499               		.loc 1 591 28 is_stmt 0 view .LVU387
 1500 03d0 0230      		cpi r16,lo8(2)
 1501 03d2 00F4      		brsh .+2
 1502 03d4 00C0      		rjmp .L39
 592:tmk_core/common/action.c ****                         }
 1503               		.loc 1 592 29 is_stmt 1 view .LVU388
 1504 03d6 82E0      		ldi r24,lo8(2)
 1505 03d8 0E94 0000 		call clear_oneshot_layer_state
 1506               	.LVL146:
 1507 03dc 00C0      		rjmp .L39
 1508               	.L106:
 609:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1509               		.loc 1 609 25 view .LVU389
 609:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1510               		.loc 1 609 28 is_stmt 0 view .LVU390
 1511 03de 0023      		tst r16
 1512 03e0 01F0      		breq .L108
 610:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1513               		.loc 1 610 77 is_stmt 1 view .LVU391
 611:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1514               		.loc 1 611 29 view .LVU392
 611:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1515               		.loc 1 611 32 is_stmt 0 view .LVU393
 1516 03e2 D933      		cpi r29,lo8(57)
 1517 03e4 01F0      		breq .+2
 1518 03e6 00C0      		rjmp .L110
 612:tmk_core/common/action.c ****                             } else {
 1519               		.loc 1 612 33 is_stmt 1 view .LVU394
 1520               	.LVL147:
 1521               	.LBB38:
 1522               	.LBI33:
 166:/usr/avr/include/util/delay.h **** {
 1523               		.loc 3 166 1 view .LVU395
 1524               	.LBB35:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1525               		.loc 3 168 2 view .LVU396
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1526               		.loc 3 172 2 view .LVU397
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1527               		.loc 3 173 2 view .LVU398
 174:/usr/avr/include/util/delay.h **** 
 1528               		.loc 3 174 2 view .LVU399
 184:/usr/avr/include/util/delay.h **** 	#endif
 1529               		.loc 3 184 3 view .LVU400
 1530               		.loc 3 187 2 view .LVU401
 1531 03e8 8FEF      		ldi r24,lo8(255999)
 1532 03ea 97EE      		ldi r25,hi8(255999)
 1533 03ec E3E0      		ldi r30,hlo8(255999)
 1534 03ee 8150      	1:	subi r24,1
 1535 03f0 9040      		sbci r25,0
 1536 03f2 E040      		sbci r30,0
 1537 03f4 01F4      		brne 1b
 1538 03f6 00C0      		rjmp .L152
 1539               	.LVL148:
 1540               	.L108:
 1541               		.loc 3 187 2 is_stmt 0 view .LVU402
 1542               	.LBE35:
 1543               	.LBE38:
 618:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1544               		.loc 1 618 79 is_stmt 1 view .LVU403
 619:tmk_core/common/action.c ****                         }
 1545               		.loc 1 619 29 view .LVU404
 1546 03f8 8C2F      		mov r24,r28
 1547 03fa 8F71      		andi r24,lo8(31)
 1548 03fc 00C0      		rjmp .L144
 1549               	.L42:
 630:tmk_core/common/action.c ****             break;
 1550               		.loc 1 630 13 view .LVU405
 630:tmk_core/common/action.c ****             break;
 1551               		.loc 1 630 83 is_stmt 0 view .LVU406
 1552 03fe 4C2F      		mov r20,r28
 1553 0400 4F70      		andi r20,lo8(15)
 630:tmk_core/common/action.c ****             break;
 1554               		.loc 1 630 13 view .LVU407
 1555 0402 6D2F      		mov r22,r29
 1556 0404 C601      		movw r24,r12
 1557 0406 0E94 0000 		call action_get_macro
 1558               	.LVL149:
 1559 040a 0E94 0000 		call action_macro_play
 1560               	.LVL150:
 631:tmk_core/common/action.c **** #endif
 1561               		.loc 1 631 13 is_stmt 1 view .LVU408
 1562 040e 00C0      		rjmp .L39
 1563               	.L40:
 708:tmk_core/common/action.c ****             break;
 1564               		.loc 1 708 13 view .LVU409
 708:tmk_core/common/action.c ****             break;
 1565               		.loc 1 708 64 is_stmt 0 view .LVU410
 1566 0410 4C2F      		mov r20,r28
 1567 0412 4F70      		andi r20,lo8(15)
 708:tmk_core/common/action.c ****             break;
 1568               		.loc 1 708 13 view .LVU411
 1569 0414 6D2F      		mov r22,r29
 1570 0416 C601      		movw r24,r12
 1571 0418 0E94 0000 		call action_function
 1572               	.LVL151:
 709:tmk_core/common/action.c **** #endif
 1573               		.loc 1 709 13 is_stmt 1 view .LVU412
 1574 041c 00C0      		rjmp .L39
 1575               	.LVL152:
 1576               	.L35:
 1577               	/* epilogue start */
 777:tmk_core/common/action.c **** 
 1578               		.loc 1 777 1 is_stmt 0 view .LVU413
 1579 041e DF91      		pop r29
 1580               	.LVL153:
 777:tmk_core/common/action.c **** 
 1581               		.loc 1 777 1 view .LVU414
 1582 0420 CF91      		pop r28
 777:tmk_core/common/action.c **** 
 1583               		.loc 1 777 1 view .LVU415
 1584 0422 1F91      		pop r17
 1585 0424 0F91      		pop r16
 1586 0426 FF90      		pop r15
 1587 0428 EF90      		pop r14
 1588               	.LVL154:
 777:tmk_core/common/action.c **** 
 1589               		.loc 1 777 1 view .LVU416
 1590 042a DF90      		pop r13
 1591 042c CF90      		pop r12
 1592               	.LVL155:
 777:tmk_core/common/action.c **** 
 1593               		.loc 1 777 1 view .LVU417
 1594 042e BF90      		pop r11
 1595 0430 0895      		ret
 1596               		.cfi_endproc
 1597               	.LFE22:
 1599               		.section	.text.process_record_handler,"ax",@progbits
 1600               	.global	process_record_handler
 1602               	process_record_handler:
 1603               	.LVL156:
 1604               	.LFB21:
 216:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1605               		.loc 1 216 50 is_stmt 1 view -0
 1606               		.cfi_startproc
 216:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1607               		.loc 1 216 50 is_stmt 0 view .LVU419
 1608 0000 0F93      		push r16
 1609               	.LCFI15:
 1610               		.cfi_def_cfa_offset 3
 1611               		.cfi_offset 16, -2
 1612 0002 1F93      		push r17
 1613               	.LCFI16:
 1614               		.cfi_def_cfa_offset 4
 1615               		.cfi_offset 17, -3
 1616 0004 CF93      		push r28
 1617               	.LCFI17:
 1618               		.cfi_def_cfa_offset 5
 1619               		.cfi_offset 28, -4
 1620 0006 DF93      		push r29
 1621               	.LCFI18:
 1622               		.cfi_def_cfa_offset 6
 1623               		.cfi_offset 29, -5
 1624               	/* prologue: function */
 1625               	/* frame size = 0 */
 1626               	/* stack size = 4 */
 1627               	.L__stack_usage = 4
 1628 0008 EC01      		movw r28,r24
 217:tmk_core/common/action.c ****     dprint("ACTION: ");
 1629               		.loc 1 217 5 is_stmt 1 view .LVU420
 217:tmk_core/common/action.c ****     dprint("ACTION: ");
 1630               		.loc 1 217 23 is_stmt 0 view .LVU421
 1631 000a 6881      		ld r22,Y
 1632 000c 7981      		ldd r23,Y+1
 1633 000e 8A81      		ldd r24,Y+2
 1634               	.LVL157:
 217:tmk_core/common/action.c ****     dprint("ACTION: ");
 1635               		.loc 1 217 23 view .LVU422
 1636 0010 0E94 0000 		call store_or_get_action
 1637               	.LVL158:
 1638 0014 8C01      		movw r16,r24
 1639               	.LVL159:
 218:tmk_core/common/action.c ****     debug_action(action);
 1640               		.loc 1 218 23 is_stmt 1 view .LVU423
 219:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1641               		.loc 1 219 5 view .LVU424
 221:tmk_core/common/action.c ****     layer_debug();
 1642               		.loc 1 221 29 view .LVU425
 222:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1643               		.loc 1 222 5 view .LVU426
 1644 0016 0E94 0000 		call layer_debug
 1645               	.LVL160:
 223:tmk_core/common/action.c ****     default_layer_debug();
 1646               		.loc 1 223 37 view .LVU427
 224:tmk_core/common/action.c **** #endif
 1647               		.loc 1 224 5 view .LVU428
 1648 001a 0E94 0000 		call default_layer_debug
 1649               	.LVL161:
 226:tmk_core/common/action.c **** 
 1650               		.loc 1 226 15 view .LVU429
 228:tmk_core/common/action.c **** }
 1651               		.loc 1 228 5 view .LVU430
 228:tmk_core/common/action.c **** }
 1652               		.loc 1 228 5 is_stmt 0 view .LVU431
 1653 001e B801      		movw r22,r16
 1654 0020 CE01      		movw r24,r28
 1655               	/* epilogue start */
 229:tmk_core/common/action.c **** 
 1656               		.loc 1 229 1 view .LVU432
 1657 0022 DF91      		pop r29
 1658 0024 CF91      		pop r28
 1659               	.LVL162:
 229:tmk_core/common/action.c **** 
 1660               		.loc 1 229 1 view .LVU433
 1661 0026 1F91      		pop r17
 1662 0028 0F91      		pop r16
 1663               	.LVL163:
 228:tmk_core/common/action.c **** }
 1664               		.loc 1 228 5 view .LVU434
 1665 002a 0C94 0000 		jmp process_action
 1666               	.LVL164:
 228:tmk_core/common/action.c **** }
 1667               		.loc 1 228 5 view .LVU435
 1668               		.cfi_endproc
 1669               	.LFE21:
 1671               		.section	.text.process_record,"ax",@progbits
 1672               	.global	process_record
 1674               	process_record:
 1675               	.LVL165:
 1676               	.LFB20:
 198:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1677               		.loc 1 198 42 is_stmt 1 view -0
 1678               		.cfi_startproc
 198:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1679               		.loc 1 198 42 is_stmt 0 view .LVU437
 1680 0000 CF93      		push r28
 1681               	.LCFI19:
 1682               		.cfi_def_cfa_offset 3
 1683               		.cfi_offset 28, -2
 1684 0002 DF93      		push r29
 1685               	.LCFI20:
 1686               		.cfi_def_cfa_offset 4
 1687               		.cfi_offset 29, -3
 1688               	/* prologue: function */
 1689               	/* frame size = 0 */
 1690               	/* stack size = 2 */
 1691               	.L__stack_usage = 2
 1692 0004 EC01      		movw r28,r24
 199:tmk_core/common/action.c ****         return;
 1693               		.loc 1 199 5 is_stmt 1 view .LVU438
 1694               	.LBB41:
 1695               	.LBI41:
 1696               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1697               		.loc 4 48 20 view .LVU439
 1698               	.LBB42:
 1699               		.loc 4 48 51 view .LVU440
 1700               		.loc 4 48 74 is_stmt 0 view .LVU441
 1701 0006 8B81      		ldd r24,Y+3
 1702 0008 9C81      		ldd r25,Y+4
 1703               	.LVL166:
 1704               		.loc 4 48 74 view .LVU442
 1705 000a 892B      		or r24,r25
 1706 000c 01F0      		breq .L154
 1707 000e 8881      		ld r24,Y
 1708 0010 9981      		ldd r25,Y+1
 1709 0012 8923      		and r24,r25
 1710 0014 8F3F      		cpi r24,lo8(-1)
 1711 0016 01F4      		brne .L170
 1712               	.L154:
 1713               	/* epilogue start */
 1714               	.LBE42:
 1715               	.LBE41:
 214:tmk_core/common/action.c **** 
 1716               		.loc 1 214 1 view .LVU443
 1717 0018 DF91      		pop r29
 1718 001a CF91      		pop r28
 1719               	.LVL167:
 214:tmk_core/common/action.c **** 
 1720               		.loc 1 214 1 view .LVU444
 1721 001c 0895      		ret
 1722               	.LVL168:
 1723               	.L159:
 212:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1724               		.loc 1 212 5 is_stmt 1 view .LVU445
 1725 001e CE01      		movw r24,r28
 1726 0020 0E94 0000 		call process_record_handler
 1727               	.LVL169:
 213:tmk_core/common/action.c **** }
 1728               		.loc 1 213 5 view .LVU446
 1729 0024 CE01      		movw r24,r28
 1730               	/* epilogue start */
 214:tmk_core/common/action.c **** 
 1731               		.loc 1 214 1 is_stmt 0 view .LVU447
 1732 0026 DF91      		pop r29
 1733 0028 CF91      		pop r28
 1734               	.LVL170:
 213:tmk_core/common/action.c **** }
 1735               		.loc 1 213 5 view .LVU448
 1736 002a 0C94 0000 		jmp post_process_record_quantum
 1737               	.LVL171:
 1738               	.L170:
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1739               		.loc 1 203 5 is_stmt 1 view .LVU449
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1740               		.loc 1 203 10 is_stmt 0 view .LVU450
 1741 002e CE01      		movw r24,r28
 1742 0030 0E94 0000 		call process_record_quantum
 1743               	.LVL172:
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1744               		.loc 1 203 8 view .LVU451
 1745 0034 8111      		cpse r24,__zero_reg__
 1746 0036 00C0      		rjmp .L159
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1747               		.loc 1 205 9 is_stmt 1 view .LVU452
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1748               		.loc 1 205 13 is_stmt 0 view .LVU453
 1749 0038 0E94 0000 		call is_oneshot_layer_active
 1750               	.LVL173:
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1751               		.loc 1 205 12 view .LVU454
 1752 003c 8823      		tst r24
 1753 003e 01F0      		breq .L154
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1754               		.loc 1 205 39 discriminator 1 view .LVU455
 1755 0040 8A81      		ldd r24,Y+2
 1756 0042 8823      		tst r24
 1757 0044 01F0      		breq .L154
 206:tmk_core/common/action.c ****         }
 1758               		.loc 1 206 13 is_stmt 1 view .LVU456
 1759 0046 82E0      		ldi r24,lo8(2)
 1760               	/* epilogue start */
 214:tmk_core/common/action.c **** 
 1761               		.loc 1 214 1 is_stmt 0 view .LVU457
 1762 0048 DF91      		pop r29
 1763 004a CF91      		pop r28
 1764               	.LVL174:
 206:tmk_core/common/action.c ****         }
 1765               		.loc 1 206 13 view .LVU458
 1766 004c 0C94 0000 		jmp clear_oneshot_layer_state
 1767               	.LVL175:
 1768               		.cfi_endproc
 1769               	.LFE20:
 1771               		.section	.text.process_record_nocache,"ax",@progbits
 1772               	.global	process_record_nocache
 1774               	process_record_nocache:
 1775               	.LVL176:
 1776               	.LFB16:
 156:tmk_core/common/action.c ****     disable_action_cache = true;
 1777               		.loc 1 156 50 is_stmt 1 view -0
 1778               		.cfi_startproc
 1779               	/* prologue: function */
 1780               	/* frame size = 0 */
 1781               	/* stack size = 0 */
 1782               	.L__stack_usage = 0
 157:tmk_core/common/action.c ****     process_record(record);
 1783               		.loc 1 157 5 view .LVU460
 157:tmk_core/common/action.c ****     process_record(record);
 1784               		.loc 1 157 26 is_stmt 0 view .LVU461
 1785 0000 21E0      		ldi r18,lo8(1)
 1786 0002 2093 0000 		sts disable_action_cache,r18
 158:tmk_core/common/action.c ****     disable_action_cache = false;
 1787               		.loc 1 158 5 is_stmt 1 view .LVU462
 1788 0006 0E94 0000 		call process_record
 1789               	.LVL177:
 159:tmk_core/common/action.c **** }
 1790               		.loc 1 159 5 view .LVU463
 159:tmk_core/common/action.c **** }
 1791               		.loc 1 159 26 is_stmt 0 view .LVU464
 1792 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1793               	/* epilogue start */
 160:tmk_core/common/action.c **** #else
 1794               		.loc 1 160 1 view .LVU465
 1795 000e 0895      		ret
 1796               		.cfi_endproc
 1797               	.LFE16:
 1799               		.section	.text.register_weak_mods,"ax",@progbits
 1800               	.global	register_weak_mods
 1802               	register_weak_mods:
 1803               	.LVL178:
 1804               	.LFB28:
 974:tmk_core/common/action.c **** 
 975:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 976:tmk_core/common/action.c ****  *
 977:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 978:tmk_core/common/action.c ****  */
 979:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1805               		.loc 1 979 39 is_stmt 1 view -0
 1806               		.cfi_startproc
 1807               	/* prologue: function */
 1808               	/* frame size = 0 */
 1809               	/* stack size = 0 */
 1810               	.L__stack_usage = 0
 980:tmk_core/common/action.c ****     if (mods) {
 1811               		.loc 1 980 5 view .LVU467
 1812               		.loc 1 980 8 is_stmt 0 view .LVU468
 1813 0000 8823      		tst r24
 1814 0002 01F0      		breq .L173
 981:tmk_core/common/action.c ****         add_weak_mods(mods);
 1815               		.loc 1 981 9 is_stmt 1 view .LVU469
 1816 0004 0E94 0000 		call add_weak_mods
 1817               	.LVL179:
 982:tmk_core/common/action.c ****         send_keyboard_report();
 1818               		.loc 1 982 9 view .LVU470
 1819 0008 0C94 0000 		jmp send_keyboard_report
 1820               	.LVL180:
 1821               	.L173:
 1822               	/* epilogue start */
 983:tmk_core/common/action.c ****     }
 984:tmk_core/common/action.c **** }
 1823               		.loc 1 984 1 is_stmt 0 view .LVU471
 1824 000c 0895      		ret
 1825               		.cfi_endproc
 1826               	.LFE28:
 1828               		.section	.text.unregister_weak_mods,"ax",@progbits
 1829               	.global	unregister_weak_mods
 1831               	unregister_weak_mods:
 1832               	.LVL181:
 1833               	.LFB29:
 985:tmk_core/common/action.c **** 
 986:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 987:tmk_core/common/action.c ****  *
 988:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 989:tmk_core/common/action.c ****  */
 990:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1834               		.loc 1 990 41 is_stmt 1 view -0
 1835               		.cfi_startproc
 1836               	/* prologue: function */
 1837               	/* frame size = 0 */
 1838               	/* stack size = 0 */
 1839               	.L__stack_usage = 0
 991:tmk_core/common/action.c ****     if (mods) {
 1840               		.loc 1 991 5 view .LVU473
 1841               		.loc 1 991 8 is_stmt 0 view .LVU474
 1842 0000 8823      		tst r24
 1843 0002 01F0      		breq .L175
 992:tmk_core/common/action.c ****         del_weak_mods(mods);
 1844               		.loc 1 992 9 is_stmt 1 view .LVU475
 1845 0004 0E94 0000 		call del_weak_mods
 1846               	.LVL182:
 993:tmk_core/common/action.c ****         send_keyboard_report();
 1847               		.loc 1 993 9 view .LVU476
 1848 0008 0C94 0000 		jmp send_keyboard_report
 1849               	.LVL183:
 1850               	.L175:
 1851               	/* epilogue start */
 994:tmk_core/common/action.c ****     }
 995:tmk_core/common/action.c **** }
 1852               		.loc 1 995 1 is_stmt 0 view .LVU477
 1853 000c 0895      		ret
 1854               		.cfi_endproc
 1855               	.LFE29:
 1857               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1858               	.global	clear_keyboard_but_mods_and_keys
 1860               	clear_keyboard_but_mods_and_keys:
 1861               	.LFB32:
 996:tmk_core/common/action.c **** 
 997:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 998:tmk_core/common/action.c ****  *
 999:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1000:tmk_core/common/action.c ****  */
1001:tmk_core/common/action.c **** void clear_keyboard(void) {
1002:tmk_core/common/action.c ****     clear_mods();
1003:tmk_core/common/action.c ****     clear_keyboard_but_mods();
1004:tmk_core/common/action.c **** }
1005:tmk_core/common/action.c **** 
1006:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1007:tmk_core/common/action.c ****  *
1008:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1009:tmk_core/common/action.c ****  */
1010:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
1011:tmk_core/common/action.c ****     clear_keys();
1012:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
1013:tmk_core/common/action.c **** }
1014:tmk_core/common/action.c **** 
1015:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1016:tmk_core/common/action.c ****  *
1017:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1018:tmk_core/common/action.c ****  */
1019:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1862               		.loc 1 1019 41 is_stmt 1 view -0
 1863               		.cfi_startproc
 1864               	/* prologue: function */
 1865               	/* frame size = 0 */
 1866               	/* stack size = 0 */
 1867               	.L__stack_usage = 0
1020:tmk_core/common/action.c ****     clear_weak_mods();
 1868               		.loc 1 1020 5 view .LVU479
 1869 0000 0E94 0000 		call clear_weak_mods
 1870               	.LVL184:
1021:tmk_core/common/action.c ****     clear_macro_mods();
 1871               		.loc 1 1021 5 view .LVU480
 1872 0004 0E94 0000 		call clear_macro_mods
 1873               	.LVL185:
1022:tmk_core/common/action.c ****     send_keyboard_report();
 1874               		.loc 1 1022 5 view .LVU481
 1875 0008 0E94 0000 		call send_keyboard_report
 1876               	.LVL186:
1023:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
1024:tmk_core/common/action.c ****     mousekey_clear();
 1877               		.loc 1 1024 5 view .LVU482
 1878 000c 0E94 0000 		call mousekey_clear
 1879               	.LVL187:
1025:tmk_core/common/action.c ****     mousekey_send();
 1880               		.loc 1 1025 5 view .LVU483
 1881 0010 0E94 0000 		call mousekey_send
 1882               	.LVL188:
1026:tmk_core/common/action.c **** #endif
1027:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
1028:tmk_core/common/action.c ****     host_system_send(0);
 1883               		.loc 1 1028 5 view .LVU484
 1884 0014 90E0      		ldi r25,0
 1885 0016 80E0      		ldi r24,0
 1886 0018 0E94 0000 		call host_system_send
 1887               	.LVL189:
1029:tmk_core/common/action.c ****     host_consumer_send(0);
 1888               		.loc 1 1029 5 view .LVU485
 1889 001c 90E0      		ldi r25,0
 1890 001e 80E0      		ldi r24,0
 1891 0020 0C94 0000 		jmp host_consumer_send
 1892               	.LVL190:
 1893               		.cfi_endproc
 1894               	.LFE32:
 1896               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1897               	.global	clear_keyboard_but_mods
 1899               	clear_keyboard_but_mods:
 1900               	.LFB31:
1010:tmk_core/common/action.c ****     clear_keys();
 1901               		.loc 1 1010 36 view -0
 1902               		.cfi_startproc
 1903               	/* prologue: function */
 1904               	/* frame size = 0 */
 1905               	/* stack size = 0 */
 1906               	.L__stack_usage = 0
1011:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1907               		.loc 1 1011 5 view .LVU487
 1908 0000 0E94 0000 		call clear_keys
 1909               	.LVL191:
1012:tmk_core/common/action.c **** }
 1910               		.loc 1 1012 5 view .LVU488
 1911 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1912               	.LVL192:
 1913               		.cfi_endproc
 1914               	.LFE31:
 1916               		.section	.text.clear_keyboard,"ax",@progbits
 1917               	.global	clear_keyboard
 1919               	clear_keyboard:
 1920               	.LFB30:
1001:tmk_core/common/action.c ****     clear_mods();
 1921               		.loc 1 1001 27 view -0
 1922               		.cfi_startproc
 1923               	/* prologue: function */
 1924               	/* frame size = 0 */
 1925               	/* stack size = 0 */
 1926               	.L__stack_usage = 0
1002:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1927               		.loc 1 1002 5 view .LVU490
 1928 0000 0E94 0000 		call clear_mods
 1929               	.LVL193:
1003:tmk_core/common/action.c **** }
 1930               		.loc 1 1003 5 view .LVU491
 1931 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1932               	.LVL194:
 1933               		.cfi_endproc
 1934               	.LFE30:
 1936               		.section	.text.is_tap_action,"ax",@progbits
 1937               	.global	is_tap_action
 1939               	is_tap_action:
 1940               	.LVL195:
 1941               	.LFB34:
1030:tmk_core/common/action.c **** #endif
1031:tmk_core/common/action.c **** }
1032:tmk_core/common/action.c **** 
1033:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1034:tmk_core/common/action.c ****  *
1035:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1036:tmk_core/common/action.c ****  */
1037:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
1038:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
1039:tmk_core/common/action.c ****     return is_tap_action(action);
1040:tmk_core/common/action.c **** }
1041:tmk_core/common/action.c **** 
1042:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1043:tmk_core/common/action.c ****  *
1044:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1045:tmk_core/common/action.c ****  */
1046:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1942               		.loc 1 1046 37 view -0
 1943               		.cfi_startproc
 1944               	/* prologue: function */
 1945               	/* frame size = 0 */
 1946               	/* stack size = 0 */
 1947               	.L__stack_usage = 0
1047:tmk_core/common/action.c ****     switch (action.kind.id) {
 1948               		.loc 1 1047 5 view .LVU493
 1949               		.loc 1 1047 24 is_stmt 0 view .LVU494
 1950 0000 E92F      		mov r30,r25
 1951 0002 E295      		swap r30
 1952 0004 EF70      		andi r30,lo8(15)
 1953               		.loc 1 1047 5 view .LVU495
 1954 0006 E250      		subi r30,lo8(-(-2))
 1955 0008 EE30      		cpi r30,lo8(14)
 1956 000a 00F4      		brsh .L189
 1957 000c F0E0      		ldi r31,0
 1958 000e E050      		subi r30,lo8(-(gs(.L183)))
 1959 0010 F040      		sbci r31,hi8(-(gs(.L183)))
 1960 0012 0C94 0000 		jmp __tablejump2__
 1961               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 1962               		.p2align	1
 1963               	.L183:
 1964 0000 0000      		.word gs(.L184)
 1965 0002 0000      		.word gs(.L184)
 1966 0004 0000      		.word gs(.L189)
 1967 0006 0000      		.word gs(.L189)
 1968 0008 0000      		.word gs(.L185)
 1969 000a 0000      		.word gs(.L189)
 1970 000c 0000      		.word gs(.L189)
 1971 000e 0000      		.word gs(.L189)
 1972 0010 0000      		.word gs(.L184)
 1973 0012 0000      		.word gs(.L184)
 1974 0014 0000      		.word gs(.L182)
 1975 0016 0000      		.word gs(.L189)
 1976 0018 0000      		.word gs(.L189)
 1977 001a 0000      		.word gs(.L182)
 1978               		.section	.text.is_tap_action
 1979               	.L184:
1048:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1049:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1050:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1051:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1052:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1980               		.loc 1 1052 13 is_stmt 1 view .LVU496
 1981 0016 803F      		cpi r24,lo8(-16)
 1982 0018 01F0      		breq .L192
 1983 001a 00F4      		brsh .L186
 1984 001c 883E      		cpi r24,lo8(-24)
 1985 001e 00F4      		brsh .L189
 1986               	.L192:
1053:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1054:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1055:tmk_core/common/action.c ****                 case OP_ONESHOT:
1056:tmk_core/common/action.c ****                     return true;
 1987               		.loc 1 1056 28 is_stmt 0 view .LVU497
 1988 0020 81E0      		ldi r24,lo8(1)
 1989               	.LVL196:
 1990               	/* epilogue start */
1057:tmk_core/common/action.c ****             }
1058:tmk_core/common/action.c ****             return false;
1059:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1060:tmk_core/common/action.c ****             switch (action.swap.code) {
1061:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1062:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1063:tmk_core/common/action.c ****                     return true;
1064:tmk_core/common/action.c ****             }
1065:tmk_core/common/action.c ****             return false;
1066:tmk_core/common/action.c ****         case ACT_MACRO:
1067:tmk_core/common/action.c ****         case ACT_FUNCTION:
1068:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1069:tmk_core/common/action.c ****                 return true;
1070:tmk_core/common/action.c ****             }
1071:tmk_core/common/action.c ****             return false;
1072:tmk_core/common/action.c ****     }
1073:tmk_core/common/action.c ****     return false;
1074:tmk_core/common/action.c **** }
 1991               		.loc 1 1074 1 view .LVU498
 1992 0022 0895      		ret
 1993               	.LVL197:
 1994               	.L186:
 1995               		.loc 1 1074 1 view .LVU499
 1996 0024 843F      		cpi r24,lo8(-12)
 1997 0026 01F0      		breq .L192
 1998               	.L189:
1058:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1999               		.loc 1 1058 20 view .LVU500
 2000 0028 80E0      		ldi r24,0
 2001               	.LVL198:
1058:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2002               		.loc 1 1058 20 view .LVU501
 2003 002a 0895      		ret
 2004               	.LVL199:
 2005               	.L185:
1060:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2006               		.loc 1 1060 13 is_stmt 1 view .LVU502
 2007 002c 883E      		cpi r24,lo8(-24)
 2008 002e 00F0      		brlo .L192
 2009 0030 813F      		cpi r24,lo8(-15)
 2010 0032 01F4      		brne .L189
 2011 0034 00C0      		rjmp .L192
 2012               	.L182:
1068:tmk_core/common/action.c ****                 return true;
 2013               		.loc 1 1068 13 view .LVU503
1068:tmk_core/common/action.c ****                 return true;
 2014               		.loc 1 1068 16 is_stmt 0 view .LVU504
 2015 0036 93FB      		bst r25,3
 2016 0038 8827      		clr r24
 2017 003a 80F9      		bld r24,0
 2018               	.LVL200:
1068:tmk_core/common/action.c ****                 return true;
 2019               		.loc 1 1068 16 view .LVU505
 2020 003c 0895      		ret
 2021               		.cfi_endproc
 2022               	.LFE34:
 2024               		.section	.text.is_tap_key,"ax",@progbits
 2025               	.global	is_tap_key
 2027               	is_tap_key:
 2028               	.LVL201:
 2029               	.LFB33:
1037:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2030               		.loc 1 1037 31 is_stmt 1 view -0
 2031               		.cfi_startproc
 2032               	/* prologue: function */
 2033               	/* frame size = 0 */
 2034               	/* stack size = 0 */
 2035               	.L__stack_usage = 0
1038:tmk_core/common/action.c ****     return is_tap_action(action);
 2036               		.loc 1 1038 5 view .LVU507
1038:tmk_core/common/action.c ****     return is_tap_action(action);
 2037               		.loc 1 1038 23 is_stmt 0 view .LVU508
 2038 0000 0E94 0000 		call layer_switch_get_action
 2039               	.LVL202:
1039:tmk_core/common/action.c **** }
 2040               		.loc 1 1039 5 is_stmt 1 view .LVU509
1039:tmk_core/common/action.c **** }
 2041               		.loc 1 1039 12 is_stmt 0 view .LVU510
 2042 0004 0C94 0000 		jmp is_tap_action
 2043               	.LVL203:
 2044               		.cfi_endproc
 2045               	.LFE33:
 2047               		.section	.text.debug_event,"ax",@progbits
 2048               	.global	debug_event
 2050               	debug_event:
 2051               	.LFB35:
1075:tmk_core/common/action.c **** 
1076:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1077:tmk_core/common/action.c ****  *
1078:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1079:tmk_core/common/action.c ****  */
1080:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2052               		.loc 1 1080 36 is_stmt 1 view -0
 2053               		.cfi_startproc
 2054 0000 CF93      		push r28
 2055               	.LCFI21:
 2056               		.cfi_def_cfa_offset 3
 2057               		.cfi_offset 28, -2
 2058 0002 DF93      		push r29
 2059               	.LCFI22:
 2060               		.cfi_def_cfa_offset 4
 2061               		.cfi_offset 29, -3
 2062 0004 00D0      		rcall .
 2063 0006 00D0      		rcall .
 2064 0008 0F92      		push __tmp_reg__
 2065               	.LCFI23:
 2066               		.cfi_def_cfa_offset 9
 2067 000a CDB7      		in r28,__SP_L__
 2068 000c DEB7      		in r29,__SP_H__
 2069               	.LCFI24:
 2070               		.cfi_def_cfa_register 28
 2071               	/* prologue: function */
 2072               	/* frame size = 5 */
 2073               	/* stack size = 7 */
 2074               	.L__stack_usage = 7
 2075               		.loc 1 1080 138 view .LVU512
 2076               	/* epilogue start */
 2077               		.loc 1 1080 1 is_stmt 0 view .LVU513
 2078 000e 0F90      		pop __tmp_reg__
 2079 0010 0F90      		pop __tmp_reg__
 2080 0012 0F90      		pop __tmp_reg__
 2081 0014 0F90      		pop __tmp_reg__
 2082 0016 0F90      		pop __tmp_reg__
 2083 0018 DF91      		pop r29
 2084 001a CF91      		pop r28
 2085 001c 0895      		ret
 2086               		.cfi_endproc
 2087               	.LFE35:
 2089               		.section	.text.debug_record,"ax",@progbits
 2090               	.global	debug_record
 2092               	debug_record:
 2093               	.LFB36:
1081:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1082:tmk_core/common/action.c ****  *
1083:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1084:tmk_core/common/action.c ****  */
1085:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2094               		.loc 1 1085 39 is_stmt 1 view -0
 2095               		.cfi_startproc
 2096 0000 CF93      		push r28
 2097               	.LCFI25:
 2098               		.cfi_def_cfa_offset 3
 2099               		.cfi_offset 28, -2
 2100 0002 DF93      		push r29
 2101               	.LCFI26:
 2102               		.cfi_def_cfa_offset 4
 2103               		.cfi_offset 29, -3
 2104 0004 00D0      		rcall .
 2105 0006 00D0      		rcall .
 2106 0008 00D0      		rcall .
 2107               	.LCFI27:
 2108               		.cfi_def_cfa_offset 10
 2109 000a CDB7      		in r28,__SP_L__
 2110 000c DEB7      		in r29,__SP_H__
 2111               	.LCFI28:
 2112               		.cfi_def_cfa_register 28
 2113               	/* prologue: function */
 2114               	/* frame size = 6 */
 2115               	/* stack size = 8 */
 2116               	.L__stack_usage = 8
1086:tmk_core/common/action.c ****     debug_event(record.event);
 2117               		.loc 1 1086 5 view .LVU515
1087:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1088:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2118               		.loc 1 1088 77 view .LVU516
 2119               	/* epilogue start */
1089:tmk_core/common/action.c **** #endif
1090:tmk_core/common/action.c **** }
 2120               		.loc 1 1090 1 is_stmt 0 view .LVU517
 2121 000e 2696      		adiw r28,6
 2122 0010 0FB6      		in __tmp_reg__,__SREG__
 2123 0012 F894      		cli
 2124 0014 DEBF      		out __SP_H__,r29
 2125 0016 0FBE      		out __SREG__,__tmp_reg__
 2126 0018 CDBF      		out __SP_L__,r28
 2127 001a DF91      		pop r29
 2128 001c CF91      		pop r28
 2129 001e 0895      		ret
 2130               		.cfi_endproc
 2131               	.LFE36:
 2133               		.section	.text.debug_action,"ax",@progbits
 2134               	.global	debug_action
 2136               	debug_action:
 2137               	.LVL204:
 2138               	.LFB37:
1091:tmk_core/common/action.c **** 
1092:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1093:tmk_core/common/action.c ****  *
1094:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1095:tmk_core/common/action.c ****  */
1096:tmk_core/common/action.c **** void debug_action(action_t action) {
 2139               		.loc 1 1096 36 is_stmt 1 view -0
 2140               		.cfi_startproc
 2141               	/* prologue: function */
 2142               	/* frame size = 0 */
 2143               	/* stack size = 0 */
 2144               	.L__stack_usage = 0
1097:tmk_core/common/action.c ****     switch (action.kind.id) {
 2145               		.loc 1 1097 5 view .LVU519
1098:tmk_core/common/action.c ****         case ACT_LMODS:
1099:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1100:tmk_core/common/action.c ****             break;
1101:tmk_core/common/action.c ****         case ACT_RMODS:
1102:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1103:tmk_core/common/action.c ****             break;
1104:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1105:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1106:tmk_core/common/action.c ****             break;
1107:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1108:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1109:tmk_core/common/action.c ****             break;
1110:tmk_core/common/action.c ****         case ACT_USAGE:
1111:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1112:tmk_core/common/action.c ****             break;
1113:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1114:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1115:tmk_core/common/action.c ****             break;
1116:tmk_core/common/action.c ****         case ACT_LAYER:
1117:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1118:tmk_core/common/action.c ****             break;
1119:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1120:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1121:tmk_core/common/action.c ****             break;
1122:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1123:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1124:tmk_core/common/action.c ****             break;
1125:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1126:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1127:tmk_core/common/action.c ****             break;
1128:tmk_core/common/action.c ****         case ACT_MACRO:
1129:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1130:tmk_core/common/action.c ****             break;
1131:tmk_core/common/action.c ****         case ACT_FUNCTION:
1132:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1133:tmk_core/common/action.c ****             break;
1134:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1135:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1136:tmk_core/common/action.c ****             break;
1137:tmk_core/common/action.c ****         default:
1138:tmk_core/common/action.c ****             dprint("UNKNOWN");
1139:tmk_core/common/action.c ****             break;
1140:tmk_core/common/action.c ****     }
1141:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2146               		.loc 1 1141 75 view .LVU520
 2147               	/* epilogue start */
1142:tmk_core/common/action.c **** }
 2148               		.loc 1 1142 1 is_stmt 0 view .LVU521
 2149 0000 0895      		ret
 2150               		.cfi_endproc
 2151               	.LFE37:
 2153               		.section	.rodata.CSWTCH.11,"a"
 2156               	CSWTCH.11:
 2157 0000 E200      		.word	226
 2158 0002 E900      		.word	233
 2159 0004 EA00      		.word	234
 2160 0006 B500      		.word	181
 2161 0008 B600      		.word	182
 2162 000a B700      		.word	183
 2163 000c CD00      		.word	205
 2164 000e 8301      		.word	387
 2165 0010 CC00      		.word	204
 2166 0012 8A01      		.word	394
 2167 0014 9201      		.word	402
 2168 0016 9401      		.word	404
 2169 0018 2102      		.word	545
 2170 001a 2302      		.word	547
 2171 001c 2402      		.word	548
 2172 001e 2502      		.word	549
 2173 0020 2602      		.word	550
 2174 0022 2702      		.word	551
 2175 0024 2A02      		.word	554
 2176 0026 B300      		.word	179
 2177 0028 B400      		.word	180
 2178 002a 6F00      		.word	111
 2179 002c 7000      		.word	112
 2180               		.section	.rodata.CSWTCH.10,"a"
 2183               	CSWTCH.10:
 2184 0000 81        		.byte	-127
 2185 0001 82        		.byte	-126
 2186 0002 83        		.byte	-125
 2187               	.global	disable_action_cache
 2188               		.section	.bss.disable_action_cache,"aw",@nobits
 2191               	disable_action_cache:
 2192 0000 00        		.zero	1
 2193               		.comm	tp_buttons,2,1
 2194               		.text
 2195               	.Letext0:
 2196               		.file 5 "/usr/avr/include/stdint.h"
 2197               		.file 6 "tmk_core/common/keycode.h"
 2198               		.file 7 "tmk_core/common/host.h"
 2199               		.file 8 "tmk_core/common/mousekey.h"
 2200               		.file 9 "tmk_core/common/command.h"
 2201               		.file 10 "tmk_core/common/action_code.h"
 2202               		.file 11 "tmk_core/common/action.h"
 2203               		.file 12 "tmk_core/common/action_layer.h"
 2204               		.file 13 "tmk_core/common/action_util.h"
 2205               		.file 14 "tmk_core/common/avr/xprintf.h"
 2206               		.file 15 "tmk_core/common/debug.h"
 2207               		.file 16 "tmk_core/common/led.h"
 2208               		.file 17 "tmk_core/common/action_macro.h"
 2209               		.file 18 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccgbOdba.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccgbOdba.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccgbOdba.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccgbOdba.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccgbOdba.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccgbOdba.s:13     .text.action_exec:0000000000000000 action_exec
     /tmp/ccgbOdba.s:94     .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccgbOdba.s:116    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/ccgbOdba.s:135    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/ccgbOdba.s:160    .text.register_code:0000000000000000 register_code
     /tmp/ccgbOdba.s:2183   .rodata.CSWTCH.10:0000000000000000 CSWTCH.10
     /tmp/ccgbOdba.s:2156   .rodata.CSWTCH.11:0000000000000000 CSWTCH.11
     /tmp/ccgbOdba.s:337    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccgbOdba.s:437    .text.tap_code:0000000000000000 tap_code
     /tmp/ccgbOdba.s:502    .text.register_mods:0000000000000000 register_mods
     /tmp/ccgbOdba.s:531    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccgbOdba.s:560    .text.process_action:0000000000000000 process_action
     /tmp/ccgbOdba.s:1674   .text.process_record:0000000000000000 process_record
     /tmp/ccgbOdba.s:1602   .text.process_record_handler:0000000000000000 process_record_handler
     /tmp/ccgbOdba.s:1774   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/ccgbOdba.s:2191   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/ccgbOdba.s:1802   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/ccgbOdba.s:1831   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/ccgbOdba.s:1860   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/ccgbOdba.s:1899   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccgbOdba.s:1919   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccgbOdba.s:1939   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/ccgbOdba.s:2027   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccgbOdba.s:2050   .text.debug_event:0000000000000000 debug_event
     /tmp/ccgbOdba.s:2092   .text.debug_record:0000000000000000 debug_record
     /tmp/ccgbOdba.s:2136   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
command_proc
keyboard_report
is_key_pressed
del_key
send_keyboard_report
add_key
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
host_keyboard_leds
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
