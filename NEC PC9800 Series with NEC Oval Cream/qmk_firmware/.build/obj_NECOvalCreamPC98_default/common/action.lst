   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.action_exec,"ax",@progbits
  12               	.global	action_exec
  14               	action_exec:
  15               	.LFB108:
  16               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:tmk_core/common/action.c **** #    include "pointing_device.h"
  42:tmk_core/common/action.c **** #endif
  43:tmk_core/common/action.c **** 
  44:tmk_core/common/action.c **** int tp_buttons;
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  51:tmk_core/common/action.c **** #    include "fauxclicky.h"
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  55:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** 
  58:tmk_core/common/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  59:tmk_core/common/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  60:tmk_core/common/action.c **** #endif
  61:tmk_core/common/action.c **** 
  62:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  63:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  64:tmk_core/common/action.c **** #endif
  65:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  66:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  67:tmk_core/common/action.c **** #endif
  68:tmk_core/common/action.c **** /** \brief Called to execute an action.
  69:tmk_core/common/action.c ****  *
  70:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  71:tmk_core/common/action.c ****  */
  72:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  17               		.loc 1 72 36 view -0
  18               		.cfi_startproc
  19 0000 CF93      		push r28
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 28, -2
  23 0002 DF93      		push r29
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 29, -3
  27 0004 CDB7      		in r28,__SP_L__
  28 0006 DEB7      		in r29,__SP_H__
  29               	.LCFI2:
  30               		.cfi_def_cfa_register 28
  31 0008 2B97      		sbiw r28,11
  32               	.LCFI3:
  33               		.cfi_def_cfa_offset 15
  34 000a 0FB6      		in __tmp_reg__,__SREG__
  35 000c F894      		cli
  36 000e DEBF      		out __SP_H__,r29
  37 0010 0FBE      		out __SREG__,__tmp_reg__
  38 0012 CDBF      		out __SP_L__,r28
  39               	/* prologue: function */
  40               	/* frame size = 11 */
  41               	/* stack size = 13 */
  42               	.L__stack_usage = 13
  43 0014 4F83      		std Y+7,r20
  44 0016 5887      		std Y+8,r21
  45 0018 6987      		std Y+9,r22
  46 001a 7A87      		std Y+10,r23
  47 001c 8B87      		std Y+11,r24
  48               	.LVL0:
  73:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  49               		.loc 1 73 5 view .LVU1
  74:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  75:tmk_core/common/action.c ****         dprint("EVENT: ");
  76:tmk_core/common/action.c ****         debug_event(event);
  77:tmk_core/common/action.c ****         dprintln();
  50               		.loc 1 77 19 view .LVU2
  78:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  79:tmk_core/common/action.c ****         retro_tapping_counter++;
  80:tmk_core/common/action.c **** #endif
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c **** 
  83:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  84:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  85:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  86:tmk_core/common/action.c ****     }
  87:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  88:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  89:tmk_core/common/action.c ****     }
  90:tmk_core/common/action.c ****     fauxclicky_check();
  91:tmk_core/common/action.c **** #endif
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  94:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  95:tmk_core/common/action.c ****         process_hand_swap(&event);
  96:tmk_core/common/action.c ****     }
  97:tmk_core/common/action.c **** #endif
  98:tmk_core/common/action.c **** 
  99:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  51               		.loc 1 99 5 view .LVU3
  52               		.loc 1 99 17 is_stmt 0 view .LVU4
  53 001e 1E82      		std Y+6,__zero_reg__
  54 0020 1D82      		std Y+5,__zero_reg__
  55 0022 85E0      		ldi r24,lo8(5)
  56 0024 FE01      		movw r30,r28
  57 0026 3796      		adiw r30,7
  58 0028 DE01      		movw r26,r28
  59 002a 1196      		adiw r26,1
  60               		0:
  61 002c 0190      		ld r0,Z+
  62 002e 0D92      		st X+,r0
  63 0030 8A95      		dec r24
  64 0032 01F4      		brne 0b
 100:tmk_core/common/action.c **** 
 101:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 102:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
 103:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
 104:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 105:tmk_core/common/action.c ****     }
 106:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
 107:tmk_core/common/action.c ****         clear_oneshot_mods();
 108:tmk_core/common/action.c ****     }
 109:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 110:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 111:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 112:tmk_core/common/action.c ****     }
 113:tmk_core/common/action.c **** #        endif
 114:tmk_core/common/action.c **** #    endif
 115:tmk_core/common/action.c **** #endif
 116:tmk_core/common/action.c **** 
 117:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 118:tmk_core/common/action.c ****     action_tapping_process(record);
  65               		.loc 1 118 5 is_stmt 1 view .LVU5
  66 0034 4981      		ldd r20,Y+1
  67               	.LVL1:
  68               		.loc 1 118 5 is_stmt 0 view .LVU6
  69 0036 5A81      		ldd r21,Y+2
  70               	.LVL2:
  71               		.loc 1 118 5 view .LVU7
  72 0038 6B81      		ldd r22,Y+3
  73 003a 7C81      		ldd r23,Y+4
  74 003c 8D81      		ldd r24,Y+5
  75 003e 9E81      		ldd r25,Y+6
  76               	/* epilogue start */
 119:tmk_core/common/action.c **** #else
 120:tmk_core/common/action.c ****     process_record(&record);
 121:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 122:tmk_core/common/action.c ****         dprint("processed: ");
 123:tmk_core/common/action.c ****         debug_record(record);
 124:tmk_core/common/action.c ****         dprintln();
 125:tmk_core/common/action.c ****     }
 126:tmk_core/common/action.c **** #endif
 127:tmk_core/common/action.c **** }
  77               		.loc 1 127 1 view .LVU8
  78 0040 2B96      		adiw r28,11
  79 0042 0FB6      		in __tmp_reg__,__SREG__
  80 0044 F894      		cli
  81 0046 DEBF      		out __SP_H__,r29
  82 0048 0FBE      		out __SREG__,__tmp_reg__
  83 004a CDBF      		out __SP_L__,r28
  84 004c DF91      		pop r29
  85 004e CF91      		pop r28
 118:tmk_core/common/action.c **** #else
  86               		.loc 1 118 5 view .LVU9
  87 0050 0C94 0000 		jmp action_tapping_process
  88               	.LVL3:
  89               		.cfi_endproc
  90               	.LFE108:
  92               		.section	.text.process_record_quantum,"ax",@progbits
  93               		.weak	process_record_quantum
  95               	process_record_quantum:
  96               	.LVL4:
  97               	.LFB110:
 128:tmk_core/common/action.c **** 
 129:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 130:tmk_core/common/action.c **** bool swap_hands = false;
 131:tmk_core/common/action.c **** bool swap_held  = false;
 132:tmk_core/common/action.c **** 
 133:tmk_core/common/action.c **** /** \brief Process Hand Swap
 134:tmk_core/common/action.c ****  *
 135:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 136:tmk_core/common/action.c ****  */
 137:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 138:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 139:tmk_core/common/action.c **** 
 140:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 141:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 142:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 143:tmk_core/common/action.c **** 
 144:tmk_core/common/action.c ****     if (do_swap) {
 145:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 146:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 147:tmk_core/common/action.c ****     } else {
 148:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 149:tmk_core/common/action.c ****     }
 150:tmk_core/common/action.c **** }
 151:tmk_core/common/action.c **** #endif
 152:tmk_core/common/action.c **** 
 153:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 154:tmk_core/common/action.c **** bool disable_action_cache = false;
 155:tmk_core/common/action.c **** 
 156:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 157:tmk_core/common/action.c ****     disable_action_cache = true;
 158:tmk_core/common/action.c ****     process_record(record);
 159:tmk_core/common/action.c ****     disable_action_cache = false;
 160:tmk_core/common/action.c **** }
 161:tmk_core/common/action.c **** #else
 162:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 163:tmk_core/common/action.c **** #endif
 164:tmk_core/common/action.c **** 
 165:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  98               		.loc 1 165 72 is_stmt 1 view -0
  99               		.cfi_startproc
 100               	/* prologue: function */
 101               	/* frame size = 0 */
 102               	/* stack size = 0 */
 103               	.L__stack_usage = 0
 104               		.loc 1 165 74 view .LVU11
 105               		.loc 1 165 1 is_stmt 0 view .LVU12
 106 0000 81E0      		ldi r24,lo8(1)
 107               	.LVL5:
 108               	/* epilogue start */
 109               		.loc 1 165 1 view .LVU13
 110 0002 0895      		ret
 111               		.cfi_endproc
 112               	.LFE110:
 114               		.section	.text.post_process_record_quantum,"ax",@progbits
 115               		.weak	post_process_record_quantum
 117               	post_process_record_quantum:
 118               	.LVL6:
 119               	.LFB111:
 166:tmk_core/common/action.c **** 
 167:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 120               		.loc 1 167 77 is_stmt 1 view -0
 121               		.cfi_startproc
 122               	/* prologue: function */
 123               	/* frame size = 0 */
 124               	/* stack size = 0 */
 125               	.L__stack_usage = 0
 126               		.loc 1 167 78 view .LVU15
 127               	/* epilogue start */
 128               		.loc 1 167 1 is_stmt 0 view .LVU16
 129 0000 0895      		ret
 130               		.cfi_endproc
 131               	.LFE111:
 133               		.section	.text.process_record_tap_hint,"ax",@progbits
 134               	.global	process_record_tap_hint
 136               	process_record_tap_hint:
 137               	.LVL7:
 138               	.LFB112:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 170:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 171:tmk_core/common/action.c ****  *
 172:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 173:tmk_core/common/action.c ****  */
 174:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 139               		.loc 1 174 51 is_stmt 1 view -0
 140               		.cfi_startproc
 141               	/* prologue: function */
 142               	/* frame size = 0 */
 143               	/* stack size = 0 */
 144               	.L__stack_usage = 0
 175:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 145               		.loc 1 175 5 view .LVU18
 146               		.loc 1 175 23 is_stmt 0 view .LVU19
 147 0000 FC01      		movw r30,r24
 148 0002 8081      		ld r24,Z
 149 0004 9181      		ldd r25,Z+1
 150               	.LVL8:
 151               		.loc 1 175 23 view .LVU20
 152 0006 0C94 0000 		jmp layer_switch_get_action
 153               	.LVL9:
 154               		.loc 1 175 23 view .LVU21
 155               		.cfi_endproc
 156               	.LFE112:
 158               		.section	.text.register_code,"ax",@progbits
 159               	.global	register_code
 161               	register_code:
 162               	.LVL10:
 163               	.LFB116:
 176:tmk_core/common/action.c **** 
 177:tmk_core/common/action.c ****     switch (action.kind.id) {
 178:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 179:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 180:tmk_core/common/action.c ****             switch (action.swap.code) {
 181:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 182:tmk_core/common/action.c ****                     break;
 183:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 184:tmk_core/common/action.c ****                 default:
 185:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 186:tmk_core/common/action.c ****                     swap_held  = true;
 187:tmk_core/common/action.c ****             }
 188:tmk_core/common/action.c ****             break;
 189:tmk_core/common/action.c **** #    endif
 190:tmk_core/common/action.c ****     }
 191:tmk_core/common/action.c **** }
 192:tmk_core/common/action.c **** #endif
 193:tmk_core/common/action.c **** 
 194:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 195:tmk_core/common/action.c ****  *
 196:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 197:tmk_core/common/action.c ****  */
 198:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 199:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 200:tmk_core/common/action.c ****         return;
 201:tmk_core/common/action.c ****     }
 202:tmk_core/common/action.c **** 
 203:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 204:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 205:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 206:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 207:tmk_core/common/action.c ****         }
 208:tmk_core/common/action.c **** #endif
 209:tmk_core/common/action.c ****         return;
 210:tmk_core/common/action.c ****     }
 211:tmk_core/common/action.c **** 
 212:tmk_core/common/action.c ****     process_record_handler(record);
 213:tmk_core/common/action.c ****     post_process_record_quantum(record);
 214:tmk_core/common/action.c **** }
 215:tmk_core/common/action.c **** 
 216:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 217:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 218:tmk_core/common/action.c ****     dprint("ACTION: ");
 219:tmk_core/common/action.c ****     debug_action(action);
 220:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 221:tmk_core/common/action.c ****     dprint(" layer_state: ");
 222:tmk_core/common/action.c ****     layer_debug();
 223:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 224:tmk_core/common/action.c ****     default_layer_debug();
 225:tmk_core/common/action.c **** #endif
 226:tmk_core/common/action.c ****     dprintln();
 227:tmk_core/common/action.c **** 
 228:tmk_core/common/action.c ****     process_action(record, action);
 229:tmk_core/common/action.c **** }
 230:tmk_core/common/action.c **** 
 231:tmk_core/common/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 232:tmk_core/common/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 233:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 234:tmk_core/common/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 235:tmk_core/common/action.c **** #    endif
 236:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 237:tmk_core/common/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 238:tmk_core/common/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 239:tmk_core/common/action.c ****     pointing_device_set_report(currentReport);
 240:tmk_core/common/action.c **** #    endif
 241:tmk_core/common/action.c **** }
 242:tmk_core/common/action.c **** #endif
 243:tmk_core/common/action.c **** 
 244:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 245:tmk_core/common/action.c ****  *
 246:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 247:tmk_core/common/action.c ****  */
 248:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 249:tmk_core/common/action.c ****     keyevent_t event = record->event;
 250:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 251:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 252:tmk_core/common/action.c **** #endif
 253:tmk_core/common/action.c **** 
 254:tmk_core/common/action.c ****     if (event.pressed) {
 255:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 256:tmk_core/common/action.c ****         clear_weak_mods();
 257:tmk_core/common/action.c ****     }
 258:tmk_core/common/action.c **** 
 259:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 260:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 261:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 262:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 263:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 264:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 265:tmk_core/common/action.c **** #    endif
 266:tmk_core/common/action.c ****     ) {
 267:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 268:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 269:tmk_core/common/action.c ****     }
 270:tmk_core/common/action.c **** #endif
 271:tmk_core/common/action.c **** 
 272:tmk_core/common/action.c ****     switch (action.kind.id) {
 273:tmk_core/common/action.c ****         /* Key and Mods */
 274:tmk_core/common/action.c ****         case ACT_LMODS:
 275:tmk_core/common/action.c ****         case ACT_RMODS: {
 276:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 277:tmk_core/common/action.c ****             if (event.pressed) {
 278:tmk_core/common/action.c ****                 if (mods) {
 279:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 280:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 281:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 282:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 283:tmk_core/common/action.c ****                         add_mods(mods);
 284:tmk_core/common/action.c ****                     } else {
 285:tmk_core/common/action.c ****                         add_weak_mods(mods);
 286:tmk_core/common/action.c ****                     }
 287:tmk_core/common/action.c ****                     send_keyboard_report();
 288:tmk_core/common/action.c ****                 }
 289:tmk_core/common/action.c ****                 register_code(action.key.code);
 290:tmk_core/common/action.c ****             } else {
 291:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 292:tmk_core/common/action.c ****                 if (mods) {
 293:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 294:tmk_core/common/action.c ****                         del_mods(mods);
 295:tmk_core/common/action.c ****                     } else {
 296:tmk_core/common/action.c ****                         del_weak_mods(mods);
 297:tmk_core/common/action.c ****                     }
 298:tmk_core/common/action.c ****                     send_keyboard_report();
 299:tmk_core/common/action.c ****                 }
 300:tmk_core/common/action.c ****             }
 301:tmk_core/common/action.c ****         } break;
 302:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 303:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 304:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 305:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 306:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 307:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 308:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 309:tmk_core/common/action.c ****                     // Oneshot modifier
 310:tmk_core/common/action.c ****                     if (event.pressed) {
 311:tmk_core/common/action.c ****                         if (tap_count == 0) {
 312:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 313:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 314:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 315:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 316:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 317:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 318:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 319:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 320:tmk_core/common/action.c ****                             clear_oneshot_mods();
 321:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 322:tmk_core/common/action.c ****                             register_mods(mods);
 323:tmk_core/common/action.c **** #        endif
 324:tmk_core/common/action.c ****                         } else {
 325:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 326:tmk_core/common/action.c ****                         }
 327:tmk_core/common/action.c ****                     } else {
 328:tmk_core/common/action.c ****                         if (tap_count == 0) {
 329:tmk_core/common/action.c ****                             clear_oneshot_mods();
 330:tmk_core/common/action.c ****                             unregister_mods(mods);
 331:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 332:tmk_core/common/action.c ****                             // Retain Oneshot mods
 333:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 334:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 335:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 336:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 337:tmk_core/common/action.c ****                                 unregister_mods(mods);
 338:tmk_core/common/action.c ****                             }
 339:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 340:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 341:tmk_core/common/action.c **** #        endif
 342:tmk_core/common/action.c ****                         } else {
 343:tmk_core/common/action.c ****                             clear_oneshot_mods();
 344:tmk_core/common/action.c ****                             unregister_mods(mods);
 345:tmk_core/common/action.c ****                         }
 346:tmk_core/common/action.c ****                     }
 347:tmk_core/common/action.c ****                     break;
 348:tmk_core/common/action.c **** #    endif
 349:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 350:tmk_core/common/action.c ****                     if (event.pressed) {
 351:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 352:tmk_core/common/action.c ****                             register_mods(mods);
 353:tmk_core/common/action.c ****                         }
 354:tmk_core/common/action.c ****                     } else {
 355:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 356:tmk_core/common/action.c ****                             unregister_mods(mods);
 357:tmk_core/common/action.c ****                         }
 358:tmk_core/common/action.c ****                     }
 359:tmk_core/common/action.c ****                     break;
 360:tmk_core/common/action.c ****                 default:
 361:tmk_core/common/action.c ****                     if (event.pressed) {
 362:tmk_core/common/action.c ****                         if (tap_count > 0) {
 363:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 364:tmk_core/common/action.c ****                             if (
 365:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 366:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 367:tmk_core/common/action.c **** #        endif
 368:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 369:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 370:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 371:tmk_core/common/action.c ****                                 record->tap.count = 0;
 372:tmk_core/common/action.c ****                                 register_mods(mods);
 373:tmk_core/common/action.c ****                             } else
 374:tmk_core/common/action.c **** #    endif
 375:tmk_core/common/action.c ****                             {
 376:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 377:tmk_core/common/action.c ****                                 register_code(action.key.code);
 378:tmk_core/common/action.c ****                             }
 379:tmk_core/common/action.c ****                         } else {
 380:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 381:tmk_core/common/action.c ****                             register_mods(mods);
 382:tmk_core/common/action.c ****                         }
 383:tmk_core/common/action.c ****                     } else {
 384:tmk_core/common/action.c ****                         if (tap_count > 0) {
 385:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 386:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 387:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 388:tmk_core/common/action.c ****                             } else {
 389:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 390:tmk_core/common/action.c ****                             }
 391:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 392:tmk_core/common/action.c ****                         } else {
 393:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 394:tmk_core/common/action.c ****                             unregister_mods(mods);
 395:tmk_core/common/action.c ****                         }
 396:tmk_core/common/action.c ****                     }
 397:tmk_core/common/action.c ****                     break;
 398:tmk_core/common/action.c ****             }
 399:tmk_core/common/action.c ****         } break;
 400:tmk_core/common/action.c **** #endif
 401:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 402:tmk_core/common/action.c ****         /* other HID usage */
 403:tmk_core/common/action.c ****         case ACT_USAGE:
 404:tmk_core/common/action.c ****             switch (action.usage.page) {
 405:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 406:tmk_core/common/action.c ****                     if (event.pressed) {
 407:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 408:tmk_core/common/action.c ****                     } else {
 409:tmk_core/common/action.c ****                         host_system_send(0);
 410:tmk_core/common/action.c ****                     }
 411:tmk_core/common/action.c ****                     break;
 412:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 413:tmk_core/common/action.c ****                     if (event.pressed) {
 414:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 415:tmk_core/common/action.c ****                     } else {
 416:tmk_core/common/action.c ****                         host_consumer_send(0);
 417:tmk_core/common/action.c ****                     }
 418:tmk_core/common/action.c ****                     break;
 419:tmk_core/common/action.c ****             }
 420:tmk_core/common/action.c ****             break;
 421:tmk_core/common/action.c **** #endif
 422:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 423:tmk_core/common/action.c ****         /* Mouse key */
 424:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 425:tmk_core/common/action.c ****             if (event.pressed) {
 426:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 427:tmk_core/common/action.c ****                 switch (action.key.code) {
 428:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 429:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 430:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN1);
 431:tmk_core/common/action.c ****                         break;
 432:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 433:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN2);
 434:tmk_core/common/action.c ****                         break;
 435:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 436:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN3);
 437:tmk_core/common/action.c ****                         break;
 438:tmk_core/common/action.c **** #    endif
 439:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 440:tmk_core/common/action.c ****                     case KC_MS_BTN4:
 441:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN4);
 442:tmk_core/common/action.c ****                         break;
 443:tmk_core/common/action.c ****                     case KC_MS_BTN5:
 444:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN5);
 445:tmk_core/common/action.c ****                         break;
 446:tmk_core/common/action.c **** #    endif
 447:tmk_core/common/action.c ****                     default:
 448:tmk_core/common/action.c ****                         mousekey_send();
 449:tmk_core/common/action.c ****                         break;
 450:tmk_core/common/action.c ****                 }
 451:tmk_core/common/action.c ****             } else {
 452:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 453:tmk_core/common/action.c ****                 switch (action.key.code) {
 454:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 455:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 456:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN1);
 457:tmk_core/common/action.c ****                         break;
 458:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 459:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN2);
 460:tmk_core/common/action.c ****                         break;
 461:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 462:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN3);
 463:tmk_core/common/action.c ****                         break;
 464:tmk_core/common/action.c **** #    endif
 465:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 466:tmk_core/common/action.c ****                     case KC_MS_BTN4:
 467:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN4);
 468:tmk_core/common/action.c ****                         break;
 469:tmk_core/common/action.c ****                     case KC_MS_BTN5:
 470:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN5);
 471:tmk_core/common/action.c ****                         break;
 472:tmk_core/common/action.c **** #    endif
 473:tmk_core/common/action.c ****                     default:
 474:tmk_core/common/action.c ****                         mousekey_send();
 475:tmk_core/common/action.c ****                         break;
 476:tmk_core/common/action.c ****                 }
 477:tmk_core/common/action.c ****             }
 478:tmk_core/common/action.c ****             break;
 479:tmk_core/common/action.c **** #endif
 480:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 481:tmk_core/common/action.c ****         case ACT_LAYER:
 482:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 483:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 484:tmk_core/common/action.c ****                 if (!event.pressed) {
 485:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 486:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 487:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 488:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 489:tmk_core/common/action.c ****                         case OP_BIT_AND:
 490:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 491:tmk_core/common/action.c ****                             break;
 492:tmk_core/common/action.c ****                         case OP_BIT_OR:
 493:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 494:tmk_core/common/action.c ****                             break;
 495:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 496:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 497:tmk_core/common/action.c ****                             break;
 498:tmk_core/common/action.c ****                         case OP_BIT_SET:
 499:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 500:tmk_core/common/action.c ****                             break;
 501:tmk_core/common/action.c ****                     }
 502:tmk_core/common/action.c ****                 }
 503:tmk_core/common/action.c ****             } else {
 504:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 505:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 506:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 507:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 508:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 509:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 510:tmk_core/common/action.c ****                         case OP_BIT_AND:
 511:tmk_core/common/action.c ****                             layer_and(bits | mask);
 512:tmk_core/common/action.c ****                             break;
 513:tmk_core/common/action.c ****                         case OP_BIT_OR:
 514:tmk_core/common/action.c ****                             layer_or(bits | mask);
 515:tmk_core/common/action.c ****                             break;
 516:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 517:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 518:tmk_core/common/action.c ****                             break;
 519:tmk_core/common/action.c ****                         case OP_BIT_SET:
 520:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 521:tmk_core/common/action.c ****                             break;
 522:tmk_core/common/action.c ****                     }
 523:tmk_core/common/action.c ****                 }
 524:tmk_core/common/action.c ****             }
 525:tmk_core/common/action.c ****             break;
 526:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 527:tmk_core/common/action.c ****             if (event.pressed) {
 528:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 529:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 530:tmk_core/common/action.c ****             } else {
 531:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 532:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 533:tmk_core/common/action.c ****             }
 534:tmk_core/common/action.c ****             break;
 535:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 536:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 537:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 538:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 539:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 540:tmk_core/common/action.c ****                     /* tap toggle */
 541:tmk_core/common/action.c ****                     if (event.pressed) {
 542:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 543:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 544:tmk_core/common/action.c ****                         }
 545:tmk_core/common/action.c ****                     } else {
 546:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 547:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 548:tmk_core/common/action.c ****                         }
 549:tmk_core/common/action.c ****                     }
 550:tmk_core/common/action.c ****                     break;
 551:tmk_core/common/action.c ****                 case OP_ON_OFF:
 552:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 553:tmk_core/common/action.c ****                     break;
 554:tmk_core/common/action.c ****                 case OP_OFF_ON:
 555:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 556:tmk_core/common/action.c ****                     break;
 557:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 558:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 559:tmk_core/common/action.c ****                     break;
 560:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 561:tmk_core/common/action.c ****                 case OP_ONESHOT:
 562:tmk_core/common/action.c ****                     // Oneshot modifier
 563:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 564:tmk_core/common/action.c ****                     do_release_oneshot = false;
 565:tmk_core/common/action.c ****                     if (event.pressed) {
 566:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 567:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 568:tmk_core/common/action.c ****                             reset_oneshot_layer();
 569:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 570:tmk_core/common/action.c ****                             break;
 571:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 572:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 573:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 574:tmk_core/common/action.c ****                         }
 575:tmk_core/common/action.c ****                     } else {
 576:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 577:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 578:tmk_core/common/action.c ****                             reset_oneshot_layer();
 579:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 580:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 581:tmk_core/common/action.c ****                         } else {
 582:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 583:tmk_core/common/action.c ****                         }
 584:tmk_core/common/action.c ****                     }
 585:tmk_core/common/action.c **** #            else
 586:tmk_core/common/action.c ****                     if (event.pressed) {
 587:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 588:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 589:tmk_core/common/action.c ****                     } else {
 590:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 591:tmk_core/common/action.c ****                         if (tap_count > 1) {
 592:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 593:tmk_core/common/action.c ****                         }
 594:tmk_core/common/action.c ****                     }
 595:tmk_core/common/action.c **** #            endif
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c **** #        endif
 598:tmk_core/common/action.c ****                 default:
 599:tmk_core/common/action.c ****                     /* tap key */
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         if (tap_count > 0) {
 602:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 603:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 604:tmk_core/common/action.c ****                         } else {
 605:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 606:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 607:tmk_core/common/action.c ****                         }
 608:tmk_core/common/action.c ****                     } else {
 609:tmk_core/common/action.c ****                         if (tap_count > 0) {
 610:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 611:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 612:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 613:tmk_core/common/action.c ****                             } else {
 614:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 615:tmk_core/common/action.c ****                             }
 616:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 617:tmk_core/common/action.c ****                         } else {
 618:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 619:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 620:tmk_core/common/action.c ****                         }
 621:tmk_core/common/action.c ****                     }
 622:tmk_core/common/action.c ****                     break;
 623:tmk_core/common/action.c ****             }
 624:tmk_core/common/action.c ****             break;
 625:tmk_core/common/action.c **** #    endif
 626:tmk_core/common/action.c **** #endif
 627:tmk_core/common/action.c ****             /* Extentions */
 628:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 629:tmk_core/common/action.c ****         case ACT_MACRO:
 630:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 631:tmk_core/common/action.c ****             break;
 632:tmk_core/common/action.c **** #endif
 633:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 634:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 635:tmk_core/common/action.c ****             switch (action.swap.code) {
 636:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 637:tmk_core/common/action.c ****                     if (event.pressed) {
 638:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 639:tmk_core/common/action.c ****                     }
 640:tmk_core/common/action.c ****                     break;
 641:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 642:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 643:tmk_core/common/action.c ****                     break;
 644:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 645:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 646:tmk_core/common/action.c ****                     break;
 647:tmk_core/common/action.c ****                 case OP_SH_ON:
 648:tmk_core/common/action.c ****                     if (!event.pressed) {
 649:tmk_core/common/action.c ****                         swap_hands = true;
 650:tmk_core/common/action.c ****                     }
 651:tmk_core/common/action.c ****                     break;
 652:tmk_core/common/action.c ****                 case OP_SH_OFF:
 653:tmk_core/common/action.c ****                     if (!event.pressed) {
 654:tmk_core/common/action.c ****                         swap_hands = false;
 655:tmk_core/common/action.c ****                     }
 656:tmk_core/common/action.c ****                     break;
 657:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 658:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 659:tmk_core/common/action.c ****                     if (event.pressed) {
 660:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 661:tmk_core/common/action.c ****                     } else {
 662:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 663:tmk_core/common/action.c ****                     }
 664:tmk_core/common/action.c ****                     break;
 665:tmk_core/common/action.c **** #    endif
 666:tmk_core/common/action.c **** 
 667:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 668:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 669:tmk_core/common/action.c ****                     /* tap toggle */
 670:tmk_core/common/action.c **** 
 671:tmk_core/common/action.c ****                     if (event.pressed) {
 672:tmk_core/common/action.c ****                         if (swap_held) {
 673:tmk_core/common/action.c ****                             swap_held = false;
 674:tmk_core/common/action.c ****                         } else {
 675:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 676:tmk_core/common/action.c ****                         }
 677:tmk_core/common/action.c ****                     } else {
 678:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 679:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 680:tmk_core/common/action.c ****                         }
 681:tmk_core/common/action.c ****                     }
 682:tmk_core/common/action.c ****                     break;
 683:tmk_core/common/action.c ****                 default:
 684:tmk_core/common/action.c ****                     /* tap key */
 685:tmk_core/common/action.c ****                     if (tap_count > 0) {
 686:tmk_core/common/action.c ****                         if (swap_held) {
 687:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 688:tmk_core/common/action.c ****                             swap_held  = false;
 689:tmk_core/common/action.c ****                         }
 690:tmk_core/common/action.c ****                         if (event.pressed) {
 691:tmk_core/common/action.c ****                             register_code(action.swap.code);
 692:tmk_core/common/action.c ****                         } else {
 693:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 694:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 695:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 696:tmk_core/common/action.c ****                         }
 697:tmk_core/common/action.c ****                     } else {
 698:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 699:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 700:tmk_core/common/action.c ****                             swap_held  = false;
 701:tmk_core/common/action.c ****                         }
 702:tmk_core/common/action.c ****                     }
 703:tmk_core/common/action.c **** #    endif
 704:tmk_core/common/action.c ****             }
 705:tmk_core/common/action.c **** #endif
 706:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 707:tmk_core/common/action.c ****         case ACT_FUNCTION:
 708:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 709:tmk_core/common/action.c ****             break;
 710:tmk_core/common/action.c **** #endif
 711:tmk_core/common/action.c ****         default:
 712:tmk_core/common/action.c ****             break;
 713:tmk_core/common/action.c ****     }
 714:tmk_core/common/action.c **** 
 715:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 716:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 717:tmk_core/common/action.c ****     switch (action.kind.id) {
 718:tmk_core/common/action.c ****         case ACT_LAYER:
 719:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 720:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 721:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 722:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 723:tmk_core/common/action.c **** #    endif
 724:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 725:tmk_core/common/action.c ****             break;
 726:tmk_core/common/action.c ****         default:
 727:tmk_core/common/action.c ****             break;
 728:tmk_core/common/action.c ****     }
 729:tmk_core/common/action.c **** #endif
 730:tmk_core/common/action.c **** 
 731:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 732:tmk_core/common/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 733:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 734:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 735:tmk_core/common/action.c ****     } else {
 736:tmk_core/common/action.c ****         if (event.pressed) {
 737:tmk_core/common/action.c ****             if (tap_count > 0) {
 738:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 739:tmk_core/common/action.c ****             }
 740:tmk_core/common/action.c ****         } else {
 741:tmk_core/common/action.c ****             if (tap_count > 0) {
 742:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 743:tmk_core/common/action.c ****             } else {
 744:tmk_core/common/action.c ****                 if (
 745:tmk_core/common/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 746:tmk_core/common/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 747:tmk_core/common/action.c **** #        endif
 748:tmk_core/common/action.c ****                     retro_tapping_counter == 2) {
 749:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 750:tmk_core/common/action.c ****                 }
 751:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 752:tmk_core/common/action.c ****             }
 753:tmk_core/common/action.c ****         }
 754:tmk_core/common/action.c ****     }
 755:tmk_core/common/action.c **** #    endif
 756:tmk_core/common/action.c **** #endif
 757:tmk_core/common/action.c **** 
 758:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 759:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 760:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 761:tmk_core/common/action.c ****         use_oneshot_swaphands();
 762:tmk_core/common/action.c ****     }
 763:tmk_core/common/action.c **** #    endif
 764:tmk_core/common/action.c **** #endif
 765:tmk_core/common/action.c **** 
 766:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 767:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 768:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 769:tmk_core/common/action.c ****      */
 770:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 771:tmk_core/common/action.c ****         record->event.pressed = false;
 772:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 773:tmk_core/common/action.c ****         process_record(record);
 774:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 775:tmk_core/common/action.c ****     }
 776:tmk_core/common/action.c **** #endif
 777:tmk_core/common/action.c **** }
 778:tmk_core/common/action.c **** 
 779:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 780:tmk_core/common/action.c ****  *
 781:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 782:tmk_core/common/action.c ****  */
 783:tmk_core/common/action.c **** void register_code(uint8_t code) {
 164               		.loc 1 783 34 is_stmt 1 view -0
 165               		.cfi_startproc
 166               		.loc 1 783 34 is_stmt 0 view .LVU23
 167 0000 CF93      		push r28
 168               	.LCFI4:
 169               		.cfi_def_cfa_offset 3
 170               		.cfi_offset 28, -2
 171               	/* prologue: function */
 172               	/* frame size = 0 */
 173               	/* stack size = 1 */
 174               	.L__stack_usage = 1
 175 0002 C82F      		mov r28,r24
 784:tmk_core/common/action.c ****     if (code == KC_NO) {
 176               		.loc 1 784 5 is_stmt 1 view .LVU24
 177               		.loc 1 784 8 is_stmt 0 view .LVU25
 178 0004 8823      		tst r24
 179 0006 01F4      		brne .+2
 180 0008 00C0      		rjmp .L5
 785:tmk_core/common/action.c ****         return;
 786:tmk_core/common/action.c ****     }
 787:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 788:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 181               		.loc 1 788 10 is_stmt 1 view .LVU26
 182               		.loc 1 788 13 is_stmt 0 view .LVU27
 183 000a 8238      		cpi r24,lo8(-126)
 184 000c 01F4      		brne .L8
 789:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 790:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 791:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 185               		.loc 1 791 9 is_stmt 1 view .LVU28
 186               		.loc 1 791 13 is_stmt 0 view .LVU29
 187 000e 0E94 0000 		call host_keyboard_leds
 188               	.LVL11:
 189               		.loc 1 791 12 view .LVU30
 190 0012 81FD      		sbrc r24,1
 191 0014 00C0      		rjmp .L5
 792:tmk_core/common/action.c **** #    endif
 793:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 192               		.loc 1 793 9 is_stmt 1 view .LVU31
 193 0016 89E3      		ldi r24,lo8(57)
 194 0018 0E94 0000 		call add_key
 195               	.LVL12:
 794:tmk_core/common/action.c ****         send_keyboard_report();
 196               		.loc 1 794 9 view .LVU32
 197 001c 0E94 0000 		call send_keyboard_report
 198               	.LVL13:
 795:tmk_core/common/action.c ****         wait_ms(100);
 199               		.loc 1 795 9 view .LVU33
 200               	.LBB34:
 201               	.LBI34:
 202               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 203               		.loc 2 166 1 view .LVU34
 204               	.LBB35:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 205               		.loc 2 168 2 view .LVU35
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 206               		.loc 2 172 2 view .LVU36
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 207               		.loc 2 173 2 view .LVU37
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 208               		.loc 2 174 2 view .LVU38
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 209               		.loc 2 184 3 view .LVU39
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 210               		.loc 2 187 2 view .LVU40
 211 0020 2FEF      		ldi r18,lo8(319999)
 212 0022 81EE      		ldi r24,hi8(319999)
 213 0024 94E0      		ldi r25,hlo8(319999)
 214 0026 2150      	1:	subi r18,1
 215 0028 8040      		sbci r24,0
 216 002a 9040      		sbci r25,0
 217 002c 01F4      		brne 1b
 218 002e 00C0      		rjmp .
 219 0030 0000      		nop
 220               	.LVL14:
 221               		.loc 2 187 2 is_stmt 0 view .LVU41
 222               	.LBE35:
 223               	.LBE34:
 796:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 224               		.loc 1 796 9 is_stmt 1 view .LVU42
 225 0032 89E3      		ldi r24,lo8(57)
 226               	.L20:
 797:tmk_core/common/action.c ****         send_keyboard_report();
 798:tmk_core/common/action.c ****     }
 799:tmk_core/common/action.c **** 
 800:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 801:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 802:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 803:tmk_core/common/action.c **** #    endif
 804:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:tmk_core/common/action.c ****         send_keyboard_report();
 806:tmk_core/common/action.c ****         wait_ms(100);
 807:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 227               		.loc 1 807 9 is_stmt 0 view .LVU43
 228 0034 0E94 0000 		call del_key
 229               	.LVL15:
 230               	.L21:
 808:tmk_core/common/action.c ****         send_keyboard_report();
 231               		.loc 1 808 9 is_stmt 1 view .LVU44
 232               	/* epilogue start */
 809:tmk_core/common/action.c ****     }
 810:tmk_core/common/action.c **** 
 811:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 812:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 813:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 814:tmk_core/common/action.c **** #    endif
 815:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 816:tmk_core/common/action.c ****         send_keyboard_report();
 817:tmk_core/common/action.c ****         wait_ms(100);
 818:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 819:tmk_core/common/action.c ****         send_keyboard_report();
 820:tmk_core/common/action.c ****     }
 821:tmk_core/common/action.c **** #endif
 822:tmk_core/common/action.c **** 
 823:tmk_core/common/action.c ****     else if
 824:tmk_core/common/action.c ****         IS_KEY(code) {
 825:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 826:tmk_core/common/action.c ****             if (command_proc(code)) return;
 827:tmk_core/common/action.c **** 
 828:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 829:tmk_core/common/action.c **** /* TODO: remove
 830:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 831:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 832:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 833:tmk_core/common/action.c **** 
 834:tmk_core/common/action.c ****             add_key(code);
 835:tmk_core/common/action.c ****             send_keyboard_report();
 836:tmk_core/common/action.c **** 
 837:tmk_core/common/action.c ****             set_mods(tmp_mods);
 838:tmk_core/common/action.c ****             send_keyboard_report();
 839:tmk_core/common/action.c ****             oneshot_cancel();
 840:tmk_core/common/action.c ****         } else
 841:tmk_core/common/action.c **** */
 842:tmk_core/common/action.c **** #endif
 843:tmk_core/common/action.c ****             {
 844:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 845:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 846:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 847:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 848:tmk_core/common/action.c ****                     del_key(code);
 849:tmk_core/common/action.c ****                     send_keyboard_report();
 850:tmk_core/common/action.c ****                 }
 851:tmk_core/common/action.c ****                 add_key(code);
 852:tmk_core/common/action.c ****                 send_keyboard_report();
 853:tmk_core/common/action.c ****             }
 854:tmk_core/common/action.c ****         }
 855:tmk_core/common/action.c ****     else if
 856:tmk_core/common/action.c ****         IS_MOD(code) {
 857:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 858:tmk_core/common/action.c ****             send_keyboard_report();
 859:tmk_core/common/action.c ****         }
 860:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 861:tmk_core/common/action.c ****     else if
 862:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 863:tmk_core/common/action.c ****     else if
 864:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 865:tmk_core/common/action.c **** #endif
 866:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 867:tmk_core/common/action.c ****     else if
 868:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 869:tmk_core/common/action.c ****             mousekey_on(code);
 870:tmk_core/common/action.c ****             mousekey_send();
 871:tmk_core/common/action.c ****         }
 872:tmk_core/common/action.c **** #endif
 873:tmk_core/common/action.c **** }
 233               		.loc 1 873 1 is_stmt 0 view .LVU45
 234 0038 CF91      		pop r28
 808:tmk_core/common/action.c ****         send_keyboard_report();
 235               		.loc 1 808 9 view .LVU46
 236 003a 0C94 0000 		jmp send_keyboard_report
 237               	.LVL16:
 238               	.L8:
 800:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 239               		.loc 1 800 10 is_stmt 1 view .LVU47
 800:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 240               		.loc 1 800 13 is_stmt 0 view .LVU48
 241 003e 8338      		cpi r24,lo8(-125)
 242 0040 01F4      		brne .L10
 802:tmk_core/common/action.c **** #    endif
 243               		.loc 1 802 9 is_stmt 1 view .LVU49
 802:tmk_core/common/action.c **** #    endif
 244               		.loc 1 802 13 is_stmt 0 view .LVU50
 245 0042 0E94 0000 		call host_keyboard_leds
 246               	.LVL17:
 802:tmk_core/common/action.c **** #    endif
 247               		.loc 1 802 12 view .LVU51
 248 0046 80FD      		sbrc r24,0
 249 0048 00C0      		rjmp .L5
 804:tmk_core/common/action.c ****         send_keyboard_report();
 250               		.loc 1 804 9 is_stmt 1 view .LVU52
 251 004a 83E5      		ldi r24,lo8(83)
 252 004c 0E94 0000 		call add_key
 253               	.LVL18:
 805:tmk_core/common/action.c ****         wait_ms(100);
 254               		.loc 1 805 9 view .LVU53
 255 0050 0E94 0000 		call send_keyboard_report
 256               	.LVL19:
 806:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 257               		.loc 1 806 9 view .LVU54
 258               	.LBB36:
 259               	.LBI36:
 166:/usr/avr/include/util/delay.h **** {
 260               		.loc 2 166 1 view .LVU55
 261               	.LBB37:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 262               		.loc 2 168 2 view .LVU56
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263               		.loc 2 172 2 view .LVU57
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 264               		.loc 2 173 2 view .LVU58
 174:/usr/avr/include/util/delay.h **** 
 265               		.loc 2 174 2 view .LVU59
 184:/usr/avr/include/util/delay.h **** 	#endif
 266               		.loc 2 184 3 view .LVU60
 267               		.loc 2 187 2 view .LVU61
 268 0054 2FEF      		ldi r18,lo8(319999)
 269 0056 81EE      		ldi r24,hi8(319999)
 270 0058 94E0      		ldi r25,hlo8(319999)
 271 005a 2150      	1:	subi r18,1
 272 005c 8040      		sbci r24,0
 273 005e 9040      		sbci r25,0
 274 0060 01F4      		brne 1b
 275 0062 00C0      		rjmp .
 276 0064 0000      		nop
 277               	.LVL20:
 278               		.loc 2 187 2 is_stmt 0 view .LVU62
 279               	.LBE37:
 280               	.LBE36:
 807:tmk_core/common/action.c ****         send_keyboard_report();
 281               		.loc 1 807 9 is_stmt 1 view .LVU63
 282 0066 83E5      		ldi r24,lo8(83)
 283 0068 00C0      		rjmp .L20
 284               	.LVL21:
 285               	.L10:
 811:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 286               		.loc 1 811 10 view .LVU64
 811:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 287               		.loc 1 811 13 is_stmt 0 view .LVU65
 288 006a 8438      		cpi r24,lo8(-124)
 289 006c 01F4      		brne .L11
 813:tmk_core/common/action.c **** #    endif
 290               		.loc 1 813 9 is_stmt 1 view .LVU66
 813:tmk_core/common/action.c **** #    endif
 291               		.loc 1 813 13 is_stmt 0 view .LVU67
 292 006e 0E94 0000 		call host_keyboard_leds
 293               	.LVL22:
 813:tmk_core/common/action.c **** #    endif
 294               		.loc 1 813 12 view .LVU68
 295 0072 82FD      		sbrc r24,2
 296 0074 00C0      		rjmp .L5
 815:tmk_core/common/action.c ****         send_keyboard_report();
 297               		.loc 1 815 9 is_stmt 1 view .LVU69
 298 0076 87E4      		ldi r24,lo8(71)
 299 0078 0E94 0000 		call add_key
 300               	.LVL23:
 816:tmk_core/common/action.c ****         wait_ms(100);
 301               		.loc 1 816 9 view .LVU70
 302 007c 0E94 0000 		call send_keyboard_report
 303               	.LVL24:
 817:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 304               		.loc 1 817 9 view .LVU71
 305               	.LBB38:
 306               	.LBI38:
 166:/usr/avr/include/util/delay.h **** {
 307               		.loc 2 166 1 view .LVU72
 308               	.LBB39:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 309               		.loc 2 168 2 view .LVU73
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 310               		.loc 2 172 2 view .LVU74
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 311               		.loc 2 173 2 view .LVU75
 174:/usr/avr/include/util/delay.h **** 
 312               		.loc 2 174 2 view .LVU76
 184:/usr/avr/include/util/delay.h **** 	#endif
 313               		.loc 2 184 3 view .LVU77
 314               		.loc 2 187 2 view .LVU78
 315 0080 2FEF      		ldi r18,lo8(319999)
 316 0082 81EE      		ldi r24,hi8(319999)
 317 0084 94E0      		ldi r25,hlo8(319999)
 318 0086 2150      	1:	subi r18,1
 319 0088 8040      		sbci r24,0
 320 008a 9040      		sbci r25,0
 321 008c 01F4      		brne 1b
 322 008e 00C0      		rjmp .
 323 0090 0000      		nop
 324               	.LVL25:
 325               		.loc 2 187 2 is_stmt 0 view .LVU79
 326               	.LBE39:
 327               	.LBE38:
 818:tmk_core/common/action.c ****         send_keyboard_report();
 328               		.loc 1 818 9 is_stmt 1 view .LVU80
 329 0092 87E4      		ldi r24,lo8(71)
 330 0094 00C0      		rjmp .L20
 331               	.LVL26:
 332               	.L11:
 823:tmk_core/common/action.c ****         IS_KEY(code) {
 333               		.loc 1 823 10 view .LVU81
 824:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 334               		.loc 1 824 9 is_stmt 0 view .LVU82
 335 0096 8CEF      		ldi r24,lo8(-4)
 336               	.LVL27:
 824:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 337               		.loc 1 824 9 view .LVU83
 338 0098 8C0F      		add r24,r28
 339 009a 813A      		cpi r24,lo8(-95)
 340 009c 00F4      		brsh .L12
 826:tmk_core/common/action.c **** 
 341               		.loc 1 826 13 is_stmt 1 view .LVU84
 847:tmk_core/common/action.c ****                     del_key(code);
 342               		.loc 1 847 17 view .LVU85
 847:tmk_core/common/action.c ****                     del_key(code);
 343               		.loc 1 847 21 is_stmt 0 view .LVU86
 344 009e 6C2F      		mov r22,r28
 345 00a0 8091 0000 		lds r24,keyboard_report
 346 00a4 9091 0000 		lds r25,keyboard_report+1
 347 00a8 0E94 0000 		call is_key_pressed
 348               	.LVL28:
 847:tmk_core/common/action.c ****                     del_key(code);
 349               		.loc 1 847 20 view .LVU87
 350 00ac 8823      		tst r24
 351 00ae 01F0      		breq .L13
 848:tmk_core/common/action.c ****                     send_keyboard_report();
 352               		.loc 1 848 21 is_stmt 1 view .LVU88
 353 00b0 8C2F      		mov r24,r28
 354 00b2 0E94 0000 		call del_key
 355               	.LVL29:
 849:tmk_core/common/action.c ****                 }
 356               		.loc 1 849 21 view .LVU89
 357 00b6 0E94 0000 		call send_keyboard_report
 358               	.LVL30:
 359               	.L13:
 851:tmk_core/common/action.c ****                 send_keyboard_report();
 360               		.loc 1 851 17 view .LVU90
 361 00ba 8C2F      		mov r24,r28
 362 00bc 0E94 0000 		call add_key
 363               	.LVL31:
 852:tmk_core/common/action.c ****             }
 364               		.loc 1 852 17 view .LVU91
 365 00c0 00C0      		rjmp .L21
 366               	.L12:
 855:tmk_core/common/action.c ****         IS_MOD(code) {
 367               		.loc 1 855 10 view .LVU92
 856:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 368               		.loc 1 856 9 is_stmt 0 view .LVU93
 369 00c2 80E2      		ldi r24,lo8(32)
 370 00c4 8C0F      		add r24,r28
 371 00c6 8830      		cpi r24,lo8(8)
 372 00c8 00F4      		brsh .L14
 857:tmk_core/common/action.c ****             send_keyboard_report();
 373               		.loc 1 857 13 is_stmt 1 view .LVU94
 857:tmk_core/common/action.c ****             send_keyboard_report();
 374               		.loc 1 857 22 is_stmt 0 view .LVU95
 375 00ca C770      		andi r28,lo8(7)
 376               	.LVL32:
 857:tmk_core/common/action.c ****             send_keyboard_report();
 377               		.loc 1 857 13 view .LVU96
 378 00cc 81E0      		ldi r24,lo8(1)
 379 00ce 00C0      		rjmp 2f
 380               		1:
 381 00d0 880F      		lsl r24
 382               		2:
 383 00d2 CA95      		dec r28
 384 00d4 02F4      		brpl 1b
 385 00d6 0E94 0000 		call add_mods
 386               	.LVL33:
 858:tmk_core/common/action.c ****         }
 387               		.loc 1 858 13 is_stmt 1 view .LVU97
 388 00da 00C0      		rjmp .L21
 389               	.LVL34:
 390               	.L14:
 861:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 391               		.loc 1 861 10 view .LVU98
 862:tmk_core/common/action.c ****     else if
 392               		.loc 1 862 9 is_stmt 0 view .LVU99
 393 00dc EBE5      		ldi r30,lo8(91)
 394 00de EC0F      		add r30,r28
 395 00e0 E330      		cpi r30,lo8(3)
 396 00e2 00F4      		brsh .L15
 862:tmk_core/common/action.c ****     else if
 397               		.loc 1 862 27 is_stmt 1 view .LVU100
 398               	.LVL35:
 399               	.LBB40:
 400               	.LBI40:
 401               		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK
  34:tmk_core/common/report.h **** };
  35:tmk_core/common/report.h **** 
  36:tmk_core/common/report.h **** /* Mouse buttons */
  37:tmk_core/common/report.h **** enum mouse_buttons {
  38:tmk_core/common/report.h ****     MOUSE_BTN1 = (1 << 0),
  39:tmk_core/common/report.h ****     MOUSE_BTN2 = (1 << 1),
  40:tmk_core/common/report.h ****     MOUSE_BTN3 = (1 << 2),
  41:tmk_core/common/report.h ****     MOUSE_BTN4 = (1 << 3),
  42:tmk_core/common/report.h ****     MOUSE_BTN5 = (1 << 4)
  43:tmk_core/common/report.h **** };
  44:tmk_core/common/report.h **** 
  45:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  46:tmk_core/common/report.h ****  *
  47:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  48:tmk_core/common/report.h ****  */
  49:tmk_core/common/report.h **** enum consumer_usages {
  50:tmk_core/common/report.h ****     // 15.5 Display Controls
  51:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  52:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  53:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  54:tmk_core/common/report.h ****     // 15.7 Transport Controls
  55:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  56:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  57:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  58:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  59:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  60:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  61:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  62:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  63:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  64:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  65:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  66:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  67:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  68:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  69:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  70:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  71:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  72:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  73:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  74:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  75:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  76:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  77:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  78:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  79:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  80:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  81:tmk_core/common/report.h ****     AC_HOME                = 0x223,
  82:tmk_core/common/report.h ****     AC_BACK                = 0x224,
  83:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
  84:tmk_core/common/report.h ****     AC_STOP                = 0x226,
  85:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
  86:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
  87:tmk_core/common/report.h **** };
  88:tmk_core/common/report.h **** 
  89:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
  90:tmk_core/common/report.h ****  *
  91:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
  92:tmk_core/common/report.h ****  */
  93:tmk_core/common/report.h **** enum desktop_usages {
  94:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
  95:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN = 0x81,
  96:tmk_core/common/report.h ****     SYSTEM_SLEEP      = 0x82,
  97:tmk_core/common/report.h ****     SYSTEM_WAKE_UP    = 0x83
  98:tmk_core/common/report.h **** };
  99:tmk_core/common/report.h **** 
 100:tmk_core/common/report.h **** // clang-format on
 101:tmk_core/common/report.h **** 
 102:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 103:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 104:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 105:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 106:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 107:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 108:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 109:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 110:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 111:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 112:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 113:tmk_core/common/report.h **** #    else
 114:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 115:tmk_core/common/report.h **** #    endif
 116:tmk_core/common/report.h **** #endif
 117:tmk_core/common/report.h **** 
 118:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 119:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 120:tmk_core/common/report.h **** #else
 121:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 122:tmk_core/common/report.h **** #endif
 123:tmk_core/common/report.h **** 
 124:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 125:tmk_core/common/report.h **** 
 126:tmk_core/common/report.h **** /* VUSB hardcodes keyboard and mouse+extrakey only */
 127:tmk_core/common/report.h **** #if defined(PROTOCOL_VUSB)
 128:tmk_core/common/report.h **** #    undef KEYBOARD_SHARED_EP
 129:tmk_core/common/report.h **** #    undef MOUSE_SHARED_EP
 130:tmk_core/common/report.h **** #endif
 131:tmk_core/common/report.h **** 
 132:tmk_core/common/report.h **** #ifdef __cplusplus
 133:tmk_core/common/report.h **** extern "C" {
 134:tmk_core/common/report.h **** #endif
 135:tmk_core/common/report.h **** 
 136:tmk_core/common/report.h **** /*
 137:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 138:tmk_core/common/report.h ****  *
 139:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 140:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 141:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 142:tmk_core/common/report.h ****  *
 143:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 144:tmk_core/common/report.h ****  *
 145:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 146:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 147:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 148:tmk_core/common/report.h ****  *
 149:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 150:tmk_core/common/report.h ****  *
 151:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 152:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 153:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 154:tmk_core/common/report.h ****  *
 155:tmk_core/common/report.h ****  */
 156:tmk_core/common/report.h **** typedef union {
 157:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 158:tmk_core/common/report.h ****     struct {
 159:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 160:tmk_core/common/report.h ****         uint8_t report_id;
 161:tmk_core/common/report.h **** #endif
 162:tmk_core/common/report.h ****         uint8_t mods;
 163:tmk_core/common/report.h ****         uint8_t reserved;
 164:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 165:tmk_core/common/report.h ****     };
 166:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 167:tmk_core/common/report.h ****     struct nkro_report {
 168:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 169:tmk_core/common/report.h ****         uint8_t report_id;
 170:tmk_core/common/report.h **** #    endif
 171:tmk_core/common/report.h ****         uint8_t mods;
 172:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 173:tmk_core/common/report.h ****     } nkro;
 174:tmk_core/common/report.h **** #endif
 175:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 176:tmk_core/common/report.h **** 
 177:tmk_core/common/report.h **** typedef struct {
 178:tmk_core/common/report.h ****     uint8_t  report_id;
 179:tmk_core/common/report.h ****     uint16_t usage;
 180:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 181:tmk_core/common/report.h **** 
 182:tmk_core/common/report.h **** typedef struct {
 183:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 184:tmk_core/common/report.h ****     uint8_t report_id;
 185:tmk_core/common/report.h **** #endif
 186:tmk_core/common/report.h ****     uint8_t buttons;
 187:tmk_core/common/report.h ****     int8_t  x;
 188:tmk_core/common/report.h ****     int8_t  y;
 189:tmk_core/common/report.h ****     int8_t  v;
 190:tmk_core/common/report.h ****     int8_t  h;
 191:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 192:tmk_core/common/report.h **** 
 193:tmk_core/common/report.h **** typedef struct {
 194:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 195:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 196:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 197:tmk_core/common/report.h **** #    else
 198:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 199:tmk_core/common/report.h **** #    endif
 200:tmk_core/common/report.h **** #endif
 201:tmk_core/common/report.h **** 
 202:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 203:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 204:tmk_core/common/report.h **** #endif
 205:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 206:tmk_core/common/report.h **** 
 207:tmk_core/common/report.h **** /* keycode to system usage */
 208:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 402               		.loc 3 208 24 view .LVU101
 403               	.LBE40:
 209:tmk_core/common/report.h ****     switch (key) {
 404               		.loc 3 209 5 view .LVU102
 862:tmk_core/common/action.c ****     else if
 405               		.loc 1 862 27 is_stmt 0 view .LVU103
 406 00e4 F0E0      		ldi r31,0
 407 00e6 E050      		subi r30,lo8(-(CSWTCH.10))
 408 00e8 F040      		sbci r31,hi8(-(CSWTCH.10))
 409 00ea 8081      		ld r24,Z
 410 00ec 90E0      		ldi r25,0
 411               	/* epilogue start */
 412               		.loc 1 873 1 view .LVU104
 413 00ee CF91      		pop r28
 414               	.LVL36:
 862:tmk_core/common/action.c ****     else if
 415               		.loc 1 862 27 view .LVU105
 416 00f0 0C94 0000 		jmp host_system_send
 417               	.LVL37:
 418               	.L15:
 863:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 419               		.loc 1 863 10 is_stmt 1 view .LVU106
 864:tmk_core/common/action.c **** #endif
 420               		.loc 1 864 9 is_stmt 0 view .LVU107
 421 00f4 E8E5      		ldi r30,lo8(88)
 422 00f6 EC0F      		add r30,r28
 423 00f8 E731      		cpi r30,lo8(23)
 424 00fa 00F4      		brsh .L16
 864:tmk_core/common/action.c **** #endif
 425               		.loc 1 864 29 is_stmt 1 view .LVU108
 426               	.LVL38:
 427               	.LBB41:
 428               	.LBI41:
 210:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 211:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 212:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 213:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 214:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 215:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 216:tmk_core/common/report.h ****         default:
 217:tmk_core/common/report.h ****             return 0;
 218:tmk_core/common/report.h ****     }
 219:tmk_core/common/report.h **** }
 220:tmk_core/common/report.h **** 
 221:tmk_core/common/report.h **** /* keycode to consumer usage */
 222:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 429               		.loc 3 222 24 view .LVU109
 430               	.LBE41:
 223:tmk_core/common/report.h ****     switch (key) {
 431               		.loc 3 223 5 view .LVU110
 864:tmk_core/common/action.c **** #endif
 432               		.loc 1 864 29 is_stmt 0 view .LVU111
 433 00fc F0E0      		ldi r31,0
 434 00fe EE0F      		lsl r30
 435 0100 FF1F      		rol r31
 436 0102 E050      		subi r30,lo8(-(CSWTCH.11))
 437 0104 F040      		sbci r31,hi8(-(CSWTCH.11))
 438 0106 8081      		ld r24,Z
 439 0108 9181      		ldd r25,Z+1
 440               	/* epilogue start */
 441               		.loc 1 873 1 view .LVU112
 442 010a CF91      		pop r28
 443               	.LVL39:
 864:tmk_core/common/action.c **** #endif
 444               		.loc 1 864 29 view .LVU113
 445 010c 0C94 0000 		jmp host_consumer_send
 446               	.LVL40:
 447               	.L16:
 867:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 448               		.loc 1 867 10 is_stmt 1 view .LVU114
 868:tmk_core/common/action.c ****             mousekey_on(code);
 449               		.loc 1 868 9 is_stmt 0 view .LVU115
 450 0110 C03F      		cpi r28,lo8(-16)
 451 0112 00F0      		brlo .L5
 869:tmk_core/common/action.c ****             mousekey_send();
 452               		.loc 1 869 13 is_stmt 1 view .LVU116
 453 0114 8C2F      		mov r24,r28
 454 0116 0E94 0000 		call mousekey_on
 455               	.LVL41:
 870:tmk_core/common/action.c ****         }
 456               		.loc 1 870 13 view .LVU117
 457               	/* epilogue start */
 458               		.loc 1 873 1 is_stmt 0 view .LVU118
 459 011a CF91      		pop r28
 460               	.LVL42:
 870:tmk_core/common/action.c ****         }
 461               		.loc 1 870 13 view .LVU119
 462 011c 0C94 0000 		jmp mousekey_send
 463               	.LVL43:
 464               	.L5:
 465               	/* epilogue start */
 466               		.loc 1 873 1 view .LVU120
 467 0120 CF91      		pop r28
 468               	.LVL44:
 469               		.loc 1 873 1 view .LVU121
 470 0122 0895      		ret
 471               		.cfi_endproc
 472               	.LFE116:
 474               		.section	.text.unregister_code,"ax",@progbits
 475               	.global	unregister_code
 477               	unregister_code:
 478               	.LVL45:
 479               	.LFB117:
 874:tmk_core/common/action.c **** 
 875:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 876:tmk_core/common/action.c ****  *
 877:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 878:tmk_core/common/action.c ****  */
 879:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 480               		.loc 1 879 36 is_stmt 1 view -0
 481               		.cfi_startproc
 482               	/* prologue: function */
 483               	/* frame size = 0 */
 484               	/* stack size = 0 */
 485               	.L__stack_usage = 0
 880:tmk_core/common/action.c ****     if (code == KC_NO) {
 486               		.loc 1 880 5 view .LVU123
 487               		.loc 1 880 8 is_stmt 0 view .LVU124
 488 0000 8823      		tst r24
 489 0002 01F4      		brne .+2
 490 0004 00C0      		rjmp .L22
 881:tmk_core/common/action.c ****         return;
 882:tmk_core/common/action.c ****     }
 883:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 884:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 491               		.loc 1 884 10 is_stmt 1 view .LVU125
 492               		.loc 1 884 13 is_stmt 0 view .LVU126
 493 0006 8238      		cpi r24,lo8(-126)
 494 0008 01F4      		brne .L25
 885:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 886:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 887:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 495               		.loc 1 887 9 is_stmt 1 view .LVU127
 496               		.loc 1 887 15 is_stmt 0 view .LVU128
 497 000a 0E94 0000 		call host_keyboard_leds
 498               	.LVL46:
 499               		.loc 1 887 12 view .LVU129
 500 000e 81FF      		sbrs r24,1
 501 0010 00C0      		rjmp .L22
 888:tmk_core/common/action.c **** #    endif
 889:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 502               		.loc 1 889 9 is_stmt 1 view .LVU130
 503 0012 89E3      		ldi r24,lo8(57)
 504 0014 0E94 0000 		call add_key
 505               	.LVL47:
 890:tmk_core/common/action.c ****         send_keyboard_report();
 506               		.loc 1 890 9 view .LVU131
 507 0018 0E94 0000 		call send_keyboard_report
 508               	.LVL48:
 891:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 509               		.loc 1 891 9 view .LVU132
 510 001c 89E3      		ldi r24,lo8(57)
 511               	.L42:
 892:tmk_core/common/action.c ****         send_keyboard_report();
 893:tmk_core/common/action.c ****     }
 894:tmk_core/common/action.c **** 
 895:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 896:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 897:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 898:tmk_core/common/action.c **** #    endif
 899:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 900:tmk_core/common/action.c ****         send_keyboard_report();
 901:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 512               		.loc 1 901 9 is_stmt 0 view .LVU133
 513 001e 0E94 0000 		call del_key
 514               	.LVL49:
 515               	.L43:
 902:tmk_core/common/action.c ****         send_keyboard_report();
 516               		.loc 1 902 9 is_stmt 1 view .LVU134
 517 0022 0C94 0000 		jmp send_keyboard_report
 518               	.LVL50:
 519               	.L25:
 895:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 520               		.loc 1 895 10 view .LVU135
 895:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 521               		.loc 1 895 13 is_stmt 0 view .LVU136
 522 0026 8338      		cpi r24,lo8(-125)
 523 0028 01F4      		brne .L27
 897:tmk_core/common/action.c **** #    endif
 524               		.loc 1 897 9 is_stmt 1 view .LVU137
 897:tmk_core/common/action.c **** #    endif
 525               		.loc 1 897 15 is_stmt 0 view .LVU138
 526 002a 0E94 0000 		call host_keyboard_leds
 527               	.LVL51:
 897:tmk_core/common/action.c **** #    endif
 528               		.loc 1 897 12 view .LVU139
 529 002e 80FF      		sbrs r24,0
 530 0030 00C0      		rjmp .L22
 899:tmk_core/common/action.c ****         send_keyboard_report();
 531               		.loc 1 899 9 is_stmt 1 view .LVU140
 532 0032 83E5      		ldi r24,lo8(83)
 533 0034 0E94 0000 		call add_key
 534               	.LVL52:
 900:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 535               		.loc 1 900 9 view .LVU141
 536 0038 0E94 0000 		call send_keyboard_report
 537               	.LVL53:
 901:tmk_core/common/action.c ****         send_keyboard_report();
 538               		.loc 1 901 9 view .LVU142
 539 003c 83E5      		ldi r24,lo8(83)
 540 003e 00C0      		rjmp .L42
 541               	.LVL54:
 542               	.L27:
 903:tmk_core/common/action.c ****     }
 904:tmk_core/common/action.c **** 
 905:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 543               		.loc 1 905 10 view .LVU143
 544               		.loc 1 905 13 is_stmt 0 view .LVU144
 545 0040 8438      		cpi r24,lo8(-124)
 546 0042 01F4      		brne .L28
 906:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 907:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 547               		.loc 1 907 9 is_stmt 1 view .LVU145
 548               		.loc 1 907 15 is_stmt 0 view .LVU146
 549 0044 0E94 0000 		call host_keyboard_leds
 550               	.LVL55:
 551               		.loc 1 907 12 view .LVU147
 552 0048 82FF      		sbrs r24,2
 553 004a 00C0      		rjmp .L22
 908:tmk_core/common/action.c **** #    endif
 909:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 554               		.loc 1 909 9 is_stmt 1 view .LVU148
 555 004c 87E4      		ldi r24,lo8(71)
 556 004e 0E94 0000 		call add_key
 557               	.LVL56:
 910:tmk_core/common/action.c ****         send_keyboard_report();
 558               		.loc 1 910 9 view .LVU149
 559 0052 0E94 0000 		call send_keyboard_report
 560               	.LVL57:
 911:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 561               		.loc 1 911 9 view .LVU150
 562 0056 87E4      		ldi r24,lo8(71)
 563 0058 00C0      		rjmp .L42
 564               	.LVL58:
 565               	.L28:
 912:tmk_core/common/action.c ****         send_keyboard_report();
 913:tmk_core/common/action.c ****     }
 914:tmk_core/common/action.c **** #endif
 915:tmk_core/common/action.c **** 
 916:tmk_core/common/action.c ****     else if
 566               		.loc 1 916 10 view .LVU151
 917:tmk_core/common/action.c ****         IS_KEY(code) {
 567               		.loc 1 917 9 is_stmt 0 view .LVU152
 568 005a 9CEF      		ldi r25,lo8(-4)
 569 005c 980F      		add r25,r24
 570 005e 913A      		cpi r25,lo8(-95)
 571 0060 00F0      		brlo .L42
 918:tmk_core/common/action.c ****             del_key(code);
 919:tmk_core/common/action.c ****             send_keyboard_report();
 920:tmk_core/common/action.c ****         }
 921:tmk_core/common/action.c ****     else if
 572               		.loc 1 921 10 is_stmt 1 view .LVU153
 922:tmk_core/common/action.c ****         IS_MOD(code) {
 573               		.loc 1 922 9 is_stmt 0 view .LVU154
 574 0062 90E2      		ldi r25,lo8(32)
 575 0064 980F      		add r25,r24
 576 0066 9830      		cpi r25,lo8(8)
 577 0068 00F4      		brsh .L30
 923:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 578               		.loc 1 923 13 is_stmt 1 view .LVU155
 579               		.loc 1 923 22 is_stmt 0 view .LVU156
 580 006a 8770      		andi r24,lo8(7)
 581               	.LVL59:
 582               		.loc 1 923 13 view .LVU157
 583 006c 91E0      		ldi r25,lo8(1)
 584 006e 00C0      		rjmp 2f
 585               		1:
 586 0070 990F      		lsl r25
 587               		2:
 588 0072 8A95      		dec r24
 589 0074 02F4      		brpl 1b
 590 0076 892F      		mov r24,r25
 591 0078 0E94 0000 		call del_mods
 592               	.LVL60:
 924:tmk_core/common/action.c ****             send_keyboard_report();
 593               		.loc 1 924 13 is_stmt 1 view .LVU158
 594 007c 00C0      		rjmp .L43
 595               	.LVL61:
 596               	.L30:
 925:tmk_core/common/action.c ****         }
 926:tmk_core/common/action.c ****     else if
 597               		.loc 1 926 10 view .LVU159
 927:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 598               		.loc 1 927 9 is_stmt 0 view .LVU160
 599 007e 9BE5      		ldi r25,lo8(91)
 600 0080 980F      		add r25,r24
 601 0082 9330      		cpi r25,lo8(3)
 602 0084 00F4      		brsh .L31
 603               		.loc 1 927 27 is_stmt 1 discriminator 1 view .LVU161
 604 0086 90E0      		ldi r25,0
 605 0088 80E0      		ldi r24,0
 606               	.LVL62:
 607               		.loc 1 927 27 is_stmt 0 discriminator 1 view .LVU162
 608 008a 0C94 0000 		jmp host_system_send
 609               	.LVL63:
 610               	.L31:
 928:tmk_core/common/action.c ****     else if
 611               		.loc 1 928 10 is_stmt 1 view .LVU163
 929:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 612               		.loc 1 929 9 is_stmt 0 view .LVU164
 613 008e 98E5      		ldi r25,lo8(88)
 614 0090 980F      		add r25,r24
 615 0092 9731      		cpi r25,lo8(23)
 616 0094 00F4      		brsh .L32
 617               		.loc 1 929 29 is_stmt 1 discriminator 1 view .LVU165
 618 0096 90E0      		ldi r25,0
 619 0098 80E0      		ldi r24,0
 620               	.LVL64:
 621               		.loc 1 929 29 is_stmt 0 discriminator 1 view .LVU166
 622 009a 0C94 0000 		jmp host_consumer_send
 623               	.LVL65:
 624               	.L32:
 930:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 931:tmk_core/common/action.c ****     else if
 625               		.loc 1 931 10 is_stmt 1 view .LVU167
 932:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 626               		.loc 1 932 9 is_stmt 0 view .LVU168
 627 009e 803F      		cpi r24,lo8(-16)
 628 00a0 00F0      		brlo .L22
 933:tmk_core/common/action.c ****             mousekey_off(code);
 629               		.loc 1 933 13 is_stmt 1 view .LVU169
 630 00a2 0E94 0000 		call mousekey_off
 631               	.LVL66:
 934:tmk_core/common/action.c ****             mousekey_send();
 632               		.loc 1 934 13 view .LVU170
 633 00a6 0C94 0000 		jmp mousekey_send
 634               	.LVL67:
 635               	.L22:
 636               	/* epilogue start */
 935:tmk_core/common/action.c ****         }
 936:tmk_core/common/action.c **** #endif
 937:tmk_core/common/action.c **** }
 637               		.loc 1 937 1 is_stmt 0 view .LVU171
 638 00aa 0895      		ret
 639               		.cfi_endproc
 640               	.LFE117:
 642               		.section	.text.tap_code,"ax",@progbits
 643               	.global	tap_code
 645               	tap_code:
 646               	.LVL68:
 647               	.LFB118:
 938:tmk_core/common/action.c **** 
 939:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 940:tmk_core/common/action.c ****  *
 941:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 942:tmk_core/common/action.c ****  */
 943:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 648               		.loc 1 943 29 is_stmt 1 view -0
 649               		.cfi_startproc
 650               		.loc 1 943 29 is_stmt 0 view .LVU173
 651 0000 CF93      		push r28
 652               	.LCFI5:
 653               		.cfi_def_cfa_offset 3
 654               		.cfi_offset 28, -2
 655               	/* prologue: function */
 656               	/* frame size = 0 */
 657               	/* stack size = 1 */
 658               	.L__stack_usage = 1
 659 0002 C82F      		mov r28,r24
 944:tmk_core/common/action.c ****     register_code(code);
 660               		.loc 1 944 5 is_stmt 1 view .LVU174
 661 0004 0E94 0000 		call register_code
 662               	.LVL69:
 945:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 663               		.loc 1 945 5 view .LVU175
 664               		.loc 1 945 8 is_stmt 0 view .LVU176
 665 0008 C933      		cpi r28,lo8(57)
 666 000a 01F4      		brne .L46
 946:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 667               		.loc 1 946 9 is_stmt 1 view .LVU177
 668               	.LVL70:
 669               	.LBB42:
 670               	.LBI42:
 166:/usr/avr/include/util/delay.h **** {
 671               		.loc 2 166 1 view .LVU178
 672               	.LBB43:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 673               		.loc 2 168 2 view .LVU179
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 674               		.loc 2 172 2 view .LVU180
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 675               		.loc 2 173 2 view .LVU181
 174:/usr/avr/include/util/delay.h **** 
 676               		.loc 2 174 2 view .LVU182
 184:/usr/avr/include/util/delay.h **** 	#endif
 677               		.loc 2 184 3 view .LVU183
 678               		.loc 2 187 2 view .LVU184
 679 000c 2FEF      		ldi r18,lo8(255999)
 680 000e 87EE      		ldi r24,hi8(255999)
 681 0010 93E0      		ldi r25,hlo8(255999)
 682 0012 2150      	1:	subi r18,1
 683 0014 8040      		sbci r24,0
 684 0016 9040      		sbci r25,0
 685 0018 01F4      		brne 1b
 686 001a 00C0      		rjmp .
 687 001c 0000      		nop
 688               	.LVL71:
 689               	.L46:
 690               		.loc 2 187 2 is_stmt 0 view .LVU185
 691               	.LBE43:
 692               	.LBE42:
 947:tmk_core/common/action.c ****     } else {
 948:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 949:tmk_core/common/action.c ****     }
 950:tmk_core/common/action.c ****     unregister_code(code);
 693               		.loc 1 950 5 is_stmt 1 view .LVU186
 694 001e 8C2F      		mov r24,r28
 695               	/* epilogue start */
 951:tmk_core/common/action.c **** }
 696               		.loc 1 951 1 is_stmt 0 view .LVU187
 697 0020 CF91      		pop r28
 698               	.LVL72:
 950:tmk_core/common/action.c **** }
 699               		.loc 1 950 5 view .LVU188
 700 0022 0C94 0000 		jmp unregister_code
 701               	.LVL73:
 950:tmk_core/common/action.c **** }
 702               		.loc 1 950 5 view .LVU189
 703               		.cfi_endproc
 704               	.LFE118:
 706               		.section	.text.register_mods,"ax",@progbits
 707               	.global	register_mods
 709               	register_mods:
 710               	.LVL74:
 711               	.LFB119:
 952:tmk_core/common/action.c **** 
 953:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 954:tmk_core/common/action.c ****  *
 955:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 956:tmk_core/common/action.c ****  */
 957:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 712               		.loc 1 957 34 is_stmt 1 view -0
 713               		.cfi_startproc
 714               	/* prologue: function */
 715               	/* frame size = 0 */
 716               	/* stack size = 0 */
 717               	.L__stack_usage = 0
 958:tmk_core/common/action.c ****     if (mods) {
 718               		.loc 1 958 5 view .LVU191
 719               		.loc 1 958 8 is_stmt 0 view .LVU192
 720 0000 8823      		tst r24
 721 0002 01F0      		breq .L47
 959:tmk_core/common/action.c ****         add_mods(mods);
 722               		.loc 1 959 9 is_stmt 1 view .LVU193
 723 0004 0E94 0000 		call add_mods
 724               	.LVL75:
 960:tmk_core/common/action.c ****         send_keyboard_report();
 725               		.loc 1 960 9 view .LVU194
 726 0008 0C94 0000 		jmp send_keyboard_report
 727               	.LVL76:
 728               	.L47:
 729               	/* epilogue start */
 961:tmk_core/common/action.c ****     }
 962:tmk_core/common/action.c **** }
 730               		.loc 1 962 1 is_stmt 0 view .LVU195
 731 000c 0895      		ret
 732               		.cfi_endproc
 733               	.LFE119:
 735               		.section	.text.unregister_mods,"ax",@progbits
 736               	.global	unregister_mods
 738               	unregister_mods:
 739               	.LVL77:
 740               	.LFB120:
 963:tmk_core/common/action.c **** 
 964:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 965:tmk_core/common/action.c ****  *
 966:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 967:tmk_core/common/action.c ****  */
 968:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 741               		.loc 1 968 36 is_stmt 1 view -0
 742               		.cfi_startproc
 743               	/* prologue: function */
 744               	/* frame size = 0 */
 745               	/* stack size = 0 */
 746               	.L__stack_usage = 0
 969:tmk_core/common/action.c ****     if (mods) {
 747               		.loc 1 969 5 view .LVU197
 748               		.loc 1 969 8 is_stmt 0 view .LVU198
 749 0000 8823      		tst r24
 750 0002 01F0      		breq .L49
 970:tmk_core/common/action.c ****         del_mods(mods);
 751               		.loc 1 970 9 is_stmt 1 view .LVU199
 752 0004 0E94 0000 		call del_mods
 753               	.LVL78:
 971:tmk_core/common/action.c ****         send_keyboard_report();
 754               		.loc 1 971 9 view .LVU200
 755 0008 0C94 0000 		jmp send_keyboard_report
 756               	.LVL79:
 757               	.L49:
 758               	/* epilogue start */
 972:tmk_core/common/action.c ****     }
 973:tmk_core/common/action.c **** }
 759               		.loc 1 973 1 is_stmt 0 view .LVU201
 760 000c 0895      		ret
 761               		.cfi_endproc
 762               	.LFE120:
 764               		.section	.text.process_action,"ax",@progbits
 765               	.global	process_action
 767               	process_action:
 768               	.LVL80:
 769               	.LFB115:
 248:tmk_core/common/action.c ****     keyevent_t event = record->event;
 770               		.loc 1 248 59 is_stmt 1 view -0
 771               		.cfi_startproc
 248:tmk_core/common/action.c ****     keyevent_t event = record->event;
 772               		.loc 1 248 59 is_stmt 0 view .LVU203
 773 0000 BF92      		push r11
 774               	.LCFI6:
 775               		.cfi_def_cfa_offset 3
 776               		.cfi_offset 11, -2
 777 0002 CF92      		push r12
 778               	.LCFI7:
 779               		.cfi_def_cfa_offset 4
 780               		.cfi_offset 12, -3
 781 0004 DF92      		push r13
 782               	.LCFI8:
 783               		.cfi_def_cfa_offset 5
 784               		.cfi_offset 13, -4
 785 0006 EF92      		push r14
 786               	.LCFI9:
 787               		.cfi_def_cfa_offset 6
 788               		.cfi_offset 14, -5
 789 0008 FF92      		push r15
 790               	.LCFI10:
 791               		.cfi_def_cfa_offset 7
 792               		.cfi_offset 15, -6
 793 000a 0F93      		push r16
 794               	.LCFI11:
 795               		.cfi_def_cfa_offset 8
 796               		.cfi_offset 16, -7
 797 000c 1F93      		push r17
 798               	.LCFI12:
 799               		.cfi_def_cfa_offset 9
 800               		.cfi_offset 17, -8
 801 000e CF93      		push r28
 802               	.LCFI13:
 803               		.cfi_def_cfa_offset 10
 804               		.cfi_offset 28, -9
 805 0010 DF93      		push r29
 806               	.LCFI14:
 807               		.cfi_def_cfa_offset 11
 808               		.cfi_offset 29, -10
 809               	/* prologue: function */
 810               	/* frame size = 0 */
 811               	/* stack size = 9 */
 812               	.L__stack_usage = 9
 813 0012 6C01      		movw r12,r24
 814 0014 D62F      		mov r29,r22
 248:tmk_core/common/action.c ****     keyevent_t event = record->event;
 815               		.loc 1 248 59 view .LVU204
 816 0016 C72F      		mov r28,r23
 249:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 817               		.loc 1 249 5 is_stmt 1 view .LVU205
 818               	.LVL81:
 251:tmk_core/common/action.c **** #endif
 819               		.loc 1 251 5 view .LVU206
 251:tmk_core/common/action.c **** #endif
 820               		.loc 1 251 36 is_stmt 0 view .LVU207
 821 0018 FC01      		movw r30,r24
 822 001a 0581      		ldd r16,Z+5
 823 001c 0295      		swap r16
 824 001e 0F70      		andi r16,lo8(15)
 825               	.LVL82:
 254:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 826               		.loc 1 254 5 is_stmt 1 view .LVU208
 254:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 827               		.loc 1 254 14 is_stmt 0 view .LVU209
 828 0020 1281      		ldd r17,Z+2
 254:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 829               		.loc 1 254 8 view .LVU210
 830 0022 1111      		cpse r17,__zero_reg__
 256:tmk_core/common/action.c ****     }
 831               		.loc 1 256 9 is_stmt 1 view .LVU211
 832 0024 0E94 0000 		call clear_weak_mods
 833               	.LVL83:
 834               	.L52:
 260:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 835               		.loc 1 260 5 view .LVU212
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 836               		.loc 1 262 5 view .LVU213
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 837               		.loc 1 262 9 is_stmt 0 view .LVU214
 838 0028 0E94 0000 		call is_oneshot_layer_active
 839               	.LVL84:
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 840               		.loc 1 262 9 view .LVU215
 841 002c E82E      		mov r14,r24
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 842               		.loc 1 262 8 view .LVU216
 843 002e 8823      		tst r24
 844 0030 01F0      		breq .L53
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 845               		.loc 1 262 35 discriminator 1 view .LVU217
 846 0032 1123      		tst r17
 847 0034 01F0      		breq .L132
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 848               		.loc 1 262 71 discriminator 2 view .LVU218
 849 0036 8C2F      		mov r24,r28
 850 0038 807F      		andi r24,lo8(-16)
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 851               		.loc 1 262 52 discriminator 2 view .LVU219
 852 003a 8034      		cpi r24,lo8(64)
 853 003c 01F0      		breq .L54
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 854               		.loc 1 262 87 discriminator 3 view .LVU220
 855 003e 80E2      		ldi r24,lo8(32)
 856               	.LVL85:
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 857               		.loc 1 262 87 discriminator 3 view .LVU221
 858 0040 8D0F      		add r24,r29
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 859               		.loc 1 262 84 discriminator 3 view .LVU222
 860 0042 8830      		cpi r24,lo8(8)
 861 0044 00F0      		brlo .L132
 862               	.L54:
 267:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 863               		.loc 1 267 9 is_stmt 1 view .LVU223
 864 0046 82E0      		ldi r24,lo8(2)
 865 0048 0E94 0000 		call clear_oneshot_layer_state
 866               	.LVL86:
 268:tmk_core/common/action.c ****     }
 867               		.loc 1 268 9 view .LVU224
 268:tmk_core/common/action.c ****     }
 868               		.loc 1 268 31 is_stmt 0 view .LVU225
 869 004c 0E94 0000 		call is_oneshot_layer_active
 870               	.LVL87:
 268:tmk_core/common/action.c ****     }
 871               		.loc 1 268 9 view .LVU226
 872 0050 91E0      		ldi r25,lo8(1)
 873 0052 E82E      		mov r14,r24
 874 0054 E926      		eor r14,r25
 875               	.LVL88:
 876               	.L53:
 272:tmk_core/common/action.c ****         /* Key and Mods */
 877               		.loc 1 272 5 is_stmt 1 view .LVU227
 272:tmk_core/common/action.c ****         /* Key and Mods */
 878               		.loc 1 272 24 is_stmt 0 view .LVU228
 879 0056 BC2E      		mov r11,r28
 880 0058 B294      		swap r11
 881 005a 9FE0      		ldi r25,lo8(15)
 882 005c B922      		and r11,r25
 272:tmk_core/common/action.c ****         /* Key and Mods */
 883               		.loc 1 272 5 view .LVU229
 884 005e EB2D      		mov r30,r11
 885 0060 F0E0      		ldi r31,0
 886 0062 E050      		subi r30,lo8(-(gs(.L57)))
 887 0064 F040      		sbci r31,hi8(-(gs(.L57)))
 888 0066 0C94 0000 		jmp __tablejump2__
 889               		.section	.jumptables.gcc.process_action,"a",@progbits
 890               		.p2align	1
 891               	.L57:
 892 0000 0000      		.word gs(.L65)
 893 0002 0000      		.word gs(.L65)
 894 0004 0000      		.word gs(.L64)
 895 0006 0000      		.word gs(.L64)
 896 0008 0000      		.word gs(.L63)
 897 000a 0000      		.word gs(.L62)
 898 000c 0000      		.word gs(.L55)
 899 000e 0000      		.word gs(.L55)
 900 0010 0000      		.word gs(.L61)
 901 0012 0000      		.word gs(.L60)
 902 0014 0000      		.word gs(.L59)
 903 0016 0000      		.word gs(.L59)
 904 0018 0000      		.word gs(.L58)
 905 001a 0000      		.word gs(.L55)
 906 001c 0000      		.word gs(.L55)
 907 001e 0000      		.word gs(.L56)
 908               		.section	.text.process_action
 909               	.LVL89:
 910               	.L132:
 260:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 911               		.loc 1 260 10 view .LVU230
 912 006a E12C      		mov r14,__zero_reg__
 913 006c 00C0      		rjmp .L53
 914               	.LVL90:
 915               	.L65:
 916               	.LBB44:
 276:tmk_core/common/action.c ****             if (event.pressed) {
 917               		.loc 1 276 13 is_stmt 1 view .LVU231
 918 006e 0C2F      		mov r16,r28
 919               	.LVL91:
 276:tmk_core/common/action.c ****             if (event.pressed) {
 920               		.loc 1 276 13 is_stmt 0 view .LVU232
 921 0070 0F70      		andi r16,lo8(15)
 276:tmk_core/common/action.c ****             if (event.pressed) {
 922               		.loc 1 276 44 view .LVU233
 923 0072 C07F      		andi r28,lo8(-16)
 924               	.LVL92:
 276:tmk_core/common/action.c ****             if (event.pressed) {
 925               		.loc 1 276 21 view .LVU234
 926 0074 01F0      		breq .L66
 276:tmk_core/common/action.c ****             if (event.pressed) {
 927               		.loc 1 276 21 discriminator 2 view .LVU235
 928 0076 0295      		swap r16
 929 0078 007F      		andi r16,lo8(-16)
 930               	.L66:
 931               	.LVL93:
 277:tmk_core/common/action.c ****                 if (mods) {
 932               		.loc 1 277 13 is_stmt 1 discriminator 4 view .LVU236
 277:tmk_core/common/action.c ****                 if (mods) {
 933               		.loc 1 277 16 is_stmt 0 discriminator 4 view .LVU237
 934 007a 1123      		tst r17
 935 007c 01F0      		breq .L67
 278:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 936               		.loc 1 278 17 is_stmt 1 view .LVU238
 278:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 937               		.loc 1 278 20 is_stmt 0 view .LVU239
 938 007e 0023      		tst r16
 939 0080 01F0      		breq .L165
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 940               		.loc 1 279 21 is_stmt 1 view .LVU240
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 941               		.loc 1 279 25 is_stmt 0 view .LVU241
 942 0082 80E2      		ldi r24,lo8(32)
 943 0084 8D0F      		add r24,r29
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 944               		.loc 1 279 24 view .LVU242
 945 0086 8830      		cpi r24,lo8(8)
 946 0088 00F0      		brlo .L69
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 947               		.loc 1 279 49 discriminator 1 view .LVU243
 948 008a D111      		cpse r29,__zero_reg__
 949 008c 00C0      		rjmp .L70
 950               	.L69:
 283:tmk_core/common/action.c ****                     } else {
 951               		.loc 1 283 25 is_stmt 1 view .LVU244
 952 008e 802F      		mov r24,r16
 953 0090 0E94 0000 		call add_mods
 954               	.LVL94:
 955               	.L71:
 287:tmk_core/common/action.c ****                 }
 956               		.loc 1 287 21 view .LVU245
 957 0094 0E94 0000 		call send_keyboard_report
 958               	.LVL95:
 289:tmk_core/common/action.c ****             } else {
 959               		.loc 1 289 17 view .LVU246
 960               	.L165:
 289:tmk_core/common/action.c ****             } else {
 961               		.loc 1 289 17 is_stmt 0 view .LVU247
 962               	.LBE44:
 602:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 963               		.loc 1 602 75 is_stmt 1 view .LVU248
 603:tmk_core/common/action.c ****                         } else {
 964               		.loc 1 603 29 view .LVU249
 965 0098 8D2F      		mov r24,r29
 966 009a 0E94 0000 		call register_code
 967               	.LVL96:
 968 009e 00C0      		rjmp .L55
 969               	.LVL97:
 970               	.L70:
 971               	.LBB45:
 285:tmk_core/common/action.c ****                     }
 972               		.loc 1 285 25 view .LVU250
 973 00a0 802F      		mov r24,r16
 974 00a2 0E94 0000 		call add_weak_mods
 975               	.LVL98:
 976 00a6 00C0      		rjmp .L71
 977               	.L67:
 291:tmk_core/common/action.c ****                 if (mods) {
 978               		.loc 1 291 17 view .LVU251
 979 00a8 8D2F      		mov r24,r29
 980 00aa 0E94 0000 		call unregister_code
 981               	.LVL99:
 292:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 982               		.loc 1 292 17 view .LVU252
 292:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 983               		.loc 1 292 20 is_stmt 0 view .LVU253
 984 00ae 0023      		tst r16
 985 00b0 01F0      		breq .L55
 293:tmk_core/common/action.c ****                         del_mods(mods);
 986               		.loc 1 293 21 is_stmt 1 view .LVU254
 293:tmk_core/common/action.c ****                         del_mods(mods);
 987               		.loc 1 293 25 is_stmt 0 view .LVU255
 988 00b2 80E2      		ldi r24,lo8(32)
 989 00b4 8D0F      		add r24,r29
 293:tmk_core/common/action.c ****                         del_mods(mods);
 990               		.loc 1 293 24 view .LVU256
 991 00b6 8830      		cpi r24,lo8(8)
 992 00b8 00F0      		brlo .L73
 293:tmk_core/common/action.c ****                         del_mods(mods);
 993               		.loc 1 293 49 discriminator 1 view .LVU257
 994 00ba D111      		cpse r29,__zero_reg__
 995 00bc 00C0      		rjmp .L74
 996               	.L73:
 294:tmk_core/common/action.c ****                     } else {
 997               		.loc 1 294 25 is_stmt 1 view .LVU258
 998 00be 802F      		mov r24,r16
 999 00c0 0E94 0000 		call del_mods
 1000               	.LVL100:
 1001               	.L75:
 298:tmk_core/common/action.c ****                 }
 1002               		.loc 1 298 21 view .LVU259
 1003 00c4 0E94 0000 		call send_keyboard_report
 1004               	.LVL101:
 1005               	.L55:
 298:tmk_core/common/action.c ****                 }
 1006               		.loc 1 298 21 is_stmt 0 view .LVU260
 1007               	.LBE45:
 717:tmk_core/common/action.c ****         case ACT_LAYER:
 1008               		.loc 1 717 5 is_stmt 1 view .LVU261
 1009 00c8 2B2D      		mov r18,r11
 1010 00ca 2850      		subi r18,8
 1011 00cc 330B      		sbc r19,r19
 1012 00ce 2430      		cpi r18,4
 1013 00d0 3105      		cpc r19,__zero_reg__
 1014 00d2 00F4      		brsh .L127
 724:tmk_core/common/action.c ****             break;
 1015               		.loc 1 724 13 view .LVU262
 1016 00d4 0E94 0000 		call host_keyboard_leds
 1017               	.LVL102:
 1018 00d8 0E94 0000 		call led_set
 1019               	.LVL103:
 725:tmk_core/common/action.c ****         default:
 1020               		.loc 1 725 13 view .LVU263
 1021               	.L127:
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 1022               		.loc 1 770 5 view .LVU264
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 1023               		.loc 1 770 8 is_stmt 0 view .LVU265
 1024 00dc EE20      		tst r14
 1025 00de 01F4      		brne .+2
 1026 00e0 00C0      		rjmp .L51
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 1027               		.loc 1 770 33 discriminator 1 view .LVU266
 1028 00e2 0E94 0000 		call get_oneshot_layer_state
 1029               	.LVL104:
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 1030               		.loc 1 770 28 discriminator 1 view .LVU267
 1031 00e6 80FD      		sbrc r24,0
 1032 00e8 00C0      		rjmp .L51
 771:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1033               		.loc 1 771 9 is_stmt 1 view .LVU268
 771:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1034               		.loc 1 771 31 is_stmt 0 view .LVU269
 1035 00ea F601      		movw r30,r12
 1036 00ec 1282      		std Z+2,__zero_reg__
 772:tmk_core/common/action.c ****         process_record(record);
 1037               		.loc 1 772 9 is_stmt 1 view .LVU270
 1038 00ee 0E94 0000 		call get_oneshot_layer
 1039               	.LVL105:
 1040 00f2 0E94 0000 		call layer_on
 1041               	.LVL106:
 773:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1042               		.loc 1 773 9 view .LVU271
 1043 00f6 C601      		movw r24,r12
 1044 00f8 0E94 0000 		call process_record
 1045               	.LVL107:
 774:tmk_core/common/action.c ****     }
 1046               		.loc 1 774 9 view .LVU272
 1047 00fc 0E94 0000 		call get_oneshot_layer
 1048               	.LVL108:
 1049               	/* epilogue start */
 777:tmk_core/common/action.c **** 
 1050               		.loc 1 777 1 is_stmt 0 view .LVU273
 1051 0100 DF91      		pop r29
 1052               	.LVL109:
 777:tmk_core/common/action.c **** 
 1053               		.loc 1 777 1 view .LVU274
 1054 0102 CF91      		pop r28
 777:tmk_core/common/action.c **** 
 1055               		.loc 1 777 1 view .LVU275
 1056 0104 1F91      		pop r17
 1057 0106 0F91      		pop r16
 1058 0108 FF90      		pop r15
 1059 010a EF90      		pop r14
 1060               	.LVL110:
 777:tmk_core/common/action.c **** 
 1061               		.loc 1 777 1 view .LVU276
 1062 010c DF90      		pop r13
 1063 010e CF90      		pop r12
 1064               	.LVL111:
 777:tmk_core/common/action.c **** 
 1065               		.loc 1 777 1 view .LVU277
 1066 0110 BF90      		pop r11
 774:tmk_core/common/action.c ****     }
 1067               		.loc 1 774 9 view .LVU278
 1068 0112 0C94 0000 		jmp layer_off
 1069               	.LVL112:
 1070               	.L74:
 1071               	.LBB46:
 296:tmk_core/common/action.c ****                     }
 1072               		.loc 1 296 25 is_stmt 1 view .LVU279
 1073 0116 802F      		mov r24,r16
 1074 0118 0E94 0000 		call del_weak_mods
 1075               	.LVL113:
 1076 011c 00C0      		rjmp .L75
 1077               	.LVL114:
 1078               	.L64:
 296:tmk_core/common/action.c ****                     }
 1079               		.loc 1 296 25 is_stmt 0 view .LVU280
 1080               	.LBE46:
 1081               	.LBB47:
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1082               		.loc 1 305 13 is_stmt 1 view .LVU281
 1083 011e FC2F      		mov r31,r28
 1084 0120 FF70      		andi r31,lo8(15)
 1085 0122 FF2E      		mov r15,r31
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1086               		.loc 1 305 44 is_stmt 0 view .LVU282
 1087 0124 C07F      		andi r28,lo8(-16)
 1088               	.LVL115:
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1089               		.loc 1 305 21 view .LVU283
 1090 0126 C032      		cpi r28,lo8(32)
 1091 0128 01F0      		breq .L76
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1092               		.loc 1 305 21 discriminator 2 view .LVU284
 1093 012a F294      		swap r15
 1094 012c 80EF      		ldi r24,lo8(-16)
 1095 012e F822      		and r15,r24
 1096               	.L76:
 1097               	.LVL116:
 306:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1098               		.loc 1 306 13 is_stmt 1 discriminator 4 view .LVU285
 1099 0130 DD23      		tst r29
 1100 0132 01F0      		breq .L77
 1101 0134 D130      		cpi r29,lo8(1)
 1102 0136 01F0      		breq .L78
 361:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1103               		.loc 1 361 21 view .LVU286
 361:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1104               		.loc 1 361 24 is_stmt 0 view .LVU287
 1105 0138 1123      		tst r17
 1106 013a 01F0      		breq .L86
 362:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1107               		.loc 1 362 25 is_stmt 1 view .LVU288
 362:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1108               		.loc 1 362 28 is_stmt 0 view .LVU289
 1109 013c 0023      		tst r16
 1110 013e 01F0      		breq .L87
 364:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1111               		.loc 1 364 29 is_stmt 1 view .LVU290
 368:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1112               		.loc 1 368 33 is_stmt 0 view .LVU291
 1113 0140 F601      		movw r30,r12
 1114 0142 8581      		ldd r24,Z+5
 364:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1115               		.loc 1 364 32 view .LVU292
 1116 0144 80FF      		sbrs r24,0
 1117 0146 00C0      		rjmp .L165
 369:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 1118               		.loc 1 369 76 is_stmt 1 view .LVU293
 371:tmk_core/common/action.c ****                                 register_mods(mods);
 1119               		.loc 1 371 33 view .LVU294
 371:tmk_core/common/action.c ****                                 register_mods(mods);
 1120               		.loc 1 371 51 is_stmt 0 view .LVU295
 1121 0148 8F70      		andi r24,lo8(15)
 1122 014a 8583      		std Z+5,r24
 372:tmk_core/common/action.c ****                             } else
 1123               		.loc 1 372 33 is_stmt 1 view .LVU296
 1124 014c 00C0      		rjmp .L87
 1125               	.L77:
 310:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1126               		.loc 1 310 21 view .LVU297
 310:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1127               		.loc 1 310 24 is_stmt 0 view .LVU298
 1128 014e 1123      		tst r17
 1129 0150 01F0      		breq .L80
 311:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1130               		.loc 1 311 25 is_stmt 1 view .LVU299
 311:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1131               		.loc 1 311 28 is_stmt 0 view .LVU300
 1132 0152 0111      		cpse r16,__zero_reg__
 1133 0154 00C0      		rjmp .L81
 1134               	.L82:
 325:tmk_core/common/action.c ****                         }
 1135               		.loc 1 325 29 is_stmt 1 view .LVU301
 325:tmk_core/common/action.c ****                         }
 1136               		.loc 1 325 50 is_stmt 0 view .LVU302
 1137 0156 0E94 0000 		call get_oneshot_mods
 1138               	.LVL117:
 325:tmk_core/common/action.c ****                         }
 1139               		.loc 1 325 29 view .LVU303
 1140 015a 8F29      		or r24,r15
 1141               	.LVL118:
 1142               	.L164:
 325:tmk_core/common/action.c ****                         }
 1143               		.loc 1 325 29 view .LVU304
 1144               	.LBE47:
 529:tmk_core/common/action.c ****             } else {
 1145               		.loc 1 529 17 view .LVU305
 1146 015c 0E94 0000 		call register_mods
 1147               	.LVL119:
 1148 0160 00C0      		rjmp .L55
 1149               	.LVL120:
 1150               	.L81:
 1151               	.LBB50:
 314:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1152               		.loc 1 314 32 is_stmt 1 view .LVU306
 314:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1153               		.loc 1 314 35 is_stmt 0 view .LVU307
 1154 0162 0130      		cpi r16,lo8(1)
 1155 0164 01F4      		brne .L82
 315:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1156               		.loc 1 315 65 is_stmt 1 view .LVU308
 316:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1157               		.loc 1 316 29 view .LVU309
 316:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1158               		.loc 1 316 53 is_stmt 0 view .LVU310
 1159 0166 0E94 0000 		call get_oneshot_mods
 1160               	.LVL121:
 316:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1161               		.loc 1 316 29 view .LVU311
 1162 016a 8F29      		or r24,r15
 1163 016c 0E94 0000 		call set_oneshot_mods
 1164               	.LVL122:
 1165 0170 00C0      		rjmp .L55
 1166               	.L80:
 328:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1167               		.loc 1 328 25 is_stmt 1 view .LVU312
 328:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1168               		.loc 1 328 28 is_stmt 0 view .LVU313
 1169 0172 0111      		cpse r16,__zero_reg__
 1170 0174 00C0      		rjmp .L83
 1171               	.L167:
 343:tmk_core/common/action.c ****                             unregister_mods(mods);
 1172               		.loc 1 343 29 is_stmt 1 view .LVU314
 1173 0176 0E94 0000 		call clear_oneshot_mods
 1174               	.LVL123:
 344:tmk_core/common/action.c ****                         }
 1175               		.loc 1 344 29 view .LVU315
 1176               	.L89:
 393:tmk_core/common/action.c ****                             unregister_mods(mods);
 1177               		.loc 1 393 67 view .LVU316
 394:tmk_core/common/action.c ****                         }
 1178               		.loc 1 394 29 view .LVU317
 1179 017a 8F2D      		mov r24,r15
 1180 017c 0E94 0000 		call unregister_mods
 1181               	.LVL124:
 1182 0180 00C0      		rjmp .L55
 1183               	.L83:
 331:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1184               		.loc 1 331 32 view .LVU318
 331:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1185               		.loc 1 331 35 is_stmt 0 view .LVU319
 1186 0182 0130      		cpi r16,lo8(1)
 1187 0184 01F4      		brne .+2
 1188 0186 00C0      		rjmp .L55
 1189 0188 00C0      		rjmp .L167
 1190               	.L78:
 350:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1191               		.loc 1 350 21 is_stmt 1 view .LVU320
 350:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1192               		.loc 1 350 24 is_stmt 0 view .LVU321
 1193 018a 1123      		tst r17
 1194 018c 01F0      		breq .L85
 351:tmk_core/common/action.c ****                             register_mods(mods);
 1195               		.loc 1 351 25 is_stmt 1 view .LVU322
 351:tmk_core/common/action.c ****                             register_mods(mods);
 1196               		.loc 1 351 28 is_stmt 0 view .LVU323
 1197 018e 0630      		cpi r16,lo8(6)
 1198 0190 00F0      		brlo .+2
 1199 0192 00C0      		rjmp .L55
 1200               	.L87:
 380:tmk_core/common/action.c ****                             register_mods(mods);
 1201               		.loc 1 380 67 is_stmt 1 view .LVU324
 381:tmk_core/common/action.c ****                         }
 1202               		.loc 1 381 29 view .LVU325
 1203 0194 8F2D      		mov r24,r15
 1204 0196 00C0      		rjmp .L164
 1205               	.L85:
 355:tmk_core/common/action.c ****                             unregister_mods(mods);
 1206               		.loc 1 355 25 view .LVU326
 355:tmk_core/common/action.c ****                             unregister_mods(mods);
 1207               		.loc 1 355 28 is_stmt 0 view .LVU327
 1208 0198 0530      		cpi r16,lo8(5)
 1209 019a 00F0      		brlo .+2
 1210 019c 00C0      		rjmp .L55
 1211 019e 00C0      		rjmp .L89
 1212               	.L86:
 384:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1213               		.loc 1 384 25 is_stmt 1 view .LVU328
 384:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1214               		.loc 1 384 28 is_stmt 0 view .LVU329
 1215 01a0 0023      		tst r16
 1216 01a2 01F0      		breq .L89
 385:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1217               		.loc 1 385 71 is_stmt 1 view .LVU330
 386:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1218               		.loc 1 386 29 view .LVU331
 386:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1219               		.loc 1 386 32 is_stmt 0 view .LVU332
 1220 01a4 D933      		cpi r29,lo8(57)
 1221 01a6 01F4      		brne .L126
 387:tmk_core/common/action.c ****                             } else {
 1222               		.loc 1 387 33 is_stmt 1 view .LVU333
 1223               	.LVL125:
 1224               	.LBB48:
 1225               	.LBI48:
 166:/usr/avr/include/util/delay.h **** {
 1226               		.loc 2 166 1 view .LVU334
 1227               	.LBB49:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1228               		.loc 2 168 2 view .LVU335
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1229               		.loc 2 172 2 view .LVU336
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1230               		.loc 2 173 2 view .LVU337
 174:/usr/avr/include/util/delay.h **** 
 1231               		.loc 2 174 2 view .LVU338
 184:/usr/avr/include/util/delay.h **** 	#endif
 1232               		.loc 2 184 3 view .LVU339
 1233               		.loc 2 187 2 view .LVU340
 1234 01a8 FFEF      		ldi r31,lo8(255999)
 1235 01aa 27EE      		ldi r18,hi8(255999)
 1236 01ac 33E0      		ldi r19,hlo8(255999)
 1237 01ae F150      	1:	subi r31,1
 1238 01b0 2040      		sbci r18,0
 1239 01b2 3040      		sbci r19,0
 1240 01b4 01F4      		brne 1b
 1241               	.LVL126:
 1242               	.L168:
 1243               		.loc 2 187 2 is_stmt 0 view .LVU341
 1244               	.LBE49:
 1245               	.LBE48:
 1246               	.LBE50:
 1247               	.LBB51:
 1248               	.LBB52:
 1249 01b6 00C0      		rjmp .
 1250 01b8 0000      		nop
 1251               	.L126:
 1252               	.LBE52:
 1253               	.LBE51:
 616:tmk_core/common/action.c ****                         } else {
 1254               		.loc 1 616 29 is_stmt 1 view .LVU342
 1255 01ba 8D2F      		mov r24,r29
 1256 01bc 0E94 0000 		call unregister_code
 1257               	.LVL127:
 1258 01c0 00C0      		rjmp .L55
 1259               	.L63:
 404:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1260               		.loc 1 404 13 view .LVU343
 404:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1261               		.loc 1 404 33 is_stmt 0 view .LVU344
 1262 01c2 8C2F      		mov r24,r28
 1263 01c4 8695      		lsr r24
 1264 01c6 8695      		lsr r24
 1265 01c8 8370      		andi r24,lo8(3)
 1266 01ca 01F0      		breq .L92
 1267 01cc 8130      		cpi r24,lo8(1)
 1268 01ce 01F0      		breq .+2
 1269 01d0 00C0      		rjmp .L55
 413:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1270               		.loc 1 413 21 is_stmt 1 view .LVU345
 414:tmk_core/common/action.c ****                     } else {
 1271               		.loc 1 414 25 is_stmt 0 view .LVU346
 1272 01d2 8D2F      		mov r24,r29
 1273 01d4 9C2F      		mov r25,r28
 1274 01d6 9370      		andi r25,lo8(3)
 413:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1275               		.loc 1 413 24 view .LVU347
 1276 01d8 1111      		cpse r17,__zero_reg__
 1277 01da 00C0      		rjmp .L166
 416:tmk_core/common/action.c ****                     }
 1278               		.loc 1 416 25 is_stmt 1 view .LVU348
 1279 01dc 90E0      		ldi r25,0
 1280 01de 80E0      		ldi r24,0
 1281               	.L166:
 1282 01e0 0E94 0000 		call host_consumer_send
 1283               	.LVL128:
 1284 01e4 00C0      		rjmp .L55
 1285               	.L92:
 406:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1286               		.loc 1 406 21 view .LVU349
 407:tmk_core/common/action.c ****                     } else {
 1287               		.loc 1 407 25 is_stmt 0 view .LVU350
 1288 01e6 8D2F      		mov r24,r29
 1289 01e8 9C2F      		mov r25,r28
 1290 01ea 9370      		andi r25,lo8(3)
 406:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1291               		.loc 1 406 24 view .LVU351
 1292 01ec 1111      		cpse r17,__zero_reg__
 1293 01ee 00C0      		rjmp .L161
 409:tmk_core/common/action.c ****                     }
 1294               		.loc 1 409 25 is_stmt 1 view .LVU352
 1295 01f0 90E0      		ldi r25,0
 1296 01f2 80E0      		ldi r24,0
 1297               	.L161:
 1298 01f4 0E94 0000 		call host_system_send
 1299               	.LVL129:
 1300 01f8 00C0      		rjmp .L55
 1301               	.L62:
 425:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1302               		.loc 1 425 13 view .LVU353
 426:tmk_core/common/action.c ****                 switch (action.key.code) {
 1303               		.loc 1 426 17 is_stmt 0 view .LVU354
 1304 01fa 8D2F      		mov r24,r29
 425:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1305               		.loc 1 425 16 view .LVU355
 1306 01fc 1123      		tst r17
 1307 01fe 01F0      		breq .L96
 426:tmk_core/common/action.c ****                 switch (action.key.code) {
 1308               		.loc 1 426 17 is_stmt 1 view .LVU356
 1309 0200 0E94 0000 		call mousekey_on
 1310               	.LVL130:
 427:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 1311               		.loc 1 427 17 view .LVU357
 448:tmk_core/common/action.c ****                         break;
 1312               		.loc 1 448 25 view .LVU358
 1313               	.L162:
 453:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 1314               		.loc 1 453 17 view .LVU359
 474:tmk_core/common/action.c ****                         break;
 1315               		.loc 1 474 25 view .LVU360
 1316 0204 0E94 0000 		call mousekey_send
 1317               	.LVL131:
 475:tmk_core/common/action.c ****                 }
 1318               		.loc 1 475 25 view .LVU361
 1319 0208 00C0      		rjmp .L55
 1320               	.L96:
 452:tmk_core/common/action.c ****                 switch (action.key.code) {
 1321               		.loc 1 452 17 view .LVU362
 1322 020a 0E94 0000 		call mousekey_off
 1323               	.LVL132:
 1324 020e 00C0      		rjmp .L162
 1325               	.L61:
 482:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1326               		.loc 1 482 13 view .LVU363
 482:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1327               		.loc 1 482 39 is_stmt 0 view .LVU364
 1328 0210 8C2F      		mov r24,r28
 1329 0212 8370      		andi r24,lo8(3)
 482:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1330               		.loc 1 482 16 view .LVU365
 1331 0214 01F0      		breq .+2
 1332 0216 00C0      		rjmp .L97
 484:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1333               		.loc 1 484 17 is_stmt 1 view .LVU366
 484:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1334               		.loc 1 484 20 is_stmt 0 view .LVU367
 1335 0218 1111      		cpse r17,__zero_reg__
 1336 021a 00C0      		rjmp .L55
 1337               	.LBB54:
 485:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1338               		.loc 1 485 21 is_stmt 1 view .LVU368
 1339               	.LVL133:
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1340               		.loc 1 486 21 view .LVU369
 485:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1341               		.loc 1 485 61 is_stmt 0 view .LVU370
 1342 021c 4D2F      		mov r20,r29
 1343 021e 4295      		swap r20
 1344 0220 4695      		lsr r20
 1345 0222 4770      		andi r20,lo8(7)
 485:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1346               		.loc 1 485 35 view .LVU371
 1347 0224 440F      		lsl r20
 1348 0226 440F      		lsl r20
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1349               		.loc 1 486 77 view .LVU372
 1350 0228 0D2F      		mov r16,r29
 1351               	.LVL134:
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1352               		.loc 1 486 77 view .LVU373
 1353 022a 0F70      		andi r16,lo8(15)
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1354               		.loc 1 486 44 view .LVU374
 1355 022c 10E0      		ldi r17,0
 1356               	.LVL135:
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1357               		.loc 1 486 44 view .LVU375
 1358 022e 30E0      		ldi r19,0
 1359 0230 20E0      		ldi r18,0
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1360               		.loc 1 486 35 view .LVU376
 1361 0232 042E      		mov r0,r20
 1362 0234 00C0      		rjmp 2f
 1363               		1:
 1364 0236 000F      		lsl r16
 1365 0238 111F      		rol r17
 1366 023a 221F      		rol r18
 1367 023c 331F      		rol r19
 1368               		2:
 1369 023e 0A94      		dec r0
 1370 0240 02F4      		brpl 1b
 1371               	.LVL136:
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1372               		.loc 1 487 21 is_stmt 1 view .LVU377
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1373               		.loc 1 487 104 is_stmt 0 view .LVU378
 1374 0242 60E0      		ldi r22,0
 1375 0244 70E0      		ldi r23,0
 1376 0246 CB01      		movw r24,r22
 1377 0248 D4FF      		sbrs r29,4
 1378 024a 00C0      		rjmp .L98
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1379               		.loc 1 487 94 discriminator 1 view .LVU379
 1380 024c 6FE0      		ldi r22,lo8(15)
 1381 024e 70E0      		ldi r23,0
 1382 0250 80E0      		ldi r24,0
 1383 0252 90E0      		ldi r25,0
 1384 0254 00C0      		rjmp 2f
 1385               		1:
 1386 0256 660F      		lsl r22
 1387 0258 771F      		rol r23
 1388 025a 881F      		rol r24
 1389 025c 991F      		rol r25
 1390               		2:
 1391 025e 4A95      		dec r20
 1392 0260 02F4      		brpl 1b
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1393               		.loc 1 487 104 discriminator 1 view .LVU380
 1394 0262 6095      		com r22
 1395 0264 7095      		com r23
 1396 0266 8095      		com r24
 1397 0268 9095      		com r25
 1398               	.L98:
 1399               	.LVL137:
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1400               		.loc 1 488 21 is_stmt 1 discriminator 4 view .LVU381
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1401               		.loc 1 488 47 is_stmt 0 discriminator 4 view .LVU382
 1402 026a C695      		lsr r28
 1403 026c C695      		lsr r28
 1404               	.LVL138:
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1405               		.loc 1 488 47 discriminator 4 view .LVU383
 1406 026e C370      		andi r28,lo8(3)
 1407 0270 602B      		or r22,r16
 1408               	.LVL139:
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1409               		.loc 1 488 47 discriminator 4 view .LVU384
 1410 0272 712B      		or r23,r17
 1411 0274 822B      		or r24,r18
 1412 0276 932B      		or r25,r19
 1413 0278 C230      		cpi r28,lo8(2)
 1414 027a 01F0      		breq .L99
 1415 027c 00F4      		brsh .L100
 1416 027e C130      		cpi r28,lo8(1)
 1417 0280 01F0      		breq .L101
 490:tmk_core/common/action.c ****                             break;
 1418               		.loc 1 490 29 is_stmt 1 view .LVU385
 1419 0282 0E94 0000 		call default_layer_and
 1420               	.LVL140:
 491:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1421               		.loc 1 491 29 view .LVU386
 1422 0286 00C0      		rjmp .L55
 1423               	.L101:
 493:tmk_core/common/action.c ****                             break;
 1424               		.loc 1 493 29 view .LVU387
 1425 0288 0E94 0000 		call default_layer_or
 1426               	.LVL141:
 494:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1427               		.loc 1 494 29 view .LVU388
 1428 028c 00C0      		rjmp .L55
 1429               	.L99:
 496:tmk_core/common/action.c ****                             break;
 1430               		.loc 1 496 29 view .LVU389
 1431 028e 0E94 0000 		call default_layer_xor
 1432               	.LVL142:
 497:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1433               		.loc 1 497 29 view .LVU390
 1434 0292 00C0      		rjmp .L55
 1435               	.L100:
 499:tmk_core/common/action.c ****                             break;
 1436               		.loc 1 499 29 view .LVU391
 1437 0294 0E94 0000 		call default_layer_set
 1438               	.LVL143:
 500:tmk_core/common/action.c ****                     }
 1439               		.loc 1 500 29 view .LVU392
 1440 0298 00C0      		rjmp .L55
 1441               	.LVL144:
 1442               	.L97:
 500:tmk_core/common/action.c ****                     }
 1443               		.loc 1 500 29 is_stmt 0 view .LVU393
 1444               	.LBE54:
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1445               		.loc 1 505 17 is_stmt 1 view .LVU394
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1446               		.loc 1 505 21 is_stmt 0 view .LVU395
 1447 029a 8695      		lsr r24
 1448 029c 1123      		tst r17
 1449 029e 01F0      		breq .L103
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1450               		.loc 1 505 21 discriminator 1 view .LVU396
 1451 02a0 8C2F      		mov r24,r28
 1452 02a2 8170      		andi r24,lo8(1)
 1453               	.L103:
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1454               		.loc 1 505 20 discriminator 4 view .LVU397
 1455 02a4 8823      		tst r24
 1456 02a6 01F4      		brne .+2
 1457 02a8 00C0      		rjmp .L55
 1458               	.LBB55:
 506:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1459               		.loc 1 506 21 is_stmt 1 view .LVU398
 1460               	.LVL145:
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1461               		.loc 1 507 21 view .LVU399
 506:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1462               		.loc 1 506 61 is_stmt 0 view .LVU400
 1463 02aa 4D2F      		mov r20,r29
 1464 02ac 4295      		swap r20
 1465 02ae 4695      		lsr r20
 1466 02b0 4770      		andi r20,lo8(7)
 506:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1467               		.loc 1 506 35 view .LVU401
 1468 02b2 440F      		lsl r20
 1469 02b4 440F      		lsl r20
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1470               		.loc 1 507 77 view .LVU402
 1471 02b6 0D2F      		mov r16,r29
 1472               	.LVL146:
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1473               		.loc 1 507 77 view .LVU403
 1474 02b8 0F70      		andi r16,lo8(15)
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1475               		.loc 1 507 44 view .LVU404
 1476 02ba 10E0      		ldi r17,0
 1477               	.LVL147:
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1478               		.loc 1 507 44 view .LVU405
 1479 02bc 30E0      		ldi r19,0
 1480 02be 20E0      		ldi r18,0
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1481               		.loc 1 507 35 view .LVU406
 1482 02c0 042E      		mov r0,r20
 1483 02c2 00C0      		rjmp 2f
 1484               		1:
 1485 02c4 000F      		lsl r16
 1486 02c6 111F      		rol r17
 1487 02c8 221F      		rol r18
 1488 02ca 331F      		rol r19
 1489               		2:
 1490 02cc 0A94      		dec r0
 1491 02ce 02F4      		brpl 1b
 1492               	.LVL148:
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1493               		.loc 1 508 21 is_stmt 1 view .LVU407
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1494               		.loc 1 508 104 is_stmt 0 view .LVU408
 1495 02d0 60E0      		ldi r22,0
 1496 02d2 70E0      		ldi r23,0
 1497 02d4 CB01      		movw r24,r22
 1498 02d6 D4FF      		sbrs r29,4
 1499 02d8 00C0      		rjmp .L104
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1500               		.loc 1 508 94 discriminator 1 view .LVU409
 1501 02da 6FE0      		ldi r22,lo8(15)
 1502 02dc 70E0      		ldi r23,0
 1503 02de 80E0      		ldi r24,0
 1504 02e0 90E0      		ldi r25,0
 1505 02e2 00C0      		rjmp 2f
 1506               		1:
 1507 02e4 660F      		lsl r22
 1508 02e6 771F      		rol r23
 1509 02e8 881F      		rol r24
 1510 02ea 991F      		rol r25
 1511               		2:
 1512 02ec 4A95      		dec r20
 1513 02ee 02F4      		brpl 1b
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1514               		.loc 1 508 104 discriminator 1 view .LVU410
 1515 02f0 6095      		com r22
 1516 02f2 7095      		com r23
 1517 02f4 8095      		com r24
 1518 02f6 9095      		com r25
 1519               	.L104:
 1520               	.LVL149:
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1521               		.loc 1 509 21 is_stmt 1 discriminator 4 view .LVU411
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1522               		.loc 1 509 47 is_stmt 0 discriminator 4 view .LVU412
 1523 02f8 C695      		lsr r28
 1524 02fa C695      		lsr r28
 1525               	.LVL150:
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1526               		.loc 1 509 47 discriminator 4 view .LVU413
 1527 02fc C370      		andi r28,lo8(3)
 1528 02fe 602B      		or r22,r16
 1529               	.LVL151:
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1530               		.loc 1 509 47 discriminator 4 view .LVU414
 1531 0300 712B      		or r23,r17
 1532 0302 822B      		or r24,r18
 1533 0304 932B      		or r25,r19
 1534 0306 C230      		cpi r28,lo8(2)
 1535 0308 01F0      		breq .L105
 1536 030a 00F4      		brsh .L106
 1537 030c C130      		cpi r28,lo8(1)
 1538 030e 01F0      		breq .L107
 511:tmk_core/common/action.c ****                             break;
 1539               		.loc 1 511 29 is_stmt 1 view .LVU415
 1540 0310 0E94 0000 		call layer_and
 1541               	.LVL152:
 512:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1542               		.loc 1 512 29 view .LVU416
 1543 0314 00C0      		rjmp .L55
 1544               	.L107:
 514:tmk_core/common/action.c ****                             break;
 1545               		.loc 1 514 29 view .LVU417
 1546 0316 0E94 0000 		call layer_or
 1547               	.LVL153:
 515:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1548               		.loc 1 515 29 view .LVU418
 1549 031a 00C0      		rjmp .L55
 1550               	.L105:
 517:tmk_core/common/action.c ****                             break;
 1551               		.loc 1 517 29 view .LVU419
 1552 031c 0E94 0000 		call layer_xor
 1553               	.LVL154:
 518:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1554               		.loc 1 518 29 view .LVU420
 1555 0320 00C0      		rjmp .L55
 1556               	.L106:
 520:tmk_core/common/action.c ****                             break;
 1557               		.loc 1 520 29 view .LVU421
 1558 0322 0E94 0000 		call layer_state_set
 1559               	.LVL155:
 521:tmk_core/common/action.c ****                     }
 1560               		.loc 1 521 29 view .LVU422
 1561 0326 00C0      		rjmp .L55
 1562               	.LVL156:
 1563               	.L60:
 521:tmk_core/common/action.c ****                     }
 1564               		.loc 1 521 29 is_stmt 0 view .LVU423
 1565               	.LBE55:
 527:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1566               		.loc 1 527 13 is_stmt 1 view .LVU424
 1567 0328 CF70      		andi r28,lo8(15)
 1568               	.LVL157:
 527:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1569               		.loc 1 527 16 is_stmt 0 view .LVU425
 1570 032a 1123      		tst r17
 1571 032c 01F0      		breq .L108
 528:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1572               		.loc 1 528 17 is_stmt 1 view .LVU426
 1573 032e 8C2F      		mov r24,r28
 1574 0330 0E94 0000 		call layer_on
 1575               	.LVL158:
 529:tmk_core/common/action.c ****             } else {
 1576               		.loc 1 529 17 view .LVU427
 1577 0334 8D2F      		mov r24,r29
 1578 0336 00C0      		rjmp .L164
 1579               	.L108:
 531:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1580               		.loc 1 531 17 view .LVU428
 1581 0338 8D2F      		mov r24,r29
 1582 033a 0E94 0000 		call unregister_mods
 1583               	.LVL159:
 532:tmk_core/common/action.c ****             }
 1584               		.loc 1 532 17 view .LVU429
 1585 033e 8C2F      		mov r24,r28
 1586               	.LVL160:
 1587               	.L160:
 619:tmk_core/common/action.c ****                         }
 1588               		.loc 1 619 29 is_stmt 0 view .LVU430
 1589 0340 0E94 0000 		call layer_off
 1590               	.LVL161:
 1591 0344 00C0      		rjmp .L55
 1592               	.L59:
 538:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1593               		.loc 1 538 13 is_stmt 1 view .LVU431
 1594 0346 D23F      		cpi r29,lo8(-14)
 1595 0348 01F0      		breq .L109
 1596 034a 00F4      		brsh .L110
 1597 034c D03F      		cpi r29,lo8(-16)
 1598 034e 01F0      		breq .L111
 1599 0350 D13F      		cpi r29,lo8(-15)
 1600 0352 01F0      		breq .L112
 1601               	.L113:
 600:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1602               		.loc 1 600 21 view .LVU432
 600:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1603               		.loc 1 600 24 is_stmt 0 view .LVU433
 1604 0354 1123      		tst r17
 1605 0356 01F4      		brne .+2
 1606 0358 00C0      		rjmp .L122
 601:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1607               		.loc 1 601 25 is_stmt 1 view .LVU434
 601:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1608               		.loc 1 601 28 is_stmt 0 view .LVU435
 1609 035a 0111      		cpse r16,__zero_reg__
 1610 035c 00C0      		rjmp .L165
 605:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1611               		.loc 1 605 76 is_stmt 1 view .LVU436
 606:tmk_core/common/action.c ****                         }
 1612               		.loc 1 606 29 view .LVU437
 1613 035e 8C2F      		mov r24,r28
 1614 0360 8F71      		andi r24,lo8(31)
 1615 0362 00C0      		rjmp .L163
 1616               	.L110:
 1617 0364 D33F      		cpi r29,lo8(-13)
 1618 0366 01F0      		breq .L114
 1619 0368 D43F      		cpi r29,lo8(-12)
 1620 036a 01F4      		brne .L113
 586:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1621               		.loc 1 586 21 view .LVU438
 586:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1622               		.loc 1 586 24 is_stmt 0 view .LVU439
 1623 036c 1123      		tst r17
 1624 036e 01F0      		breq .L121
 587:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1625               		.loc 1 587 25 is_stmt 1 view .LVU440
 587:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1626               		.loc 1 587 50 is_stmt 0 view .LVU441
 1627 0370 CF71      		andi r28,lo8(31)
 1628               	.LVL162:
 587:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1629               		.loc 1 587 25 view .LVU442
 1630 0372 8C2F      		mov r24,r28
 1631 0374 0E94 0000 		call layer_on
 1632               	.LVL163:
 588:tmk_core/common/action.c ****                     } else {
 1633               		.loc 1 588 25 is_stmt 1 view .LVU443
 1634 0378 63E0      		ldi r22,lo8(3)
 1635 037a 8C2F      		mov r24,r28
 1636 037c 0E94 0000 		call set_oneshot_layer
 1637               	.LVL164:
 1638 0380 00C0      		rjmp .L55
 1639               	.LVL165:
 1640               	.L111:
 541:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1641               		.loc 1 541 21 view .LVU444
 541:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1642               		.loc 1 541 24 is_stmt 0 view .LVU445
 1643 0382 1123      		tst r17
 1644 0384 01F0      		breq .L116
 542:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1645               		.loc 1 542 25 is_stmt 1 view .LVU446
 542:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1646               		.loc 1 542 28 is_stmt 0 view .LVU447
 1647 0386 0530      		cpi r16,lo8(5)
 1648 0388 00F0      		brlo .+2
 1649 038a 00C0      		rjmp .L55
 1650               	.L117:
 543:tmk_core/common/action.c ****                         }
 1651               		.loc 1 543 29 is_stmt 1 view .LVU448
 1652 038c 8C2F      		mov r24,r28
 1653 038e 8F71      		andi r24,lo8(31)
 1654 0390 0E94 0000 		call layer_invert
 1655               	.LVL166:
 1656 0394 00C0      		rjmp .L55
 1657               	.L116:
 546:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1658               		.loc 1 546 25 view .LVU449
 546:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1659               		.loc 1 546 28 is_stmt 0 view .LVU450
 1660 0396 0630      		cpi r16,lo8(6)
 1661 0398 00F0      		brlo .+2
 1662 039a 00C0      		rjmp .L55
 1663 039c 00C0      		rjmp .L117
 1664               	.L112:
 552:tmk_core/common/action.c ****                     break;
 1665               		.loc 1 552 21 is_stmt 1 view .LVU451
 1666 039e 8C2F      		mov r24,r28
 1667 03a0 8F71      		andi r24,lo8(31)
 552:tmk_core/common/action.c ****                     break;
 1668               		.loc 1 552 68 is_stmt 0 view .LVU452
 1669 03a2 1123      		tst r17
 1670 03a4 01F0      		breq .L160
 1671               	.L163:
 606:tmk_core/common/action.c ****                         }
 1672               		.loc 1 606 29 view .LVU453
 1673 03a6 0E94 0000 		call layer_on
 1674               	.LVL167:
 1675 03aa 00C0      		rjmp .L55
 1676               	.L109:
 555:tmk_core/common/action.c ****                     break;
 1677               		.loc 1 555 21 is_stmt 1 view .LVU454
 1678 03ac 8C2F      		mov r24,r28
 1679 03ae 8F71      		andi r24,lo8(31)
 555:tmk_core/common/action.c ****                     break;
 1680               		.loc 1 555 69 is_stmt 0 view .LVU455
 1681 03b0 1123      		tst r17
 1682 03b2 01F0      		breq .L163
 1683 03b4 00C0      		rjmp .L160
 1684               	.L114:
 558:tmk_core/common/action.c ****                     break;
 1685               		.loc 1 558 21 is_stmt 1 view .LVU456
 558:tmk_core/common/action.c ****                     break;
 1686               		.loc 1 558 70 is_stmt 0 view .LVU457
 1687 03b6 1123      		tst r17
 1688 03b8 01F0      		breq .L120
 558:tmk_core/common/action.c ****                     break;
 1689               		.loc 1 558 37 discriminator 1 view .LVU458
 1690 03ba 8C2F      		mov r24,r28
 1691 03bc 8F71      		andi r24,lo8(31)
 1692 03be 0E94 0000 		call layer_move
 1693               	.LVL168:
 1694 03c2 00C0      		rjmp .L55
 1695               	.L120:
 558:tmk_core/common/action.c ****                     break;
 1696               		.loc 1 558 72 discriminator 2 view .LVU459
 1697 03c4 0E94 0000 		call layer_clear
 1698               	.LVL169:
 1699 03c8 00C0      		rjmp .L55
 1700               	.L121:
 590:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1701               		.loc 1 590 25 is_stmt 1 view .LVU460
 1702 03ca 81E0      		ldi r24,lo8(1)
 1703 03cc 0E94 0000 		call clear_oneshot_layer_state
 1704               	.LVL170:
 591:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1705               		.loc 1 591 25 view .LVU461
 591:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1706               		.loc 1 591 28 is_stmt 0 view .LVU462
 1707 03d0 0230      		cpi r16,lo8(2)
 1708 03d2 00F4      		brsh .+2
 1709 03d4 00C0      		rjmp .L55
 592:tmk_core/common/action.c ****                         }
 1710               		.loc 1 592 29 is_stmt 1 view .LVU463
 1711 03d6 82E0      		ldi r24,lo8(2)
 1712 03d8 0E94 0000 		call clear_oneshot_layer_state
 1713               	.LVL171:
 1714 03dc 00C0      		rjmp .L55
 1715               	.L122:
 609:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1716               		.loc 1 609 25 view .LVU464
 609:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1717               		.loc 1 609 28 is_stmt 0 view .LVU465
 1718 03de 0023      		tst r16
 1719 03e0 01F0      		breq .L124
 610:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1720               		.loc 1 610 77 is_stmt 1 view .LVU466
 611:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1721               		.loc 1 611 29 view .LVU467
 611:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1722               		.loc 1 611 32 is_stmt 0 view .LVU468
 1723 03e2 D933      		cpi r29,lo8(57)
 1724 03e4 01F0      		breq .+2
 1725 03e6 00C0      		rjmp .L126
 612:tmk_core/common/action.c ****                             } else {
 1726               		.loc 1 612 33 is_stmt 1 view .LVU469
 1727               	.LVL172:
 1728               	.LBB56:
 1729               	.LBI51:
 166:/usr/avr/include/util/delay.h **** {
 1730               		.loc 2 166 1 view .LVU470
 1731               	.LBB53:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1732               		.loc 2 168 2 view .LVU471
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1733               		.loc 2 172 2 view .LVU472
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1734               		.loc 2 173 2 view .LVU473
 174:/usr/avr/include/util/delay.h **** 
 1735               		.loc 2 174 2 view .LVU474
 184:/usr/avr/include/util/delay.h **** 	#endif
 1736               		.loc 2 184 3 view .LVU475
 1737               		.loc 2 187 2 view .LVU476
 1738 03e8 8FEF      		ldi r24,lo8(255999)
 1739 03ea 97EE      		ldi r25,hi8(255999)
 1740 03ec E3E0      		ldi r30,hlo8(255999)
 1741 03ee 8150      	1:	subi r24,1
 1742 03f0 9040      		sbci r25,0
 1743 03f2 E040      		sbci r30,0
 1744 03f4 01F4      		brne 1b
 1745 03f6 00C0      		rjmp .L168
 1746               	.LVL173:
 1747               	.L124:
 1748               		.loc 2 187 2 is_stmt 0 view .LVU477
 1749               	.LBE53:
 1750               	.LBE56:
 618:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1751               		.loc 1 618 79 is_stmt 1 view .LVU478
 619:tmk_core/common/action.c ****                         }
 1752               		.loc 1 619 29 view .LVU479
 1753 03f8 8C2F      		mov r24,r28
 1754 03fa 8F71      		andi r24,lo8(31)
 1755 03fc 00C0      		rjmp .L160
 1756               	.L58:
 630:tmk_core/common/action.c ****             break;
 1757               		.loc 1 630 13 view .LVU480
 630:tmk_core/common/action.c ****             break;
 1758               		.loc 1 630 83 is_stmt 0 view .LVU481
 1759 03fe 4C2F      		mov r20,r28
 1760 0400 4F70      		andi r20,lo8(15)
 630:tmk_core/common/action.c ****             break;
 1761               		.loc 1 630 13 view .LVU482
 1762 0402 6D2F      		mov r22,r29
 1763 0404 C601      		movw r24,r12
 1764 0406 0E94 0000 		call action_get_macro
 1765               	.LVL174:
 1766 040a 0E94 0000 		call action_macro_play
 1767               	.LVL175:
 631:tmk_core/common/action.c **** #endif
 1768               		.loc 1 631 13 is_stmt 1 view .LVU483
 1769 040e 00C0      		rjmp .L55
 1770               	.L56:
 708:tmk_core/common/action.c ****             break;
 1771               		.loc 1 708 13 view .LVU484
 708:tmk_core/common/action.c ****             break;
 1772               		.loc 1 708 64 is_stmt 0 view .LVU485
 1773 0410 4C2F      		mov r20,r28
 1774 0412 4F70      		andi r20,lo8(15)
 708:tmk_core/common/action.c ****             break;
 1775               		.loc 1 708 13 view .LVU486
 1776 0414 6D2F      		mov r22,r29
 1777 0416 C601      		movw r24,r12
 1778 0418 0E94 0000 		call action_function
 1779               	.LVL176:
 709:tmk_core/common/action.c **** #endif
 1780               		.loc 1 709 13 is_stmt 1 view .LVU487
 1781 041c 00C0      		rjmp .L55
 1782               	.LVL177:
 1783               	.L51:
 1784               	/* epilogue start */
 777:tmk_core/common/action.c **** 
 1785               		.loc 1 777 1 is_stmt 0 view .LVU488
 1786 041e DF91      		pop r29
 1787               	.LVL178:
 777:tmk_core/common/action.c **** 
 1788               		.loc 1 777 1 view .LVU489
 1789 0420 CF91      		pop r28
 777:tmk_core/common/action.c **** 
 1790               		.loc 1 777 1 view .LVU490
 1791 0422 1F91      		pop r17
 1792 0424 0F91      		pop r16
 1793 0426 FF90      		pop r15
 1794 0428 EF90      		pop r14
 1795               	.LVL179:
 777:tmk_core/common/action.c **** 
 1796               		.loc 1 777 1 view .LVU491
 1797 042a DF90      		pop r13
 1798 042c CF90      		pop r12
 1799               	.LVL180:
 777:tmk_core/common/action.c **** 
 1800               		.loc 1 777 1 view .LVU492
 1801 042e BF90      		pop r11
 1802 0430 0895      		ret
 1803               		.cfi_endproc
 1804               	.LFE115:
 1806               		.section	.text.process_record_handler,"ax",@progbits
 1807               	.global	process_record_handler
 1809               	process_record_handler:
 1810               	.LVL181:
 1811               	.LFB114:
 216:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1812               		.loc 1 216 50 is_stmt 1 view -0
 1813               		.cfi_startproc
 216:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1814               		.loc 1 216 50 is_stmt 0 view .LVU494
 1815 0000 0F93      		push r16
 1816               	.LCFI15:
 1817               		.cfi_def_cfa_offset 3
 1818               		.cfi_offset 16, -2
 1819 0002 1F93      		push r17
 1820               	.LCFI16:
 1821               		.cfi_def_cfa_offset 4
 1822               		.cfi_offset 17, -3
 1823 0004 CF93      		push r28
 1824               	.LCFI17:
 1825               		.cfi_def_cfa_offset 5
 1826               		.cfi_offset 28, -4
 1827 0006 DF93      		push r29
 1828               	.LCFI18:
 1829               		.cfi_def_cfa_offset 6
 1830               		.cfi_offset 29, -5
 1831               	/* prologue: function */
 1832               	/* frame size = 0 */
 1833               	/* stack size = 4 */
 1834               	.L__stack_usage = 4
 1835 0008 EC01      		movw r28,r24
 217:tmk_core/common/action.c ****     dprint("ACTION: ");
 1836               		.loc 1 217 5 is_stmt 1 view .LVU495
 217:tmk_core/common/action.c ****     dprint("ACTION: ");
 1837               		.loc 1 217 23 is_stmt 0 view .LVU496
 1838 000a 6881      		ld r22,Y
 1839 000c 7981      		ldd r23,Y+1
 1840 000e 8A81      		ldd r24,Y+2
 1841               	.LVL182:
 217:tmk_core/common/action.c ****     dprint("ACTION: ");
 1842               		.loc 1 217 23 view .LVU497
 1843 0010 0E94 0000 		call store_or_get_action
 1844               	.LVL183:
 1845 0014 8C01      		movw r16,r24
 1846               	.LVL184:
 218:tmk_core/common/action.c ****     debug_action(action);
 1847               		.loc 1 218 23 is_stmt 1 view .LVU498
 219:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1848               		.loc 1 219 5 view .LVU499
 221:tmk_core/common/action.c ****     layer_debug();
 1849               		.loc 1 221 29 view .LVU500
 222:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1850               		.loc 1 222 5 view .LVU501
 1851 0016 0E94 0000 		call layer_debug
 1852               	.LVL185:
 223:tmk_core/common/action.c ****     default_layer_debug();
 1853               		.loc 1 223 37 view .LVU502
 224:tmk_core/common/action.c **** #endif
 1854               		.loc 1 224 5 view .LVU503
 1855 001a 0E94 0000 		call default_layer_debug
 1856               	.LVL186:
 226:tmk_core/common/action.c **** 
 1857               		.loc 1 226 15 view .LVU504
 228:tmk_core/common/action.c **** }
 1858               		.loc 1 228 5 view .LVU505
 228:tmk_core/common/action.c **** }
 1859               		.loc 1 228 5 is_stmt 0 view .LVU506
 1860 001e B801      		movw r22,r16
 1861 0020 CE01      		movw r24,r28
 1862               	/* epilogue start */
 229:tmk_core/common/action.c **** 
 1863               		.loc 1 229 1 view .LVU507
 1864 0022 DF91      		pop r29
 1865 0024 CF91      		pop r28
 1866               	.LVL187:
 229:tmk_core/common/action.c **** 
 1867               		.loc 1 229 1 view .LVU508
 1868 0026 1F91      		pop r17
 1869 0028 0F91      		pop r16
 1870               	.LVL188:
 228:tmk_core/common/action.c **** }
 1871               		.loc 1 228 5 view .LVU509
 1872 002a 0C94 0000 		jmp process_action
 1873               	.LVL189:
 228:tmk_core/common/action.c **** }
 1874               		.loc 1 228 5 view .LVU510
 1875               		.cfi_endproc
 1876               	.LFE114:
 1878               		.section	.text.process_record,"ax",@progbits
 1879               	.global	process_record
 1881               	process_record:
 1882               	.LVL190:
 1883               	.LFB113:
 198:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1884               		.loc 1 198 42 is_stmt 1 view -0
 1885               		.cfi_startproc
 198:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1886               		.loc 1 198 42 is_stmt 0 view .LVU512
 1887 0000 CF93      		push r28
 1888               	.LCFI19:
 1889               		.cfi_def_cfa_offset 3
 1890               		.cfi_offset 28, -2
 1891 0002 DF93      		push r29
 1892               	.LCFI20:
 1893               		.cfi_def_cfa_offset 4
 1894               		.cfi_offset 29, -3
 1895               	/* prologue: function */
 1896               	/* frame size = 0 */
 1897               	/* stack size = 2 */
 1898               	.L__stack_usage = 2
 1899 0004 EC01      		movw r28,r24
 199:tmk_core/common/action.c ****         return;
 1900               		.loc 1 199 5 is_stmt 1 view .LVU513
 1901               	.LBB59:
 1902               	.LBI59:
 1903               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1904               		.loc 4 48 20 view .LVU514
 1905               	.LBB60:
 1906               		.loc 4 48 51 view .LVU515
 1907               		.loc 4 48 74 is_stmt 0 view .LVU516
 1908 0006 8B81      		ldd r24,Y+3
 1909 0008 9C81      		ldd r25,Y+4
 1910               	.LVL191:
 1911               		.loc 4 48 74 view .LVU517
 1912 000a 892B      		or r24,r25
 1913 000c 01F0      		breq .L170
 1914 000e 8881      		ld r24,Y
 1915 0010 9981      		ldd r25,Y+1
 1916 0012 8923      		and r24,r25
 1917 0014 8F3F      		cpi r24,lo8(-1)
 1918 0016 01F4      		brne .L186
 1919               	.L170:
 1920               	/* epilogue start */
 1921               	.LBE60:
 1922               	.LBE59:
 214:tmk_core/common/action.c **** 
 1923               		.loc 1 214 1 view .LVU518
 1924 0018 DF91      		pop r29
 1925 001a CF91      		pop r28
 1926               	.LVL192:
 214:tmk_core/common/action.c **** 
 1927               		.loc 1 214 1 view .LVU519
 1928 001c 0895      		ret
 1929               	.LVL193:
 1930               	.L175:
 212:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1931               		.loc 1 212 5 is_stmt 1 view .LVU520
 1932 001e CE01      		movw r24,r28
 1933 0020 0E94 0000 		call process_record_handler
 1934               	.LVL194:
 213:tmk_core/common/action.c **** }
 1935               		.loc 1 213 5 view .LVU521
 1936 0024 CE01      		movw r24,r28
 1937               	/* epilogue start */
 214:tmk_core/common/action.c **** 
 1938               		.loc 1 214 1 is_stmt 0 view .LVU522
 1939 0026 DF91      		pop r29
 1940 0028 CF91      		pop r28
 1941               	.LVL195:
 213:tmk_core/common/action.c **** }
 1942               		.loc 1 213 5 view .LVU523
 1943 002a 0C94 0000 		jmp post_process_record_quantum
 1944               	.LVL196:
 1945               	.L186:
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1946               		.loc 1 203 5 is_stmt 1 view .LVU524
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1947               		.loc 1 203 10 is_stmt 0 view .LVU525
 1948 002e CE01      		movw r24,r28
 1949 0030 0E94 0000 		call process_record_quantum
 1950               	.LVL197:
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1951               		.loc 1 203 8 view .LVU526
 1952 0034 8111      		cpse r24,__zero_reg__
 1953 0036 00C0      		rjmp .L175
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1954               		.loc 1 205 9 is_stmt 1 view .LVU527
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1955               		.loc 1 205 13 is_stmt 0 view .LVU528
 1956 0038 0E94 0000 		call is_oneshot_layer_active
 1957               	.LVL198:
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1958               		.loc 1 205 12 view .LVU529
 1959 003c 8823      		tst r24
 1960 003e 01F0      		breq .L170
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1961               		.loc 1 205 39 discriminator 1 view .LVU530
 1962 0040 8A81      		ldd r24,Y+2
 1963 0042 8823      		tst r24
 1964 0044 01F0      		breq .L170
 206:tmk_core/common/action.c ****         }
 1965               		.loc 1 206 13 is_stmt 1 view .LVU531
 1966 0046 82E0      		ldi r24,lo8(2)
 1967               	/* epilogue start */
 214:tmk_core/common/action.c **** 
 1968               		.loc 1 214 1 is_stmt 0 view .LVU532
 1969 0048 DF91      		pop r29
 1970 004a CF91      		pop r28
 1971               	.LVL199:
 206:tmk_core/common/action.c ****         }
 1972               		.loc 1 206 13 view .LVU533
 1973 004c 0C94 0000 		jmp clear_oneshot_layer_state
 1974               	.LVL200:
 1975               		.cfi_endproc
 1976               	.LFE113:
 1978               		.section	.text.process_record_nocache,"ax",@progbits
 1979               	.global	process_record_nocache
 1981               	process_record_nocache:
 1982               	.LVL201:
 1983               	.LFB109:
 156:tmk_core/common/action.c ****     disable_action_cache = true;
 1984               		.loc 1 156 50 is_stmt 1 view -0
 1985               		.cfi_startproc
 1986               	/* prologue: function */
 1987               	/* frame size = 0 */
 1988               	/* stack size = 0 */
 1989               	.L__stack_usage = 0
 157:tmk_core/common/action.c ****     process_record(record);
 1990               		.loc 1 157 5 view .LVU535
 157:tmk_core/common/action.c ****     process_record(record);
 1991               		.loc 1 157 26 is_stmt 0 view .LVU536
 1992 0000 21E0      		ldi r18,lo8(1)
 1993 0002 2093 0000 		sts disable_action_cache,r18
 158:tmk_core/common/action.c ****     disable_action_cache = false;
 1994               		.loc 1 158 5 is_stmt 1 view .LVU537
 1995 0006 0E94 0000 		call process_record
 1996               	.LVL202:
 159:tmk_core/common/action.c **** }
 1997               		.loc 1 159 5 view .LVU538
 159:tmk_core/common/action.c **** }
 1998               		.loc 1 159 26 is_stmt 0 view .LVU539
 1999 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2000               	/* epilogue start */
 160:tmk_core/common/action.c **** #else
 2001               		.loc 1 160 1 view .LVU540
 2002 000e 0895      		ret
 2003               		.cfi_endproc
 2004               	.LFE109:
 2006               		.section	.text.register_weak_mods,"ax",@progbits
 2007               	.global	register_weak_mods
 2009               	register_weak_mods:
 2010               	.LVL203:
 2011               	.LFB121:
 974:tmk_core/common/action.c **** 
 975:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 976:tmk_core/common/action.c ****  *
 977:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 978:tmk_core/common/action.c ****  */
 979:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 2012               		.loc 1 979 39 is_stmt 1 view -0
 2013               		.cfi_startproc
 2014               	/* prologue: function */
 2015               	/* frame size = 0 */
 2016               	/* stack size = 0 */
 2017               	.L__stack_usage = 0
 980:tmk_core/common/action.c ****     if (mods) {
 2018               		.loc 1 980 5 view .LVU542
 2019               		.loc 1 980 8 is_stmt 0 view .LVU543
 2020 0000 8823      		tst r24
 2021 0002 01F0      		breq .L189
 981:tmk_core/common/action.c ****         add_weak_mods(mods);
 2022               		.loc 1 981 9 is_stmt 1 view .LVU544
 2023 0004 0E94 0000 		call add_weak_mods
 2024               	.LVL204:
 982:tmk_core/common/action.c ****         send_keyboard_report();
 2025               		.loc 1 982 9 view .LVU545
 2026 0008 0C94 0000 		jmp send_keyboard_report
 2027               	.LVL205:
 2028               	.L189:
 2029               	/* epilogue start */
 983:tmk_core/common/action.c ****     }
 984:tmk_core/common/action.c **** }
 2030               		.loc 1 984 1 is_stmt 0 view .LVU546
 2031 000c 0895      		ret
 2032               		.cfi_endproc
 2033               	.LFE121:
 2035               		.section	.text.unregister_weak_mods,"ax",@progbits
 2036               	.global	unregister_weak_mods
 2038               	unregister_weak_mods:
 2039               	.LVL206:
 2040               	.LFB122:
 985:tmk_core/common/action.c **** 
 986:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 987:tmk_core/common/action.c ****  *
 988:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 989:tmk_core/common/action.c ****  */
 990:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 2041               		.loc 1 990 41 is_stmt 1 view -0
 2042               		.cfi_startproc
 2043               	/* prologue: function */
 2044               	/* frame size = 0 */
 2045               	/* stack size = 0 */
 2046               	.L__stack_usage = 0
 991:tmk_core/common/action.c ****     if (mods) {
 2047               		.loc 1 991 5 view .LVU548
 2048               		.loc 1 991 8 is_stmt 0 view .LVU549
 2049 0000 8823      		tst r24
 2050 0002 01F0      		breq .L191
 992:tmk_core/common/action.c ****         del_weak_mods(mods);
 2051               		.loc 1 992 9 is_stmt 1 view .LVU550
 2052 0004 0E94 0000 		call del_weak_mods
 2053               	.LVL207:
 993:tmk_core/common/action.c ****         send_keyboard_report();
 2054               		.loc 1 993 9 view .LVU551
 2055 0008 0C94 0000 		jmp send_keyboard_report
 2056               	.LVL208:
 2057               	.L191:
 2058               	/* epilogue start */
 994:tmk_core/common/action.c ****     }
 995:tmk_core/common/action.c **** }
 2059               		.loc 1 995 1 is_stmt 0 view .LVU552
 2060 000c 0895      		ret
 2061               		.cfi_endproc
 2062               	.LFE122:
 2064               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2065               	.global	clear_keyboard_but_mods_and_keys
 2067               	clear_keyboard_but_mods_and_keys:
 2068               	.LFB125:
 996:tmk_core/common/action.c **** 
 997:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 998:tmk_core/common/action.c ****  *
 999:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1000:tmk_core/common/action.c ****  */
1001:tmk_core/common/action.c **** void clear_keyboard(void) {
1002:tmk_core/common/action.c ****     clear_mods();
1003:tmk_core/common/action.c ****     clear_keyboard_but_mods();
1004:tmk_core/common/action.c **** }
1005:tmk_core/common/action.c **** 
1006:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1007:tmk_core/common/action.c ****  *
1008:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1009:tmk_core/common/action.c ****  */
1010:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
1011:tmk_core/common/action.c ****     clear_keys();
1012:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
1013:tmk_core/common/action.c **** }
1014:tmk_core/common/action.c **** 
1015:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1016:tmk_core/common/action.c ****  *
1017:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1018:tmk_core/common/action.c ****  */
1019:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 2069               		.loc 1 1019 41 is_stmt 1 view -0
 2070               		.cfi_startproc
 2071               	/* prologue: function */
 2072               	/* frame size = 0 */
 2073               	/* stack size = 0 */
 2074               	.L__stack_usage = 0
1020:tmk_core/common/action.c ****     clear_weak_mods();
 2075               		.loc 1 1020 5 view .LVU554
 2076 0000 0E94 0000 		call clear_weak_mods
 2077               	.LVL209:
1021:tmk_core/common/action.c ****     clear_macro_mods();
 2078               		.loc 1 1021 5 view .LVU555
 2079 0004 0E94 0000 		call clear_macro_mods
 2080               	.LVL210:
1022:tmk_core/common/action.c ****     send_keyboard_report();
 2081               		.loc 1 1022 5 view .LVU556
 2082 0008 0E94 0000 		call send_keyboard_report
 2083               	.LVL211:
1023:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
1024:tmk_core/common/action.c ****     mousekey_clear();
 2084               		.loc 1 1024 5 view .LVU557
 2085 000c 0E94 0000 		call mousekey_clear
 2086               	.LVL212:
1025:tmk_core/common/action.c ****     mousekey_send();
 2087               		.loc 1 1025 5 view .LVU558
 2088 0010 0E94 0000 		call mousekey_send
 2089               	.LVL213:
1026:tmk_core/common/action.c **** #endif
1027:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
1028:tmk_core/common/action.c ****     host_system_send(0);
 2090               		.loc 1 1028 5 view .LVU559
 2091 0014 90E0      		ldi r25,0
 2092 0016 80E0      		ldi r24,0
 2093 0018 0E94 0000 		call host_system_send
 2094               	.LVL214:
1029:tmk_core/common/action.c ****     host_consumer_send(0);
 2095               		.loc 1 1029 5 view .LVU560
 2096 001c 90E0      		ldi r25,0
 2097 001e 80E0      		ldi r24,0
 2098 0020 0C94 0000 		jmp host_consumer_send
 2099               	.LVL215:
 2100               		.cfi_endproc
 2101               	.LFE125:
 2103               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2104               	.global	clear_keyboard_but_mods
 2106               	clear_keyboard_but_mods:
 2107               	.LFB124:
1010:tmk_core/common/action.c ****     clear_keys();
 2108               		.loc 1 1010 36 view -0
 2109               		.cfi_startproc
 2110               	/* prologue: function */
 2111               	/* frame size = 0 */
 2112               	/* stack size = 0 */
 2113               	.L__stack_usage = 0
1011:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 2114               		.loc 1 1011 5 view .LVU562
 2115 0000 0E94 0000 		call clear_keys
 2116               	.LVL216:
1012:tmk_core/common/action.c **** }
 2117               		.loc 1 1012 5 view .LVU563
 2118 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2119               	.LVL217:
 2120               		.cfi_endproc
 2121               	.LFE124:
 2123               		.section	.text.clear_keyboard,"ax",@progbits
 2124               	.global	clear_keyboard
 2126               	clear_keyboard:
 2127               	.LFB123:
1001:tmk_core/common/action.c ****     clear_mods();
 2128               		.loc 1 1001 27 view -0
 2129               		.cfi_startproc
 2130               	/* prologue: function */
 2131               	/* frame size = 0 */
 2132               	/* stack size = 0 */
 2133               	.L__stack_usage = 0
1002:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2134               		.loc 1 1002 5 view .LVU565
 2135 0000 0E94 0000 		call clear_mods
 2136               	.LVL218:
1003:tmk_core/common/action.c **** }
 2137               		.loc 1 1003 5 view .LVU566
 2138 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2139               	.LVL219:
 2140               		.cfi_endproc
 2141               	.LFE123:
 2143               		.section	.text.is_tap_action,"ax",@progbits
 2144               	.global	is_tap_action
 2146               	is_tap_action:
 2147               	.LVL220:
 2148               	.LFB127:
1030:tmk_core/common/action.c **** #endif
1031:tmk_core/common/action.c **** }
1032:tmk_core/common/action.c **** 
1033:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1034:tmk_core/common/action.c ****  *
1035:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1036:tmk_core/common/action.c ****  */
1037:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
1038:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
1039:tmk_core/common/action.c ****     return is_tap_action(action);
1040:tmk_core/common/action.c **** }
1041:tmk_core/common/action.c **** 
1042:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1043:tmk_core/common/action.c ****  *
1044:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1045:tmk_core/common/action.c ****  */
1046:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 2149               		.loc 1 1046 37 view -0
 2150               		.cfi_startproc
 2151               	/* prologue: function */
 2152               	/* frame size = 0 */
 2153               	/* stack size = 0 */
 2154               	.L__stack_usage = 0
1047:tmk_core/common/action.c ****     switch (action.kind.id) {
 2155               		.loc 1 1047 5 view .LVU568
 2156               		.loc 1 1047 24 is_stmt 0 view .LVU569
 2157 0000 E92F      		mov r30,r25
 2158 0002 E295      		swap r30
 2159 0004 EF70      		andi r30,lo8(15)
 2160               		.loc 1 1047 5 view .LVU570
 2161 0006 E250      		subi r30,lo8(-(-2))
 2162 0008 EE30      		cpi r30,lo8(14)
 2163 000a 00F4      		brsh .L205
 2164 000c F0E0      		ldi r31,0
 2165 000e E050      		subi r30,lo8(-(gs(.L199)))
 2166 0010 F040      		sbci r31,hi8(-(gs(.L199)))
 2167 0012 0C94 0000 		jmp __tablejump2__
 2168               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2169               		.p2align	1
 2170               	.L199:
 2171 0000 0000      		.word gs(.L200)
 2172 0002 0000      		.word gs(.L200)
 2173 0004 0000      		.word gs(.L205)
 2174 0006 0000      		.word gs(.L205)
 2175 0008 0000      		.word gs(.L201)
 2176 000a 0000      		.word gs(.L205)
 2177 000c 0000      		.word gs(.L205)
 2178 000e 0000      		.word gs(.L205)
 2179 0010 0000      		.word gs(.L200)
 2180 0012 0000      		.word gs(.L200)
 2181 0014 0000      		.word gs(.L198)
 2182 0016 0000      		.word gs(.L205)
 2183 0018 0000      		.word gs(.L205)
 2184 001a 0000      		.word gs(.L198)
 2185               		.section	.text.is_tap_action
 2186               	.L200:
1048:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1049:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1050:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1051:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1052:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2187               		.loc 1 1052 13 is_stmt 1 view .LVU571
 2188 0016 803F      		cpi r24,lo8(-16)
 2189 0018 01F0      		breq .L208
 2190 001a 00F4      		brsh .L202
 2191 001c 883E      		cpi r24,lo8(-24)
 2192 001e 00F4      		brsh .L205
 2193               	.L208:
1053:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1054:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1055:tmk_core/common/action.c ****                 case OP_ONESHOT:
1056:tmk_core/common/action.c ****                     return true;
 2194               		.loc 1 1056 28 is_stmt 0 view .LVU572
 2195 0020 81E0      		ldi r24,lo8(1)
 2196               	.LVL221:
 2197               	/* epilogue start */
1057:tmk_core/common/action.c ****             }
1058:tmk_core/common/action.c ****             return false;
1059:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1060:tmk_core/common/action.c ****             switch (action.swap.code) {
1061:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1062:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1063:tmk_core/common/action.c ****                     return true;
1064:tmk_core/common/action.c ****             }
1065:tmk_core/common/action.c ****             return false;
1066:tmk_core/common/action.c ****         case ACT_MACRO:
1067:tmk_core/common/action.c ****         case ACT_FUNCTION:
1068:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1069:tmk_core/common/action.c ****                 return true;
1070:tmk_core/common/action.c ****             }
1071:tmk_core/common/action.c ****             return false;
1072:tmk_core/common/action.c ****     }
1073:tmk_core/common/action.c ****     return false;
1074:tmk_core/common/action.c **** }
 2198               		.loc 1 1074 1 view .LVU573
 2199 0022 0895      		ret
 2200               	.LVL222:
 2201               	.L202:
 2202               		.loc 1 1074 1 view .LVU574
 2203 0024 843F      		cpi r24,lo8(-12)
 2204 0026 01F0      		breq .L208
 2205               	.L205:
1058:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2206               		.loc 1 1058 20 view .LVU575
 2207 0028 80E0      		ldi r24,0
 2208               	.LVL223:
1058:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2209               		.loc 1 1058 20 view .LVU576
 2210 002a 0895      		ret
 2211               	.LVL224:
 2212               	.L201:
1060:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2213               		.loc 1 1060 13 is_stmt 1 view .LVU577
 2214 002c 883E      		cpi r24,lo8(-24)
 2215 002e 00F0      		brlo .L208
 2216 0030 813F      		cpi r24,lo8(-15)
 2217 0032 01F4      		brne .L205
 2218 0034 00C0      		rjmp .L208
 2219               	.L198:
1068:tmk_core/common/action.c ****                 return true;
 2220               		.loc 1 1068 13 view .LVU578
1068:tmk_core/common/action.c ****                 return true;
 2221               		.loc 1 1068 16 is_stmt 0 view .LVU579
 2222 0036 93FB      		bst r25,3
 2223 0038 8827      		clr r24
 2224 003a 80F9      		bld r24,0
 2225               	.LVL225:
1068:tmk_core/common/action.c ****                 return true;
 2226               		.loc 1 1068 16 view .LVU580
 2227 003c 0895      		ret
 2228               		.cfi_endproc
 2229               	.LFE127:
 2231               		.section	.text.is_tap_key,"ax",@progbits
 2232               	.global	is_tap_key
 2234               	is_tap_key:
 2235               	.LVL226:
 2236               	.LFB126:
1037:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2237               		.loc 1 1037 31 is_stmt 1 view -0
 2238               		.cfi_startproc
 2239               	/* prologue: function */
 2240               	/* frame size = 0 */
 2241               	/* stack size = 0 */
 2242               	.L__stack_usage = 0
1038:tmk_core/common/action.c ****     return is_tap_action(action);
 2243               		.loc 1 1038 5 view .LVU582
1038:tmk_core/common/action.c ****     return is_tap_action(action);
 2244               		.loc 1 1038 23 is_stmt 0 view .LVU583
 2245 0000 0E94 0000 		call layer_switch_get_action
 2246               	.LVL227:
1039:tmk_core/common/action.c **** }
 2247               		.loc 1 1039 5 is_stmt 1 view .LVU584
1039:tmk_core/common/action.c **** }
 2248               		.loc 1 1039 12 is_stmt 0 view .LVU585
 2249 0004 0C94 0000 		jmp is_tap_action
 2250               	.LVL228:
 2251               		.cfi_endproc
 2252               	.LFE126:
 2254               		.section	.text.debug_event,"ax",@progbits
 2255               	.global	debug_event
 2257               	debug_event:
 2258               	.LFB128:
1075:tmk_core/common/action.c **** 
1076:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1077:tmk_core/common/action.c ****  *
1078:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1079:tmk_core/common/action.c ****  */
1080:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2259               		.loc 1 1080 36 is_stmt 1 view -0
 2260               		.cfi_startproc
 2261 0000 CF93      		push r28
 2262               	.LCFI21:
 2263               		.cfi_def_cfa_offset 3
 2264               		.cfi_offset 28, -2
 2265 0002 DF93      		push r29
 2266               	.LCFI22:
 2267               		.cfi_def_cfa_offset 4
 2268               		.cfi_offset 29, -3
 2269 0004 00D0      		rcall .
 2270 0006 00D0      		rcall .
 2271 0008 0F92      		push __tmp_reg__
 2272               	.LCFI23:
 2273               		.cfi_def_cfa_offset 9
 2274 000a CDB7      		in r28,__SP_L__
 2275 000c DEB7      		in r29,__SP_H__
 2276               	.LCFI24:
 2277               		.cfi_def_cfa_register 28
 2278               	/* prologue: function */
 2279               	/* frame size = 5 */
 2280               	/* stack size = 7 */
 2281               	.L__stack_usage = 7
 2282               		.loc 1 1080 138 view .LVU587
 2283               	/* epilogue start */
 2284               		.loc 1 1080 1 is_stmt 0 view .LVU588
 2285 000e 0F90      		pop __tmp_reg__
 2286 0010 0F90      		pop __tmp_reg__
 2287 0012 0F90      		pop __tmp_reg__
 2288 0014 0F90      		pop __tmp_reg__
 2289 0016 0F90      		pop __tmp_reg__
 2290 0018 DF91      		pop r29
 2291 001a CF91      		pop r28
 2292 001c 0895      		ret
 2293               		.cfi_endproc
 2294               	.LFE128:
 2296               		.section	.text.debug_record,"ax",@progbits
 2297               	.global	debug_record
 2299               	debug_record:
 2300               	.LFB129:
1081:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1082:tmk_core/common/action.c ****  *
1083:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1084:tmk_core/common/action.c ****  */
1085:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2301               		.loc 1 1085 39 is_stmt 1 view -0
 2302               		.cfi_startproc
 2303 0000 CF93      		push r28
 2304               	.LCFI25:
 2305               		.cfi_def_cfa_offset 3
 2306               		.cfi_offset 28, -2
 2307 0002 DF93      		push r29
 2308               	.LCFI26:
 2309               		.cfi_def_cfa_offset 4
 2310               		.cfi_offset 29, -3
 2311 0004 00D0      		rcall .
 2312 0006 00D0      		rcall .
 2313 0008 00D0      		rcall .
 2314               	.LCFI27:
 2315               		.cfi_def_cfa_offset 10
 2316 000a CDB7      		in r28,__SP_L__
 2317 000c DEB7      		in r29,__SP_H__
 2318               	.LCFI28:
 2319               		.cfi_def_cfa_register 28
 2320               	/* prologue: function */
 2321               	/* frame size = 6 */
 2322               	/* stack size = 8 */
 2323               	.L__stack_usage = 8
1086:tmk_core/common/action.c ****     debug_event(record.event);
 2324               		.loc 1 1086 5 view .LVU590
1087:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1088:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2325               		.loc 1 1088 77 view .LVU591
 2326               	/* epilogue start */
1089:tmk_core/common/action.c **** #endif
1090:tmk_core/common/action.c **** }
 2327               		.loc 1 1090 1 is_stmt 0 view .LVU592
 2328 000e 2696      		adiw r28,6
 2329 0010 0FB6      		in __tmp_reg__,__SREG__
 2330 0012 F894      		cli
 2331 0014 DEBF      		out __SP_H__,r29
 2332 0016 0FBE      		out __SREG__,__tmp_reg__
 2333 0018 CDBF      		out __SP_L__,r28
 2334 001a DF91      		pop r29
 2335 001c CF91      		pop r28
 2336 001e 0895      		ret
 2337               		.cfi_endproc
 2338               	.LFE129:
 2340               		.section	.text.debug_action,"ax",@progbits
 2341               	.global	debug_action
 2343               	debug_action:
 2344               	.LVL229:
 2345               	.LFB130:
1091:tmk_core/common/action.c **** 
1092:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1093:tmk_core/common/action.c ****  *
1094:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1095:tmk_core/common/action.c ****  */
1096:tmk_core/common/action.c **** void debug_action(action_t action) {
 2346               		.loc 1 1096 36 is_stmt 1 view -0
 2347               		.cfi_startproc
 2348               	/* prologue: function */
 2349               	/* frame size = 0 */
 2350               	/* stack size = 0 */
 2351               	.L__stack_usage = 0
1097:tmk_core/common/action.c ****     switch (action.kind.id) {
 2352               		.loc 1 1097 5 view .LVU594
1098:tmk_core/common/action.c ****         case ACT_LMODS:
1099:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1100:tmk_core/common/action.c ****             break;
1101:tmk_core/common/action.c ****         case ACT_RMODS:
1102:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1103:tmk_core/common/action.c ****             break;
1104:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1105:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1106:tmk_core/common/action.c ****             break;
1107:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1108:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1109:tmk_core/common/action.c ****             break;
1110:tmk_core/common/action.c ****         case ACT_USAGE:
1111:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1112:tmk_core/common/action.c ****             break;
1113:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1114:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1115:tmk_core/common/action.c ****             break;
1116:tmk_core/common/action.c ****         case ACT_LAYER:
1117:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1118:tmk_core/common/action.c ****             break;
1119:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1120:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1121:tmk_core/common/action.c ****             break;
1122:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1123:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1124:tmk_core/common/action.c ****             break;
1125:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1126:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1127:tmk_core/common/action.c ****             break;
1128:tmk_core/common/action.c ****         case ACT_MACRO:
1129:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1130:tmk_core/common/action.c ****             break;
1131:tmk_core/common/action.c ****         case ACT_FUNCTION:
1132:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1133:tmk_core/common/action.c ****             break;
1134:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1135:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1136:tmk_core/common/action.c ****             break;
1137:tmk_core/common/action.c ****         default:
1138:tmk_core/common/action.c ****             dprint("UNKNOWN");
1139:tmk_core/common/action.c ****             break;
1140:tmk_core/common/action.c ****     }
1141:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2353               		.loc 1 1141 75 view .LVU595
 2354               	/* epilogue start */
1142:tmk_core/common/action.c **** }
 2355               		.loc 1 1142 1 is_stmt 0 view .LVU596
 2356 0000 0895      		ret
 2357               		.cfi_endproc
 2358               	.LFE130:
 2360               		.section	.rodata.CSWTCH.11,"a"
 2363               	CSWTCH.11:
 2364 0000 E200      		.word	226
 2365 0002 E900      		.word	233
 2366 0004 EA00      		.word	234
 2367 0006 B500      		.word	181
 2368 0008 B600      		.word	182
 2369 000a B700      		.word	183
 2370 000c CD00      		.word	205
 2371 000e 8301      		.word	387
 2372 0010 CC00      		.word	204
 2373 0012 8A01      		.word	394
 2374 0014 9201      		.word	402
 2375 0016 9401      		.word	404
 2376 0018 2102      		.word	545
 2377 001a 2302      		.word	547
 2378 001c 2402      		.word	548
 2379 001e 2502      		.word	549
 2380 0020 2602      		.word	550
 2381 0022 2702      		.word	551
 2382 0024 2A02      		.word	554
 2383 0026 B300      		.word	179
 2384 0028 B400      		.word	180
 2385 002a 6F00      		.word	111
 2386 002c 7000      		.word	112
 2387               		.section	.rodata.CSWTCH.10,"a"
 2390               	CSWTCH.10:
 2391 0000 81        		.byte	-127
 2392 0001 82        		.byte	-126
 2393 0002 83        		.byte	-125
 2394               	.global	disable_action_cache
 2395               		.section	.bss.disable_action_cache,"aw",@nobits
 2398               	disable_action_cache:
 2399 0000 00        		.zero	1
 2400               		.comm	tp_buttons,2,1
 2401               		.text
 2402               	.Letext0:
 2403               		.file 5 "/usr/avr/include/stdint.h"
 2404               		.file 6 "tmk_core/common/keycode.h"
 2405               		.file 7 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 2406               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 2407               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2408               		.file 10 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 2409               		.file 11 "/usr/avr/include/stdio.h"
 2410               		.file 12 "tmk_core/common/host.h"
 2411               		.file 13 "tmk_core/common/mousekey.h"
 2412               		.file 14 "tmk_core/common/command.h"
 2413               		.file 15 "tmk_core/common/action_code.h"
 2414               		.file 16 "tmk_core/common/action.h"
 2415               		.file 17 "tmk_core/common/action_layer.h"
 2416               		.file 18 "tmk_core/common/action_util.h"
 2417               		.file 19 "tmk_core/common/debug.h"
 2418               		.file 20 "tmk_core/common/led.h"
 2419               		.file 21 "tmk_core/common/action_macro.h"
 2420               		.file 22 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccnStYet.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccnStYet.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccnStYet.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccnStYet.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccnStYet.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccnStYet.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccnStYet.s:14     .text.action_exec:0000000000000000 action_exec
     /tmp/ccnStYet.s:95     .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccnStYet.s:117    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/ccnStYet.s:136    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/ccnStYet.s:161    .text.register_code:0000000000000000 register_code
     /tmp/ccnStYet.s:2390   .rodata.CSWTCH.10:0000000000000000 CSWTCH.10
     /tmp/ccnStYet.s:2363   .rodata.CSWTCH.11:0000000000000000 CSWTCH.11
     /tmp/ccnStYet.s:477    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccnStYet.s:645    .text.tap_code:0000000000000000 tap_code
     /tmp/ccnStYet.s:709    .text.register_mods:0000000000000000 register_mods
     /tmp/ccnStYet.s:738    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccnStYet.s:767    .text.process_action:0000000000000000 process_action
     /tmp/ccnStYet.s:1881   .text.process_record:0000000000000000 process_record
     /tmp/ccnStYet.s:1809   .text.process_record_handler:0000000000000000 process_record_handler
     /tmp/ccnStYet.s:1981   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/ccnStYet.s:2398   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/ccnStYet.s:2009   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/ccnStYet.s:2038   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/ccnStYet.s:2067   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/ccnStYet.s:2106   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccnStYet.s:2126   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccnStYet.s:2146   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/ccnStYet.s:2234   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccnStYet.s:2257   .text.debug_event:0000000000000000 debug_event
     /tmp/ccnStYet.s:2299   .text.debug_record:0000000000000000 debug_record
     /tmp/ccnStYet.s:2343   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
keyboard_report
is_key_pressed
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
