   1               		.file	"ps2_interrupt.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.pbuf_dequeue,"ax",@progbits
  12               	pbuf_dequeue:
  13               	.LFB8:
  14               		.file 1 "../../tmk_core/protocol/pbuff.h"
   1:../../tmk_core/protocol/pbuff.h **** /*--------------------------------------------------------------------
   2:../../tmk_core/protocol/pbuff.h ****  * Ring buffer to store scan codes from keyboard
   3:../../tmk_core/protocol/pbuff.h ****  *------------------------------------------------------------------*/
   4:../../tmk_core/protocol/pbuff.h **** 
   5:../../tmk_core/protocol/pbuff.h **** #ifndef PBUFF_H
   6:../../tmk_core/protocol/pbuff.h **** #define PBUFF_H
   7:../../tmk_core/protocol/pbuff.h **** 
   8:../../tmk_core/protocol/pbuff.h **** #include "print.h"
   9:../../tmk_core/protocol/pbuff.h **** 
  10:../../tmk_core/protocol/pbuff.h **** #define PBUF_SIZE 32
  11:../../tmk_core/protocol/pbuff.h **** static uint16_t pbuf[PBUF_SIZE];
  12:../../tmk_core/protocol/pbuff.h **** static uint16_t pbuf_head = 0;
  13:../../tmk_core/protocol/pbuff.h **** static uint16_t pbuf_tail = 0;
  14:../../tmk_core/protocol/pbuff.h **** static inline void pbuf_enqueue(uint16_t data)
  15:../../tmk_core/protocol/pbuff.h **** {
  16:../../tmk_core/protocol/pbuff.h ****     uint8_t sreg = SREG;
  17:../../tmk_core/protocol/pbuff.h ****     cli();
  18:../../tmk_core/protocol/pbuff.h ****     uint16_t next = (pbuf_head + 1) % PBUF_SIZE;
  19:../../tmk_core/protocol/pbuff.h ****     if (next != pbuf_tail) {
  20:../../tmk_core/protocol/pbuff.h ****         pbuf[pbuf_head] = data;
  21:../../tmk_core/protocol/pbuff.h ****         pbuf_head = next;
  22:../../tmk_core/protocol/pbuff.h ****     } else {
  23:../../tmk_core/protocol/pbuff.h ****         print("pbuf: full\n");
  24:../../tmk_core/protocol/pbuff.h ****     }
  25:../../tmk_core/protocol/pbuff.h ****     SREG = sreg;
  26:../../tmk_core/protocol/pbuff.h **** }
  27:../../tmk_core/protocol/pbuff.h **** static inline uint16_t pbuf_dequeue(void)
  28:../../tmk_core/protocol/pbuff.h **** {
  15               		.loc 1 28 1 view -0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  29:../../tmk_core/protocol/pbuff.h ****     uint16_t val = 0;
  21               		.loc 1 29 5 view .LVU1
  22               	.LVL0:
  30:../../tmk_core/protocol/pbuff.h **** 
  31:../../tmk_core/protocol/pbuff.h ****     uint8_t sreg = SREG;
  23               		.loc 1 31 5 view .LVU2
  24               		.loc 1 31 13 is_stmt 0 view .LVU3
  25 0000 4FB7      		in r20,__SREG__
  26               	.LVL1:
  32:../../tmk_core/protocol/pbuff.h ****     cli();
  27               		.loc 1 32 5 is_stmt 1 view .LVU4
  28               	/* #APP */
  29               	 ;  32 "../../tmk_core/protocol/pbuff.h" 1
  30 0002 F894      		cli
  31               	 ;  0 "" 2
  33:../../tmk_core/protocol/pbuff.h ****     if (pbuf_head != pbuf_tail) {
  32               		.loc 1 33 5 view .LVU5
  33               		.loc 1 33 19 is_stmt 0 view .LVU6
  34               	/* #NOAPP */
  35 0004 2091 0000 		lds r18,pbuf_tail
  36 0008 3091 0000 		lds r19,pbuf_tail+1
  37               		.loc 1 33 8 view .LVU7
  38 000c 8091 0000 		lds r24,pbuf_head
  39 0010 9091 0000 		lds r25,pbuf_head+1
  40 0014 8217      		cp r24,r18
  41 0016 9307      		cpc r25,r19
  42 0018 01F0      		breq .L3
  34:../../tmk_core/protocol/pbuff.h ****         val = pbuf[pbuf_tail];
  43               		.loc 1 34 9 is_stmt 1 view .LVU8
  44               		.loc 1 34 13 is_stmt 0 view .LVU9
  45 001a F901      		movw r30,r18
  46 001c EE0F      		lsl r30
  47 001e FF1F      		rol r31
  48 0020 E050      		subi r30,lo8(-(pbuf))
  49 0022 F040      		sbci r31,hi8(-(pbuf))
  50 0024 8081      		ld r24,Z
  51 0026 9181      		ldd r25,Z+1
  52               	.LVL2:
  35:../../tmk_core/protocol/pbuff.h ****         pbuf_tail = (pbuf_tail + 1) % PBUF_SIZE;
  53               		.loc 1 35 9 is_stmt 1 view .LVU10
  54               		.loc 1 35 32 is_stmt 0 view .LVU11
  55 0028 2F5F      		subi r18,-1
  56 002a 3F4F      		sbci r19,-1
  57               		.loc 1 35 37 view .LVU12
  58 002c 2F71      		andi r18,31
  59 002e 3327      		clr r19
  60               		.loc 1 35 19 view .LVU13
  61 0030 3093 0000 		sts pbuf_tail+1,r19
  62 0034 2093 0000 		sts pbuf_tail,r18
  63               	.LVL3:
  64               	.L2:
  36:../../tmk_core/protocol/pbuff.h ****     }
  37:../../tmk_core/protocol/pbuff.h ****     SREG = sreg;
  65               		.loc 1 37 5 is_stmt 1 view .LVU14
  66               		.loc 1 37 10 is_stmt 0 view .LVU15
  67 0038 4FBF      		out __SREG__,r20
  38:../../tmk_core/protocol/pbuff.h **** 
  39:../../tmk_core/protocol/pbuff.h ****     return val;
  68               		.loc 1 39 5 is_stmt 1 view .LVU16
  69               	/* epilogue start */
  40:../../tmk_core/protocol/pbuff.h **** }
  70               		.loc 1 40 1 is_stmt 0 view .LVU17
  71 003a 0895      		ret
  72               	.LVL4:
  73               	.L3:
  29:../../tmk_core/protocol/pbuff.h **** 
  74               		.loc 1 29 14 view .LVU18
  75 003c 90E0      		ldi r25,0
  76 003e 80E0      		ldi r24,0
  77 0040 00C0      		rjmp .L2
  78               		.cfi_endproc
  79               	.LFE8:
  81               		.section	.text.wait_clock_lo,"ax",@progbits
  83               	wait_clock_lo:
  84               	.LVL5:
  85               	.LFB11:
  86               		.file 2 "../../tmk_core/protocol/ps2.h"
   1:../../tmk_core/protocol/ps2.h **** /*
   2:../../tmk_core/protocol/ps2.h **** Copyright 2010,2011,2012,2013 Jun WAKO <wakojun@gmail.com>
   3:../../tmk_core/protocol/ps2.h **** 
   4:../../tmk_core/protocol/ps2.h **** This software is licensed with a Modified BSD License.
   5:../../tmk_core/protocol/ps2.h **** All of this is supposed to be Free Software, Open Source, DFSG-free,
   6:../../tmk_core/protocol/ps2.h **** GPL-compatible, and OK to use in both free and proprietary applications.
   7:../../tmk_core/protocol/ps2.h **** Additions and corrections to this file are welcome.
   8:../../tmk_core/protocol/ps2.h **** 
   9:../../tmk_core/protocol/ps2.h **** 
  10:../../tmk_core/protocol/ps2.h **** Redistribution and use in source and binary forms, with or without
  11:../../tmk_core/protocol/ps2.h **** modification, are permitted provided that the following conditions are met:
  12:../../tmk_core/protocol/ps2.h **** 
  13:../../tmk_core/protocol/ps2.h **** * Redistributions of source code must retain the above copyright
  14:../../tmk_core/protocol/ps2.h ****   notice, this list of conditions and the following disclaimer.
  15:../../tmk_core/protocol/ps2.h **** 
  16:../../tmk_core/protocol/ps2.h **** * Redistributions in binary form must reproduce the above copyright
  17:../../tmk_core/protocol/ps2.h ****   notice, this list of conditions and the following disclaimer in
  18:../../tmk_core/protocol/ps2.h ****   the documentation and/or other materials provided with the
  19:../../tmk_core/protocol/ps2.h ****   distribution.
  20:../../tmk_core/protocol/ps2.h **** 
  21:../../tmk_core/protocol/ps2.h **** * Neither the name of the copyright holders nor the names of
  22:../../tmk_core/protocol/ps2.h ****   contributors may be used to endorse or promote products derived
  23:../../tmk_core/protocol/ps2.h ****   from this software without specific prior written permission.
  24:../../tmk_core/protocol/ps2.h **** 
  25:../../tmk_core/protocol/ps2.h **** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  26:../../tmk_core/protocol/ps2.h **** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  27:../../tmk_core/protocol/ps2.h **** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  28:../../tmk_core/protocol/ps2.h **** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  29:../../tmk_core/protocol/ps2.h **** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  30:../../tmk_core/protocol/ps2.h **** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  31:../../tmk_core/protocol/ps2.h **** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  32:../../tmk_core/protocol/ps2.h **** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  33:../../tmk_core/protocol/ps2.h **** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  34:../../tmk_core/protocol/ps2.h **** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  35:../../tmk_core/protocol/ps2.h **** POSSIBILITY OF SUCH DAMAGE.
  36:../../tmk_core/protocol/ps2.h **** */
  37:../../tmk_core/protocol/ps2.h **** 
  38:../../tmk_core/protocol/ps2.h **** #ifndef PS2_H
  39:../../tmk_core/protocol/ps2.h **** #define PS2_H
  40:../../tmk_core/protocol/ps2.h **** 
  41:../../tmk_core/protocol/ps2.h **** #include <stdbool.h>
  42:../../tmk_core/protocol/ps2.h **** #include "wait.h"
  43:../../tmk_core/protocol/ps2.h **** #include "ps2_io.h"
  44:../../tmk_core/protocol/ps2.h **** #include "print.h"
  45:../../tmk_core/protocol/ps2.h **** 
  46:../../tmk_core/protocol/ps2.h **** /*
  47:../../tmk_core/protocol/ps2.h ****  * Primitive PS/2 Library for AVR
  48:../../tmk_core/protocol/ps2.h ****  *
  49:../../tmk_core/protocol/ps2.h ****  * PS/2 Resources
  50:../../tmk_core/protocol/ps2.h ****  * --------------
  51:../../tmk_core/protocol/ps2.h ****  * [1] The PS/2 Mouse/Keyboard Protocol
  52:../../tmk_core/protocol/ps2.h ****  * http://www.computer-engineering.org/ps2protocol/
  53:../../tmk_core/protocol/ps2.h ****  * Concise and thorough primer of PS/2 protocol.
  54:../../tmk_core/protocol/ps2.h ****  *
  55:../../tmk_core/protocol/ps2.h ****  * [2] Keyboard and Auxiliary Device Controller
  56:../../tmk_core/protocol/ps2.h ****  * http://www.mcamafia.de/pdf/ibm_hitrc07.pdf
  57:../../tmk_core/protocol/ps2.h ****  * Signal Timing and Format
  58:../../tmk_core/protocol/ps2.h ****  *
  59:../../tmk_core/protocol/ps2.h ****  * [3] Keyboards(101- and 102-key)
  60:../../tmk_core/protocol/ps2.h ****  * http://www.mcamafia.de/pdf/ibm_hitrc11.pdf
  61:../../tmk_core/protocol/ps2.h ****  * Keyboard Layout, Scan Code Set, POR, and Commands.
  62:../../tmk_core/protocol/ps2.h ****  *
  63:../../tmk_core/protocol/ps2.h ****  * [4] PS/2 Reference Manuals
  64:../../tmk_core/protocol/ps2.h ****  * http://www.mcamafia.de/pdf/ibm_hitrc07.pdf
  65:../../tmk_core/protocol/ps2.h ****  * Collection of IBM Personal System/2 documents.
  66:../../tmk_core/protocol/ps2.h ****  *
  67:../../tmk_core/protocol/ps2.h ****  * [5] TrackPoint Engineering Specifications for version 3E
  68:../../tmk_core/protocol/ps2.h ****  * https://web.archive.org/web/20100526161812/http://wwwcssrv.almaden.ibm.com/trackpoint/download.h
  69:../../tmk_core/protocol/ps2.h ****  */
  70:../../tmk_core/protocol/ps2.h **** #define PS2_ACK         0xFA
  71:../../tmk_core/protocol/ps2.h **** #define PS2_RESEND      0xFE
  72:../../tmk_core/protocol/ps2.h **** #define PS2_SET_LED     0xED
  73:../../tmk_core/protocol/ps2.h **** 
  74:../../tmk_core/protocol/ps2.h **** // TODO: error numbers
  75:../../tmk_core/protocol/ps2.h **** #define PS2_ERR_NONE        0
  76:../../tmk_core/protocol/ps2.h **** #define PS2_ERR_STARTBIT1   1
  77:../../tmk_core/protocol/ps2.h **** #define PS2_ERR_STARTBIT2   2
  78:../../tmk_core/protocol/ps2.h **** #define PS2_ERR_STARTBIT3   3
  79:../../tmk_core/protocol/ps2.h **** #define PS2_ERR_PARITY      0x10
  80:../../tmk_core/protocol/ps2.h **** #define PS2_ERR_NODATA      0x20
  81:../../tmk_core/protocol/ps2.h **** 
  82:../../tmk_core/protocol/ps2.h **** #define PS2_LED_SCROLL_LOCK 0
  83:../../tmk_core/protocol/ps2.h **** #define PS2_LED_NUM_LOCK    1
  84:../../tmk_core/protocol/ps2.h **** #define PS2_LED_CAPS_LOCK   2
  85:../../tmk_core/protocol/ps2.h **** 
  86:../../tmk_core/protocol/ps2.h **** 
  87:../../tmk_core/protocol/ps2.h **** extern uint8_t ps2_error;
  88:../../tmk_core/protocol/ps2.h **** 
  89:../../tmk_core/protocol/ps2.h **** void ps2_host_init(void);
  90:../../tmk_core/protocol/ps2.h **** uint8_t ps2_host_send(uint8_t data);
  91:../../tmk_core/protocol/ps2.h **** uint8_t ps2_host_recv_response(void);
  92:../../tmk_core/protocol/ps2.h **** uint8_t ps2_host_recv(void);
  93:../../tmk_core/protocol/ps2.h **** void ps2_host_set_led(uint8_t usb_led);
  94:../../tmk_core/protocol/ps2.h **** 
  95:../../tmk_core/protocol/ps2.h **** 
  96:../../tmk_core/protocol/ps2.h **** /*--------------------------------------------------------------------
  97:../../tmk_core/protocol/ps2.h ****  * static functions
  98:../../tmk_core/protocol/ps2.h ****  *------------------------------------------------------------------*/
  99:../../tmk_core/protocol/ps2.h **** static inline uint16_t wait_clock_lo(uint16_t us)
 100:../../tmk_core/protocol/ps2.h **** {
  87               		.loc 2 100 1 is_stmt 1 view -0
  88               		.cfi_startproc
  89               		.loc 2 100 1 is_stmt 0 view .LVU20
  90 0000 CF93      		push r28
  91               	.LCFI0:
  92               		.cfi_def_cfa_offset 3
  93               		.cfi_offset 28, -2
  94 0002 DF93      		push r29
  95               	.LCFI1:
  96               		.cfi_def_cfa_offset 4
  97               		.cfi_offset 29, -3
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 2 */
 101               	.L__stack_usage = 2
 102 0004 EC01      		movw r28,r24
 101:../../tmk_core/protocol/ps2.h ****     while (clock_in()  && us) { asm(""); wait_us(1); us--; }
 103               		.loc 2 101 5 is_stmt 1 view .LVU21
 104               	.LVL6:
 105               	.L5:
 106               		.loc 2 101 11 discriminator 1 view .LVU22
 107               		.loc 2 101 12 is_stmt 0 discriminator 1 view .LVU23
 108 0006 0E94 0000 		call clock_in
 109               	.LVL7:
 110               		.loc 2 101 11 discriminator 1 view .LVU24
 111 000a 8823      		tst r24
 112 000c 01F0      		breq .L4
 113               		.loc 2 101 24 discriminator 2 view .LVU25
 114 000e 2097      		sbiw r28,0
 115 0010 01F4      		brne .L7
 116               	.L4:
 102:../../tmk_core/protocol/ps2.h ****     return us;
 103:../../tmk_core/protocol/ps2.h **** }
 117               		.loc 2 103 1 view .LVU26
 118 0012 CE01      		movw r24,r28
 119               	/* epilogue start */
 120 0014 DF91      		pop r29
 121 0016 CF91      		pop r28
 122               	.LVL8:
 123               		.loc 2 103 1 view .LVU27
 124 0018 0895      		ret
 125               	.LVL9:
 126               	.L7:
 101:../../tmk_core/protocol/ps2.h ****     while (clock_in()  && us) { asm(""); wait_us(1); us--; }
 127               		.loc 2 101 33 is_stmt 1 discriminator 3 view .LVU28
 101:../../tmk_core/protocol/ps2.h ****     while (clock_in()  && us) { asm(""); wait_us(1); us--; }
 128               		.loc 2 101 42 discriminator 3 view .LVU29
 129               	.LVL10:
 130               	.LBB27:
 131               	.LBI27:
 132               		.file 3 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 133               		.loc 3 255 1 discriminator 3 view .LVU30
 134               	.LBB28:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 135               		.loc 3 257 2 discriminator 3 view .LVU31
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 136               		.loc 3 261 2 discriminator 3 view .LVU32
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 137               		.loc 3 262 2 discriminator 3 view .LVU33
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 138               		.loc 3 263 2 discriminator 3 view .LVU34
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 139               		.loc 3 273 3 discriminator 3 view .LVU35
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 140               		.loc 3 276 2 discriminator 3 view .LVU36
 141 001a 85E0      		ldi r24,lo8(5)
 142 001c 8A95      	1:	dec r24
 143 001e 01F4      		brne 1b
 144 0020 0000      		nop
 145               	.LVL11:
 146               		.loc 3 276 2 is_stmt 0 discriminator 3 view .LVU37
 147               	.LBE28:
 148               	.LBE27:
 101:../../tmk_core/protocol/ps2.h ****     return us;
 149               		.loc 2 101 54 is_stmt 1 discriminator 3 view .LVU38
 101:../../tmk_core/protocol/ps2.h ****     return us;
 150               		.loc 2 101 56 is_stmt 0 discriminator 3 view .LVU39
 151 0022 2197      		sbiw r28,1
 152               	.LVL12:
 101:../../tmk_core/protocol/ps2.h ****     return us;
 153               		.loc 2 101 56 discriminator 3 view .LVU40
 154 0024 00C0      		rjmp .L5
 155               		.cfi_endproc
 156               	.LFE11:
 158               		.section	.text.wait_clock_hi.constprop.0,"ax",@progbits
 160               	wait_clock_hi.constprop.0:
 161               	.LFB23:
 104:../../tmk_core/protocol/ps2.h **** static inline uint16_t wait_clock_hi(uint16_t us)
 162               		.loc 2 104 24 is_stmt 1 view -0
 163               		.cfi_startproc
 164 0000 CF93      		push r28
 165               	.LCFI2:
 166               		.cfi_def_cfa_offset 3
 167               		.cfi_offset 28, -2
 168 0002 DF93      		push r29
 169               	.LCFI3:
 170               		.cfi_def_cfa_offset 4
 171               		.cfi_offset 29, -3
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 2 */
 175               	.L__stack_usage = 2
 176               	.LVL13:
 177               		.loc 2 104 24 is_stmt 0 view .LVU42
 178 0004 C2E3      		ldi r28,lo8(50)
 179 0006 D0E0      		ldi r29,0
 180               	.LVL14:
 181               	.L12:
 105:../../tmk_core/protocol/ps2.h **** {
 106:../../tmk_core/protocol/ps2.h ****     while (!clock_in() && us) { asm(""); wait_us(1); us--; }
 182               		.loc 2 106 11 is_stmt 1 view .LVU43
 183               		.loc 2 106 13 is_stmt 0 view .LVU44
 184 0008 0E94 0000 		call clock_in
 185               	.LVL15:
 186               		.loc 2 106 11 view .LVU45
 187 000c 8111      		cpse r24,__zero_reg__
 188 000e 00C0      		rjmp .L11
 189               		.loc 2 106 24 view .LVU46
 190 0010 2097      		sbiw r28,0
 191 0012 01F4      		brne .L14
 192               	.L11:
 107:../../tmk_core/protocol/ps2.h ****     return us;
 108:../../tmk_core/protocol/ps2.h **** }
 193               		.loc 2 108 1 view .LVU47
 194 0014 CE01      		movw r24,r28
 195               	/* epilogue start */
 196 0016 DF91      		pop r29
 197 0018 CF91      		pop r28
 198               	.LVL16:
 199               		.loc 2 108 1 view .LVU48
 200 001a 0895      		ret
 201               	.LVL17:
 202               	.L14:
 106:../../tmk_core/protocol/ps2.h ****     return us;
 203               		.loc 2 106 33 is_stmt 1 view .LVU49
 106:../../tmk_core/protocol/ps2.h ****     return us;
 204               		.loc 2 106 42 view .LVU50
 205               	.LVL18:
 206               	.LBB29:
 207               	.LBI29:
 255:/usr/avr/include/util/delay.h **** {
 208               		.loc 3 255 1 view .LVU51
 209               	.LBB30:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 210               		.loc 3 257 2 view .LVU52
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 211               		.loc 3 261 2 view .LVU53
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 212               		.loc 3 262 2 view .LVU54
 263:/usr/avr/include/util/delay.h **** 
 213               		.loc 3 263 2 view .LVU55
 273:/usr/avr/include/util/delay.h **** 	#endif
 214               		.loc 3 273 3 view .LVU56
 215               		.loc 3 276 2 view .LVU57
 216 001c 85E0      		ldi r24,lo8(5)
 217 001e 8A95      	1:	dec r24
 218 0020 01F4      		brne 1b
 219 0022 0000      		nop
 220               	.LVL19:
 221               		.loc 3 276 2 is_stmt 0 view .LVU58
 222               	.LBE30:
 223               	.LBE29:
 106:../../tmk_core/protocol/ps2.h ****     return us;
 224               		.loc 2 106 54 is_stmt 1 view .LVU59
 106:../../tmk_core/protocol/ps2.h ****     return us;
 225               		.loc 2 106 56 is_stmt 0 view .LVU60
 226 0024 2197      		sbiw r28,1
 227               	.LVL20:
 106:../../tmk_core/protocol/ps2.h ****     return us;
 228               		.loc 2 106 56 view .LVU61
 229 0026 00C0      		rjmp .L12
 230               		.cfi_endproc
 231               	.LFE23:
 233               		.section	.text.ps2_host_init,"ax",@progbits
 234               	.global	ps2_host_init
 236               	ps2_host_init:
 237               	.LFB17:
 238               		.file 4 "../../tmk_core/protocol/ps2_interrupt.c"
   1:../../tmk_core/protocol/ps2_interrupt.c **** /*
   2:../../tmk_core/protocol/ps2_interrupt.c **** Copyright 2010,2011,2012,2013 Jun WAKO <wakojun@gmail.com>
   3:../../tmk_core/protocol/ps2_interrupt.c **** 
   4:../../tmk_core/protocol/ps2_interrupt.c **** This software is licensed with a Modified BSD License.
   5:../../tmk_core/protocol/ps2_interrupt.c **** All of this is supposed to be Free Software, Open Source, DFSG-free,
   6:../../tmk_core/protocol/ps2_interrupt.c **** GPL-compatible, and OK to use in both free and proprietary applications.
   7:../../tmk_core/protocol/ps2_interrupt.c **** Additions and corrections to this file are welcome.
   8:../../tmk_core/protocol/ps2_interrupt.c **** 
   9:../../tmk_core/protocol/ps2_interrupt.c **** 
  10:../../tmk_core/protocol/ps2_interrupt.c **** Redistribution and use in source and binary forms, with or without
  11:../../tmk_core/protocol/ps2_interrupt.c **** modification, are permitted provided that the following conditions are met:
  12:../../tmk_core/protocol/ps2_interrupt.c **** 
  13:../../tmk_core/protocol/ps2_interrupt.c **** * Redistributions of source code must retain the above copyright
  14:../../tmk_core/protocol/ps2_interrupt.c ****   notice, this list of conditions and the following disclaimer.
  15:../../tmk_core/protocol/ps2_interrupt.c **** 
  16:../../tmk_core/protocol/ps2_interrupt.c **** * Redistributions in binary form must reproduce the above copyright
  17:../../tmk_core/protocol/ps2_interrupt.c ****   notice, this list of conditions and the following disclaimer in
  18:../../tmk_core/protocol/ps2_interrupt.c ****   the documentation and/or other materials provided with the
  19:../../tmk_core/protocol/ps2_interrupt.c ****   distribution.
  20:../../tmk_core/protocol/ps2_interrupt.c **** 
  21:../../tmk_core/protocol/ps2_interrupt.c **** * Neither the name of the copyright holders nor the names of
  22:../../tmk_core/protocol/ps2_interrupt.c ****   contributors may be used to endorse or promote products derived
  23:../../tmk_core/protocol/ps2_interrupt.c ****   from this software without specific prior written permission.
  24:../../tmk_core/protocol/ps2_interrupt.c **** 
  25:../../tmk_core/protocol/ps2_interrupt.c **** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  26:../../tmk_core/protocol/ps2_interrupt.c **** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  27:../../tmk_core/protocol/ps2_interrupt.c **** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  28:../../tmk_core/protocol/ps2_interrupt.c **** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  29:../../tmk_core/protocol/ps2_interrupt.c **** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  30:../../tmk_core/protocol/ps2_interrupt.c **** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  31:../../tmk_core/protocol/ps2_interrupt.c **** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  32:../../tmk_core/protocol/ps2_interrupt.c **** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  33:../../tmk_core/protocol/ps2_interrupt.c **** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  34:../../tmk_core/protocol/ps2_interrupt.c **** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  35:../../tmk_core/protocol/ps2_interrupt.c **** POSSIBILITY OF SUCH DAMAGE.
  36:../../tmk_core/protocol/ps2_interrupt.c **** */
  37:../../tmk_core/protocol/ps2_interrupt.c **** 
  38:../../tmk_core/protocol/ps2_interrupt.c **** /*
  39:../../tmk_core/protocol/ps2_interrupt.c ****  * PS/2 protocol Pin interrupt version
  40:../../tmk_core/protocol/ps2_interrupt.c ****  */
  41:../../tmk_core/protocol/ps2_interrupt.c **** 
  42:../../tmk_core/protocol/ps2_interrupt.c **** #include <stdbool.h>
  43:../../tmk_core/protocol/ps2_interrupt.c **** #include <avr/interrupt.h>
  44:../../tmk_core/protocol/ps2_interrupt.c **** #include <util/delay.h>
  45:../../tmk_core/protocol/ps2_interrupt.c **** #include "pbuff.h"
  46:../../tmk_core/protocol/ps2_interrupt.c **** #include "ps2.h"
  47:../../tmk_core/protocol/ps2_interrupt.c **** #include "ps2_io.h"
  48:../../tmk_core/protocol/ps2_interrupt.c **** #include "print.h"
  49:../../tmk_core/protocol/ps2_interrupt.c **** 
  50:../../tmk_core/protocol/ps2_interrupt.c **** 
  51:../../tmk_core/protocol/ps2_interrupt.c **** #define WAIT(stat, us, err) do { \
  52:../../tmk_core/protocol/ps2_interrupt.c ****     if (!wait_##stat(us)) { \
  53:../../tmk_core/protocol/ps2_interrupt.c ****         ps2_error = err; \
  54:../../tmk_core/protocol/ps2_interrupt.c ****         goto ERROR; \
  55:../../tmk_core/protocol/ps2_interrupt.c ****     } \
  56:../../tmk_core/protocol/ps2_interrupt.c **** } while (0)
  57:../../tmk_core/protocol/ps2_interrupt.c **** 
  58:../../tmk_core/protocol/ps2_interrupt.c **** 
  59:../../tmk_core/protocol/ps2_interrupt.c **** uint8_t ps2_error = PS2_ERR_NONE;
  60:../../tmk_core/protocol/ps2_interrupt.c **** 
  61:../../tmk_core/protocol/ps2_interrupt.c **** void ps2_host_init(void)
  62:../../tmk_core/protocol/ps2_interrupt.c **** {
 239               		.loc 4 62 1 is_stmt 1 view -0
 240               		.cfi_startproc
 241               	/* prologue: function */
 242               	/* frame size = 0 */
 243               	/* stack size = 0 */
 244               	.L__stack_usage = 0
  63:../../tmk_core/protocol/ps2_interrupt.c ****     idle();
 245               		.loc 4 63 5 view .LVU63
 246               	.LBB33:
 247               	.LBI33:
 109:../../tmk_core/protocol/ps2.h **** static inline uint16_t wait_data_lo(uint16_t us)
 110:../../tmk_core/protocol/ps2.h **** {
 111:../../tmk_core/protocol/ps2.h ****     while (data_in() && us)  { asm(""); wait_us(1); us--; }
 112:../../tmk_core/protocol/ps2.h ****     return us;
 113:../../tmk_core/protocol/ps2.h **** }
 114:../../tmk_core/protocol/ps2.h **** static inline uint16_t wait_data_hi(uint16_t us)
 115:../../tmk_core/protocol/ps2.h **** {
 116:../../tmk_core/protocol/ps2.h ****     while (!data_in() && us)  { asm(""); wait_us(1); us--; }
 117:../../tmk_core/protocol/ps2.h ****     return us;
 118:../../tmk_core/protocol/ps2.h **** }
 119:../../tmk_core/protocol/ps2.h **** 
 120:../../tmk_core/protocol/ps2.h **** /* idle state that device can send */
 121:../../tmk_core/protocol/ps2.h **** static inline void idle(void)
 248               		.loc 2 121 20 view .LVU64
 249               	.LBB34:
 122:../../tmk_core/protocol/ps2.h **** {
 123:../../tmk_core/protocol/ps2.h ****     clock_hi();
 250               		.loc 2 123 5 view .LVU65
 251 0000 0E94 0000 		call clock_hi
 252               	.LVL21:
 124:../../tmk_core/protocol/ps2.h ****     data_hi();
 253               		.loc 2 124 5 view .LVU66
 254 0004 0E94 0000 		call data_hi
 255               	.LVL22:
 256               	.LBE34:
 257               	.LBE33:
  64:../../tmk_core/protocol/ps2_interrupt.c ****     PS2_INT_INIT();
 258               		.loc 4 64 5 view .LVU67
 259               		.loc 4 64 5 view .LVU68
 260 0008 E9E6      		ldi r30,lo8(105)
 261 000a F0E0      		ldi r31,0
 262 000c 8081      		ld r24,Z
 263 000e 8860      		ori r24,lo8(8)
 264 0010 8083      		st Z,r24
 265               		.loc 4 64 5 view .LVU69
  65:../../tmk_core/protocol/ps2_interrupt.c ****     PS2_INT_ON();
 266               		.loc 4 65 5 view .LVU70
 267               		.loc 4 65 5 view .LVU71
 268 0012 E99A      		sbi 0x1d,1
 269               		.loc 4 65 5 view .LVU72
 270               	/* epilogue start */
  66:../../tmk_core/protocol/ps2_interrupt.c ****     // POR(150-2000ms) plus BAT(300-500ms) may take 2.5sec([3]p.20)
  67:../../tmk_core/protocol/ps2_interrupt.c ****     //_delay_ms(2500);
  68:../../tmk_core/protocol/ps2_interrupt.c **** }
 271               		.loc 4 68 1 is_stmt 0 view .LVU73
 272 0014 0895      		ret
 273               		.cfi_endproc
 274               	.LFE17:
 276               		.section	.text.ps2_host_recv_response,"ax",@progbits
 277               	.global	ps2_host_recv_response
 279               	ps2_host_recv_response:
 280               	.LFB19:
  69:../../tmk_core/protocol/ps2_interrupt.c **** 
  70:../../tmk_core/protocol/ps2_interrupt.c **** uint8_t ps2_host_send(uint8_t data)
  71:../../tmk_core/protocol/ps2_interrupt.c **** {
  72:../../tmk_core/protocol/ps2_interrupt.c ****     bool parity = true;
  73:../../tmk_core/protocol/ps2_interrupt.c ****     ps2_error = PS2_ERR_NONE;
  74:../../tmk_core/protocol/ps2_interrupt.c **** 
  75:../../tmk_core/protocol/ps2_interrupt.c ****     PS2_INT_OFF();
  76:../../tmk_core/protocol/ps2_interrupt.c **** 
  77:../../tmk_core/protocol/ps2_interrupt.c ****     /* terminate a transmission if we have */
  78:../../tmk_core/protocol/ps2_interrupt.c ****     inhibit();
  79:../../tmk_core/protocol/ps2_interrupt.c ****     _delay_us(100); // 100us [4]p.13, [5]p.50
  80:../../tmk_core/protocol/ps2_interrupt.c **** 
  81:../../tmk_core/protocol/ps2_interrupt.c ****     /* 'Request to Send' and Start bit */
  82:../../tmk_core/protocol/ps2_interrupt.c ****     data_lo();
  83:../../tmk_core/protocol/ps2_interrupt.c ****     clock_hi();
  84:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 10000, 10);   // 10ms [5]p.50
  85:../../tmk_core/protocol/ps2_interrupt.c **** 
  86:../../tmk_core/protocol/ps2_interrupt.c ****     /* Data bit[2-9] */
  87:../../tmk_core/protocol/ps2_interrupt.c ****     for (uint8_t i = 0; i < 8; i++) {
  88:../../tmk_core/protocol/ps2_interrupt.c ****         _delay_us(15);
  89:../../tmk_core/protocol/ps2_interrupt.c ****         if (data&(1<<i)) {
  90:../../tmk_core/protocol/ps2_interrupt.c ****             parity = !parity;
  91:../../tmk_core/protocol/ps2_interrupt.c ****             data_hi();
  92:../../tmk_core/protocol/ps2_interrupt.c ****         } else {
  93:../../tmk_core/protocol/ps2_interrupt.c ****             data_lo();
  94:../../tmk_core/protocol/ps2_interrupt.c ****         }
  95:../../tmk_core/protocol/ps2_interrupt.c ****         WAIT(clock_hi, 50, 2);
  96:../../tmk_core/protocol/ps2_interrupt.c ****         WAIT(clock_lo, 50, 3);
  97:../../tmk_core/protocol/ps2_interrupt.c ****     }
  98:../../tmk_core/protocol/ps2_interrupt.c **** 
  99:../../tmk_core/protocol/ps2_interrupt.c ****     /* Parity bit */
 100:../../tmk_core/protocol/ps2_interrupt.c ****     _delay_us(15);
 101:../../tmk_core/protocol/ps2_interrupt.c ****     if (parity) { data_hi(); } else { data_lo(); }
 102:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_hi, 50, 4);
 103:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 5);
 104:../../tmk_core/protocol/ps2_interrupt.c **** 
 105:../../tmk_core/protocol/ps2_interrupt.c ****     /* Stop bit */
 106:../../tmk_core/protocol/ps2_interrupt.c ****     _delay_us(15);
 107:../../tmk_core/protocol/ps2_interrupt.c ****     data_hi();
 108:../../tmk_core/protocol/ps2_interrupt.c **** 
 109:../../tmk_core/protocol/ps2_interrupt.c ****     /* Ack */
 110:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(data_lo, 50, 6);
 111:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 7);
 112:../../tmk_core/protocol/ps2_interrupt.c **** 
 113:../../tmk_core/protocol/ps2_interrupt.c ****     /* wait for idle state */
 114:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_hi, 50, 8);
 115:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(data_hi, 50, 9);
 116:../../tmk_core/protocol/ps2_interrupt.c **** 
 117:../../tmk_core/protocol/ps2_interrupt.c ****     idle();
 118:../../tmk_core/protocol/ps2_interrupt.c ****     PS2_INT_ON();
 119:../../tmk_core/protocol/ps2_interrupt.c ****     return ps2_host_recv_response();
 120:../../tmk_core/protocol/ps2_interrupt.c **** ERROR:
 121:../../tmk_core/protocol/ps2_interrupt.c ****     idle();
 122:../../tmk_core/protocol/ps2_interrupt.c ****     PS2_INT_ON();
 123:../../tmk_core/protocol/ps2_interrupt.c ****     return 0;
 124:../../tmk_core/protocol/ps2_interrupt.c **** }
 125:../../tmk_core/protocol/ps2_interrupt.c **** 
 126:../../tmk_core/protocol/ps2_interrupt.c **** uint8_t ps2_host_recv_response(void)
 127:../../tmk_core/protocol/ps2_interrupt.c **** {
 281               		.loc 4 127 1 is_stmt 1 view -0
 282               		.cfi_startproc
 283               	/* prologue: function */
 284               	/* frame size = 0 */
 285               	/* stack size = 0 */
 286               	.L__stack_usage = 0
 128:../../tmk_core/protocol/ps2_interrupt.c ****     // Command may take 25ms/20ms at most([5]p.46, [3]p.21)
 129:../../tmk_core/protocol/ps2_interrupt.c ****     uint8_t retry = 25;
 287               		.loc 4 129 5 view .LVU75
 288               	.LVL23:
 130:../../tmk_core/protocol/ps2_interrupt.c ****     while (retry-- && !pbuf_has_data()) {
 289               		.loc 4 130 5 view .LVU76
 290               		.loc 4 130 11 is_stmt 0 view .LVU77
 291 0000 8AE1      		ldi r24,lo8(26)
 292               	.LVL24:
 293               	.L17:
 294               		.loc 4 130 11 is_stmt 1 view .LVU78
 295               		.loc 4 130 11 is_stmt 0 view .LVU79
 296 0002 8150      		subi r24,lo8(-(-1))
 297               	.LVL25:
 298               		.loc 4 130 11 view .LVU80
 299 0004 01F4      		brne .L18
 300               	.LVL26:
 301               	.L19:
 131:../../tmk_core/protocol/ps2_interrupt.c ****         _delay_ms(1);
 132:../../tmk_core/protocol/ps2_interrupt.c ****     }
 133:../../tmk_core/protocol/ps2_interrupt.c ****     return pbuf_dequeue();
 302               		.loc 4 133 5 is_stmt 1 view .LVU81
 303               		.loc 4 133 12 is_stmt 0 view .LVU82
 304 0006 0E94 0000 		call pbuf_dequeue
 305               	.LVL27:
 306               	/* epilogue start */
 134:../../tmk_core/protocol/ps2_interrupt.c **** }
 307               		.loc 4 134 1 view .LVU83
 308 000a 0895      		ret
 309               	.LVL28:
 310               	.L18:
 311               	.LBB39:
 312               	.LBI39:
  41:../../tmk_core/protocol/pbuff.h **** static inline bool pbuf_has_data(void)
 313               		.loc 1 41 20 is_stmt 1 view .LVU84
 314               	.LBB40:
  42:../../tmk_core/protocol/pbuff.h **** {
  43:../../tmk_core/protocol/pbuff.h ****     uint8_t sreg = SREG;
 315               		.loc 1 43 5 view .LVU85
 316               		.loc 1 43 13 is_stmt 0 view .LVU86
 317 000c 9FB7      		in r25,__SREG__
 318               	.LVL29:
  44:../../tmk_core/protocol/pbuff.h ****     cli();
 319               		.loc 1 44 5 is_stmt 1 view .LVU87
 320               	/* #APP */
 321               	 ;  44 "../../tmk_core/protocol/pbuff.h" 1
 322 000e F894      		cli
 323               	 ;  0 "" 2
  45:../../tmk_core/protocol/pbuff.h ****     bool has_data = (pbuf_head != pbuf_tail);
 324               		.loc 1 45 5 view .LVU88
 325               		.loc 1 45 32 is_stmt 0 view .LVU89
 326               	/* #NOAPP */
 327 0010 4091 0000 		lds r20,pbuf_head
 328 0014 5091 0000 		lds r21,pbuf_head+1
 329 0018 2091 0000 		lds r18,pbuf_tail
 330 001c 3091 0000 		lds r19,pbuf_tail+1
 331               	.LVL30:
  46:../../tmk_core/protocol/pbuff.h ****     SREG = sreg;
 332               		.loc 1 46 5 is_stmt 1 view .LVU90
 333               		.loc 1 46 10 is_stmt 0 view .LVU91
 334 0020 9FBF      		out __SREG__,r25
  47:../../tmk_core/protocol/pbuff.h ****     return has_data;
 335               		.loc 1 47 5 is_stmt 1 view .LVU92
 336               	.LVL31:
 337               		.loc 1 47 5 is_stmt 0 view .LVU93
 338               	.LBE40:
 339               	.LBE39:
 130:../../tmk_core/protocol/ps2_interrupt.c ****         _delay_ms(1);
 340               		.loc 4 130 20 view .LVU94
 341 0022 4217      		cp r20,r18
 342 0024 5307      		cpc r21,r19
 343 0026 01F4      		brne .L19
 131:../../tmk_core/protocol/ps2_interrupt.c ****     }
 344               		.loc 4 131 9 is_stmt 1 view .LVU95
 345               	.LVL32:
 346               	.LBB41:
 347               	.LBI41:
 166:/usr/avr/include/util/delay.h **** {
 348               		.loc 3 166 1 view .LVU96
 349               	.LBB42:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 350               		.loc 3 168 2 view .LVU97
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 351               		.loc 3 172 2 view .LVU98
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 352               		.loc 3 173 2 view .LVU99
 174:/usr/avr/include/util/delay.h **** 
 353               		.loc 3 174 2 view .LVU100
 184:/usr/avr/include/util/delay.h **** 	#endif
 354               		.loc 3 184 3 view .LVU101
 187:/usr/avr/include/util/delay.h **** 
 355               		.loc 3 187 2 view .LVU102
 356 0028 EFE9      		ldi r30,lo8(3999)
 357 002a FFE0      		ldi r31,hi8(3999)
 358 002c 3197      	1:	sbiw r30,1
 359 002e 01F4      		brne 1b
 360 0030 00C0      		rjmp .
 361 0032 0000      		nop
 210:/usr/avr/include/util/delay.h **** 
 362               		.loc 3 210 1 is_stmt 0 view .LVU103
 363 0034 00C0      		rjmp .L17
 364               	.LBE42:
 365               	.LBE41:
 366               		.cfi_endproc
 367               	.LFE19:
 369               		.section	.text.ps2_host_send,"ax",@progbits
 370               	.global	ps2_host_send
 372               	ps2_host_send:
 373               	.LVL33:
 374               	.LFB18:
  71:../../tmk_core/protocol/ps2_interrupt.c ****     bool parity = true;
 375               		.loc 4 71 1 is_stmt 1 view -0
 376               		.cfi_startproc
  71:../../tmk_core/protocol/ps2_interrupt.c ****     bool parity = true;
 377               		.loc 4 71 1 is_stmt 0 view .LVU105
 378 0000 EF92      		push r14
 379               	.LCFI4:
 380               		.cfi_def_cfa_offset 3
 381               		.cfi_offset 14, -2
 382 0002 FF92      		push r15
 383               	.LCFI5:
 384               		.cfi_def_cfa_offset 4
 385               		.cfi_offset 15, -3
 386 0004 0F93      		push r16
 387               	.LCFI6:
 388               		.cfi_def_cfa_offset 5
 389               		.cfi_offset 16, -4
 390 0006 1F93      		push r17
 391               	.LCFI7:
 392               		.cfi_def_cfa_offset 6
 393               		.cfi_offset 17, -5
 394 0008 CF93      		push r28
 395               	.LCFI8:
 396               		.cfi_def_cfa_offset 7
 397               		.cfi_offset 28, -6
 398 000a DF93      		push r29
 399               	.LCFI9:
 400               		.cfi_def_cfa_offset 8
 401               		.cfi_offset 29, -7
 402               	/* prologue: function */
 403               	/* frame size = 0 */
 404               	/* stack size = 6 */
 405               	.L__stack_usage = 6
 406 000c C82F      		mov r28,r24
  72:../../tmk_core/protocol/ps2_interrupt.c ****     ps2_error = PS2_ERR_NONE;
 407               		.loc 4 72 5 is_stmt 1 view .LVU106
 408               	.LVL34:
  73:../../tmk_core/protocol/ps2_interrupt.c **** 
 409               		.loc 4 73 5 view .LVU107
  73:../../tmk_core/protocol/ps2_interrupt.c **** 
 410               		.loc 4 73 15 is_stmt 0 view .LVU108
 411 000e 1092 0000 		sts ps2_error,__zero_reg__
  75:../../tmk_core/protocol/ps2_interrupt.c **** 
 412               		.loc 4 75 5 is_stmt 1 view .LVU109
  75:../../tmk_core/protocol/ps2_interrupt.c **** 
 413               		.loc 4 75 5 view .LVU110
 414 0012 E998      		cbi 0x1d,1
  75:../../tmk_core/protocol/ps2_interrupt.c **** 
 415               		.loc 4 75 5 view .LVU111
  78:../../tmk_core/protocol/ps2_interrupt.c ****     _delay_us(100); // 100us [4]p.13, [5]p.50
 416               		.loc 4 78 5 view .LVU112
 417               	.LBB66:
 418               	.LBI66:
 125:../../tmk_core/protocol/ps2.h **** }
 126:../../tmk_core/protocol/ps2.h **** 
 127:../../tmk_core/protocol/ps2.h **** /* inhibit device to send */
 128:../../tmk_core/protocol/ps2.h **** static inline void inhibit(void)
 419               		.loc 2 128 20 view .LVU113
 420               	.LBB67:
 129:../../tmk_core/protocol/ps2.h **** {
 130:../../tmk_core/protocol/ps2.h ****     clock_lo();
 421               		.loc 2 130 5 view .LVU114
 422 0014 0E94 0000 		call clock_lo
 423               	.LVL35:
 131:../../tmk_core/protocol/ps2.h ****     data_hi();
 424               		.loc 2 131 5 view .LVU115
 425 0018 0E94 0000 		call data_hi
 426               	.LVL36:
 427               	.LBE67:
 428               	.LBE66:
  79:../../tmk_core/protocol/ps2_interrupt.c **** 
 429               		.loc 4 79 5 view .LVU116
 430               	.LBB68:
 431               	.LBI68:
 255:/usr/avr/include/util/delay.h **** {
 432               		.loc 3 255 1 view .LVU117
 433               	.LBB69:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 434               		.loc 3 257 2 view .LVU118
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 435               		.loc 3 261 2 view .LVU119
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 436               		.loc 3 262 2 view .LVU120
 263:/usr/avr/include/util/delay.h **** 
 437               		.loc 3 263 2 view .LVU121
 273:/usr/avr/include/util/delay.h **** 	#endif
 438               		.loc 3 273 3 view .LVU122
 439               		.loc 3 276 2 view .LVU123
 440 001c 8FE8      		ldi r24,lo8(399)
 441 001e 91E0      		ldi r25,hi8(399)
 442 0020 0197      	1:	sbiw r24,1
 443 0022 01F4      		brne 1b
 444 0024 00C0      		rjmp .
 445 0026 0000      		nop
 446               	.LVL37:
 447               		.loc 3 276 2 is_stmt 0 view .LVU124
 448               	.LBE69:
 449               	.LBE68:
  82:../../tmk_core/protocol/ps2_interrupt.c ****     clock_hi();
 450               		.loc 4 82 5 is_stmt 1 view .LVU125
 451 0028 0E94 0000 		call data_lo
 452               	.LVL38:
  83:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 10000, 10);   // 10ms [5]p.50
 453               		.loc 4 83 5 view .LVU126
 454 002c 0E94 0000 		call clock_hi
 455               	.LVL39:
  84:../../tmk_core/protocol/ps2_interrupt.c **** 
 456               		.loc 4 84 5 view .LVU127
  84:../../tmk_core/protocol/ps2_interrupt.c **** 
 457               		.loc 4 84 5 view .LVU128
 458 0030 80E1      		ldi r24,lo8(16)
 459 0032 97E2      		ldi r25,lo8(39)
 460 0034 0E94 0000 		call wait_clock_lo
 461               	.LVL40:
 462 0038 892B      		or r24,r25
 463 003a 01F4      		brne .L45
  84:../../tmk_core/protocol/ps2_interrupt.c **** 
 464               		.loc 4 84 5 discriminator 1 view .LVU129
 465 003c 8AE0      		ldi r24,lo8(10)
 466               	.LVL41:
 467               	.L48:
 115:../../tmk_core/protocol/ps2_interrupt.c **** 
 468               		.loc 4 115 5 is_stmt 0 discriminator 1 view .LVU130
 469 003e 8093 0000 		sts ps2_error,r24
 115:../../tmk_core/protocol/ps2_interrupt.c **** 
 470               		.loc 4 115 5 is_stmt 1 discriminator 1 view .LVU131
 471               	.L25:
 121:../../tmk_core/protocol/ps2_interrupt.c ****     PS2_INT_ON();
 472               		.loc 4 121 5 discriminator 1 view .LVU132
 473               	.LBB70:
 474               	.LBI70:
 121:../../tmk_core/protocol/ps2.h **** {
 475               		.loc 2 121 20 discriminator 1 view .LVU133
 476               	.LBB71:
 123:../../tmk_core/protocol/ps2.h ****     data_hi();
 477               		.loc 2 123 5 discriminator 1 view .LVU134
 478 0042 0E94 0000 		call clock_hi
 479               	.LVL42:
 124:../../tmk_core/protocol/ps2.h **** }
 480               		.loc 2 124 5 discriminator 1 view .LVU135
 481 0046 0E94 0000 		call data_hi
 482               	.LVL43:
 483               	.LBE71:
 484               	.LBE70:
 122:../../tmk_core/protocol/ps2_interrupt.c ****     return 0;
 485               		.loc 4 122 5 discriminator 1 view .LVU136
 122:../../tmk_core/protocol/ps2_interrupt.c ****     return 0;
 486               		.loc 4 122 5 discriminator 1 view .LVU137
 487 004a E99A      		sbi 0x1d,1
 122:../../tmk_core/protocol/ps2_interrupt.c ****     return 0;
 488               		.loc 4 122 5 discriminator 1 view .LVU138
 123:../../tmk_core/protocol/ps2_interrupt.c **** }
 489               		.loc 4 123 5 discriminator 1 view .LVU139
 124:../../tmk_core/protocol/ps2_interrupt.c **** 
 490               		.loc 4 124 1 is_stmt 0 discriminator 1 view .LVU140
 491 004c 80E0      		ldi r24,0
 492               	/* epilogue start */
 493 004e DF91      		pop r29
 494 0050 CF91      		pop r28
 495 0052 1F91      		pop r17
 496 0054 0F91      		pop r16
 497 0056 FF90      		pop r15
 498 0058 EF90      		pop r14
 499 005a 0895      		ret
 500               	.LVL44:
 501               	.L45:
 124:../../tmk_core/protocol/ps2_interrupt.c **** 
 502               		.loc 4 124 1 discriminator 1 view .LVU141
 503 005c F12C      		mov r15,__zero_reg__
 504 005e E12C      		mov r14,__zero_reg__
  72:../../tmk_core/protocol/ps2_interrupt.c ****     ps2_error = PS2_ERR_NONE;
 505               		.loc 4 72 10 view .LVU142
 506 0060 11E0      		ldi r17,lo8(1)
 507               	.LBB72:
  89:../../tmk_core/protocol/ps2_interrupt.c ****             parity = !parity;
 508               		.loc 4 89 13 view .LVU143
 509 0062 D0E0      		ldi r29,0
  90:../../tmk_core/protocol/ps2_interrupt.c ****             data_hi();
 510               		.loc 4 90 13 view .LVU144
 511 0064 01E0      		ldi r16,lo8(1)
 512               	.LVL45:
 513               	.L24:
  88:../../tmk_core/protocol/ps2_interrupt.c ****         if (data&(1<<i)) {
 514               		.loc 4 88 9 is_stmt 1 view .LVU145
 515               	.LBB73:
 516               	.LBI73:
 255:/usr/avr/include/util/delay.h **** {
 517               		.loc 3 255 1 view .LVU146
 518               	.LBB74:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 519               		.loc 3 257 2 view .LVU147
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 520               		.loc 3 261 2 view .LVU148
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 521               		.loc 3 262 2 view .LVU149
 263:/usr/avr/include/util/delay.h **** 
 522               		.loc 3 263 2 view .LVU150
 273:/usr/avr/include/util/delay.h **** 	#endif
 523               		.loc 3 273 3 view .LVU151
 524               		.loc 3 276 2 view .LVU152
 525 0066 90E5      		ldi r25,lo8(80)
 526 0068 9A95      	1:	dec r25
 527 006a 01F4      		brne 1b
 528               	.LVL46:
 529               		.loc 3 276 2 is_stmt 0 view .LVU153
 530               	.LBE74:
 531               	.LBE73:
  89:../../tmk_core/protocol/ps2_interrupt.c ****             parity = !parity;
 532               		.loc 4 89 9 is_stmt 1 view .LVU154
  89:../../tmk_core/protocol/ps2_interrupt.c ****             parity = !parity;
 533               		.loc 4 89 13 is_stmt 0 view .LVU155
 534 006c CE01      		movw r24,r28
 535 006e 0E2C      		mov r0,r14
 536 0070 00C0      		rjmp 2f
 537               		1:
 538 0072 9595      		asr r25
 539 0074 8795      		ror r24
 540               		2:
 541 0076 0A94      		dec r0
 542 0078 02F4      		brpl 1b
  89:../../tmk_core/protocol/ps2_interrupt.c ****             parity = !parity;
 543               		.loc 4 89 12 view .LVU156
 544 007a 80FF      		sbrs r24,0
 545 007c 00C0      		rjmp .L26
  90:../../tmk_core/protocol/ps2_interrupt.c ****             data_hi();
 546               		.loc 4 90 13 is_stmt 1 view .LVU157
 547 007e 1027      		eor r17,r16
 548               	.LVL47:
  91:../../tmk_core/protocol/ps2_interrupt.c ****         } else {
 549               		.loc 4 91 13 view .LVU158
 550 0080 0E94 0000 		call data_hi
 551               	.LVL48:
 552               	.L27:
  95:../../tmk_core/protocol/ps2_interrupt.c ****         WAIT(clock_lo, 50, 3);
 553               		.loc 4 95 9 view .LVU159
  95:../../tmk_core/protocol/ps2_interrupt.c ****         WAIT(clock_lo, 50, 3);
 554               		.loc 4 95 9 view .LVU160
 555 0084 0E94 0000 		call wait_clock_hi.constprop.0
 556               	.LVL49:
 557 0088 892B      		or r24,r25
 558 008a 01F4      		brne .L28
  95:../../tmk_core/protocol/ps2_interrupt.c ****         WAIT(clock_lo, 50, 3);
 559               		.loc 4 95 9 discriminator 1 view .LVU161
 560 008c 82E0      		ldi r24,lo8(2)
 561 008e 00C0      		rjmp .L48
 562               	.L26:
  93:../../tmk_core/protocol/ps2_interrupt.c ****         }
 563               		.loc 4 93 13 view .LVU162
 564 0090 0E94 0000 		call data_lo
 565               	.LVL50:
 566 0094 00C0      		rjmp .L27
 567               	.L28:
  95:../../tmk_core/protocol/ps2_interrupt.c ****         WAIT(clock_lo, 50, 3);
 568               		.loc 4 95 9 discriminator 2 view .LVU163
  96:../../tmk_core/protocol/ps2_interrupt.c ****     }
 569               		.loc 4 96 9 discriminator 2 view .LVU164
  96:../../tmk_core/protocol/ps2_interrupt.c ****     }
 570               		.loc 4 96 9 discriminator 2 view .LVU165
 571 0096 82E3      		ldi r24,lo8(50)
 572 0098 90E0      		ldi r25,0
 573 009a 0E94 0000 		call wait_clock_lo
 574               	.LVL51:
 575 009e 892B      		or r24,r25
 576 00a0 01F4      		brne .L29
  96:../../tmk_core/protocol/ps2_interrupt.c ****     }
 577               		.loc 4 96 9 discriminator 1 view .LVU166
 578 00a2 83E0      		ldi r24,lo8(3)
 579 00a4 00C0      		rjmp .L48
 580               	.L29:
  96:../../tmk_core/protocol/ps2_interrupt.c ****     }
 581               		.loc 4 96 9 discriminator 2 view .LVU167
  87:../../tmk_core/protocol/ps2_interrupt.c ****         _delay_us(15);
 582               		.loc 4 87 32 discriminator 2 view .LVU168
 583               	.LVL52:
  87:../../tmk_core/protocol/ps2_interrupt.c ****         _delay_us(15);
 584               		.loc 4 87 25 discriminator 2 view .LVU169
 585 00a6 8FEF      		ldi r24,-1
 586 00a8 E81A      		sub r14,r24
 587 00aa F80A      		sbc r15,r24
 588               	.LVL53:
  87:../../tmk_core/protocol/ps2_interrupt.c ****         _delay_us(15);
 589               		.loc 4 87 5 is_stmt 0 discriminator 2 view .LVU170
 590 00ac 98E0      		ldi r25,8
 591 00ae E916      		cp r14,r25
 592 00b0 F104      		cpc r15,__zero_reg__
 593 00b2 01F4      		brne .L24
 594               	.LBE72:
 100:../../tmk_core/protocol/ps2_interrupt.c ****     if (parity) { data_hi(); } else { data_lo(); }
 595               		.loc 4 100 5 is_stmt 1 view .LVU171
 596               	.LVL54:
 597               	.LBB75:
 598               	.LBI75:
 255:/usr/avr/include/util/delay.h **** {
 599               		.loc 3 255 1 view .LVU172
 600               	.LBB76:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 601               		.loc 3 257 2 view .LVU173
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 602               		.loc 3 261 2 view .LVU174
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 603               		.loc 3 262 2 view .LVU175
 263:/usr/avr/include/util/delay.h **** 
 604               		.loc 3 263 2 view .LVU176
 273:/usr/avr/include/util/delay.h **** 	#endif
 605               		.loc 3 273 3 view .LVU177
 606               		.loc 3 276 2 view .LVU178
 607 00b4 80E5      		ldi r24,lo8(80)
 608 00b6 8A95      	1:	dec r24
 609 00b8 01F4      		brne 1b
 610               	.LVL55:
 611               		.loc 3 276 2 is_stmt 0 view .LVU179
 612               	.LBE76:
 613               	.LBE75:
 101:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_hi, 50, 4);
 614               		.loc 4 101 5 is_stmt 1 view .LVU180
 101:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_hi, 50, 4);
 615               		.loc 4 101 8 is_stmt 0 view .LVU181
 616 00ba 1123      		tst r17
 617 00bc 01F0      		breq .L30
 101:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_hi, 50, 4);
 618               		.loc 4 101 19 is_stmt 1 discriminator 1 view .LVU182
 619 00be 0E94 0000 		call data_hi
 620               	.LVL56:
 621               	.L31:
 102:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 5);
 622               		.loc 4 102 5 view .LVU183
 102:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 5);
 623               		.loc 4 102 5 view .LVU184
 624 00c2 0E94 0000 		call wait_clock_hi.constprop.0
 625               	.LVL57:
 626 00c6 892B      		or r24,r25
 627 00c8 01F4      		brne .L32
 102:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 5);
 628               		.loc 4 102 5 discriminator 1 view .LVU185
 629 00ca 84E0      		ldi r24,lo8(4)
 630 00cc 00C0      		rjmp .L48
 631               	.L30:
 101:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_hi, 50, 4);
 632               		.loc 4 101 39 discriminator 2 view .LVU186
 633 00ce 0E94 0000 		call data_lo
 634               	.LVL58:
 635 00d2 00C0      		rjmp .L31
 636               	.L32:
 102:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 5);
 637               		.loc 4 102 5 discriminator 2 view .LVU187
 103:../../tmk_core/protocol/ps2_interrupt.c **** 
 638               		.loc 4 103 5 discriminator 2 view .LVU188
 103:../../tmk_core/protocol/ps2_interrupt.c **** 
 639               		.loc 4 103 5 discriminator 2 view .LVU189
 640 00d4 82E3      		ldi r24,lo8(50)
 641 00d6 90E0      		ldi r25,0
 642 00d8 0E94 0000 		call wait_clock_lo
 643               	.LVL59:
 644 00dc 892B      		or r24,r25
 645 00de 01F4      		brne .L33
 103:../../tmk_core/protocol/ps2_interrupt.c **** 
 646               		.loc 4 103 5 discriminator 1 view .LVU190
 647 00e0 85E0      		ldi r24,lo8(5)
 648 00e2 00C0      		rjmp .L48
 649               	.L33:
 103:../../tmk_core/protocol/ps2_interrupt.c **** 
 650               		.loc 4 103 5 view .LVU191
 106:../../tmk_core/protocol/ps2_interrupt.c ****     data_hi();
 651               		.loc 4 106 5 view .LVU192
 652               	.LVL60:
 653               	.LBB77:
 654               	.LBI77:
 255:/usr/avr/include/util/delay.h **** {
 655               		.loc 3 255 1 view .LVU193
 656               	.LBB78:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 657               		.loc 3 257 2 view .LVU194
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 658               		.loc 3 261 2 view .LVU195
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 659               		.loc 3 262 2 view .LVU196
 263:/usr/avr/include/util/delay.h **** 
 660               		.loc 3 263 2 view .LVU197
 273:/usr/avr/include/util/delay.h **** 	#endif
 661               		.loc 3 273 3 view .LVU198
 662               		.loc 3 276 2 view .LVU199
 663 00e4 90E5      		ldi r25,lo8(80)
 664 00e6 9A95      	1:	dec r25
 665 00e8 01F4      		brne 1b
 666               	.LVL61:
 667               		.loc 3 276 2 is_stmt 0 view .LVU200
 668               	.LBE78:
 669               	.LBE77:
 107:../../tmk_core/protocol/ps2_interrupt.c **** 
 670               		.loc 4 107 5 is_stmt 1 view .LVU201
 671 00ea 0E94 0000 		call data_hi
 672               	.LVL62:
 110:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 7);
 673               		.loc 4 110 5 view .LVU202
 110:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 7);
 674               		.loc 4 110 5 view .LVU203
 675               	.LBB79:
 676               	.LBI79:
 109:../../tmk_core/protocol/ps2.h **** {
 677               		.loc 2 109 24 view .LVU204
 109:../../tmk_core/protocol/ps2.h **** {
 678               		.loc 2 109 24 is_stmt 0 view .LVU205
 679               	.LBE79:
 107:../../tmk_core/protocol/ps2_interrupt.c **** 
 680               		.loc 4 107 5 view .LVU206
 681 00ee C2E3      		ldi r28,lo8(50)
 682 00f0 D0E0      		ldi r29,0
 683               	.LVL63:
 684               	.L34:
 685               	.LBB84:
 686               	.LBB80:
 111:../../tmk_core/protocol/ps2.h ****     return us;
 687               		.loc 2 111 11 is_stmt 1 view .LVU207
 111:../../tmk_core/protocol/ps2.h ****     return us;
 688               		.loc 2 111 12 is_stmt 0 view .LVU208
 689 00f2 0E94 0000 		call data_in
 690               	.LVL64:
 111:../../tmk_core/protocol/ps2.h ****     return us;
 691               		.loc 2 111 11 view .LVU209
 692 00f6 8823      		tst r24
 693 00f8 01F0      		breq .L35
 111:../../tmk_core/protocol/ps2.h ****     return us;
 694               		.loc 2 111 22 view .LVU210
 695 00fa 2097      		sbiw r28,0
 696 00fc 01F4      		brne .L36
 697               	.LVL65:
 698               	.L37:
 111:../../tmk_core/protocol/ps2.h ****     return us;
 699               		.loc 2 111 22 view .LVU211
 700               	.LBE80:
 701               	.LBE84:
 110:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 7);
 702               		.loc 4 110 5 is_stmt 1 discriminator 1 view .LVU212
 703 00fe 86E0      		ldi r24,lo8(6)
 704 0100 00C0      		rjmp .L48
 705               	.LVL66:
 706               	.L36:
 707               	.LBB85:
 708               	.LBB83:
 111:../../tmk_core/protocol/ps2.h ****     return us;
 709               		.loc 2 111 32 view .LVU213
 111:../../tmk_core/protocol/ps2.h ****     return us;
 710               		.loc 2 111 41 view .LVU214
 711               	.LVL67:
 712               	.LBB81:
 713               	.LBI81:
 255:/usr/avr/include/util/delay.h **** {
 714               		.loc 3 255 1 view .LVU215
 715               	.LBB82:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 716               		.loc 3 257 2 view .LVU216
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 717               		.loc 3 261 2 view .LVU217
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 718               		.loc 3 262 2 view .LVU218
 263:/usr/avr/include/util/delay.h **** 
 719               		.loc 3 263 2 view .LVU219
 273:/usr/avr/include/util/delay.h **** 	#endif
 720               		.loc 3 273 3 view .LVU220
 721               		.loc 3 276 2 view .LVU221
 722 0102 85E0      		ldi r24,lo8(5)
 723 0104 8A95      	1:	dec r24
 724 0106 01F4      		brne 1b
 725 0108 0000      		nop
 726               	.LVL68:
 727               		.loc 3 276 2 is_stmt 0 view .LVU222
 728               	.LBE82:
 729               	.LBE81:
 111:../../tmk_core/protocol/ps2.h ****     return us;
 730               		.loc 2 111 53 is_stmt 1 view .LVU223
 111:../../tmk_core/protocol/ps2.h ****     return us;
 731               		.loc 2 111 55 is_stmt 0 view .LVU224
 732 010a 2197      		sbiw r28,1
 733               	.LVL69:
 111:../../tmk_core/protocol/ps2.h ****     return us;
 734               		.loc 2 111 55 view .LVU225
 735 010c 00C0      		rjmp .L34
 736               	.L35:
 112:../../tmk_core/protocol/ps2.h **** }
 737               		.loc 2 112 5 is_stmt 1 view .LVU226
 738               	.LVL70:
 112:../../tmk_core/protocol/ps2.h **** }
 739               		.loc 2 112 5 is_stmt 0 view .LVU227
 740               	.LBE83:
 741               	.LBE85:
 110:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 7);
 742               		.loc 4 110 5 view .LVU228
 743 010e CD2B      		or r28,r29
 744 0110 01F0      		breq .L37
 110:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(clock_lo, 50, 7);
 745               		.loc 4 110 5 is_stmt 1 discriminator 2 view .LVU229
 111:../../tmk_core/protocol/ps2_interrupt.c **** 
 746               		.loc 4 111 5 discriminator 2 view .LVU230
 111:../../tmk_core/protocol/ps2_interrupt.c **** 
 747               		.loc 4 111 5 discriminator 2 view .LVU231
 748 0112 82E3      		ldi r24,lo8(50)
 749 0114 90E0      		ldi r25,0
 750 0116 0E94 0000 		call wait_clock_lo
 751               	.LVL71:
 752 011a 892B      		or r24,r25
 753 011c 01F4      		brne .L39
 111:../../tmk_core/protocol/ps2_interrupt.c **** 
 754               		.loc 4 111 5 discriminator 1 view .LVU232
 755 011e 87E0      		ldi r24,lo8(7)
 756 0120 00C0      		rjmp .L48
 757               	.L39:
 111:../../tmk_core/protocol/ps2_interrupt.c **** 
 758               		.loc 4 111 5 discriminator 2 view .LVU233
 114:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(data_hi, 50, 9);
 759               		.loc 4 114 5 discriminator 2 view .LVU234
 114:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(data_hi, 50, 9);
 760               		.loc 4 114 5 discriminator 2 view .LVU235
 761 0122 0E94 0000 		call wait_clock_hi.constprop.0
 762               	.LVL72:
 763 0126 892B      		or r24,r25
 764 0128 01F4      		brne .L46
 114:../../tmk_core/protocol/ps2_interrupt.c ****     WAIT(data_hi, 50, 9);
 765               		.loc 4 114 5 discriminator 1 view .LVU236
 766 012a 88E0      		ldi r24,lo8(8)
 767 012c 00C0      		rjmp .L48
 768               	.LVL73:
 769               	.L42:
 770               	.LBB86:
 771               	.LBB87:
 116:../../tmk_core/protocol/ps2.h ****     return us;
 772               		.loc 2 116 33 view .LVU237
 116:../../tmk_core/protocol/ps2.h ****     return us;
 773               		.loc 2 116 42 view .LVU238
 774               	.LVL74:
 775               	.LBB88:
 776               	.LBI88:
 255:/usr/avr/include/util/delay.h **** {
 777               		.loc 3 255 1 view .LVU239
 778               	.LBB89:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 779               		.loc 3 257 2 view .LVU240
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 780               		.loc 3 261 2 view .LVU241
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 781               		.loc 3 262 2 view .LVU242
 263:/usr/avr/include/util/delay.h **** 
 782               		.loc 3 263 2 view .LVU243
 273:/usr/avr/include/util/delay.h **** 	#endif
 783               		.loc 3 273 3 view .LVU244
 784               		.loc 3 276 2 view .LVU245
 785 012e 95E0      		ldi r25,lo8(5)
 786 0130 9A95      	1:	dec r25
 787 0132 01F4      		brne 1b
 788 0134 0000      		nop
 789               	.LVL75:
 790               		.loc 3 276 2 is_stmt 0 view .LVU246
 791               	.LBE89:
 792               	.LBE88:
 116:../../tmk_core/protocol/ps2.h ****     return us;
 793               		.loc 2 116 54 is_stmt 1 view .LVU247
 116:../../tmk_core/protocol/ps2.h ****     return us;
 794               		.loc 2 116 56 is_stmt 0 view .LVU248
 795 0136 2197      		sbiw r28,1
 796               	.LVL76:
 797               	.L40:
 116:../../tmk_core/protocol/ps2.h ****     return us;
 798               		.loc 2 116 11 is_stmt 1 view .LVU249
 116:../../tmk_core/protocol/ps2.h ****     return us;
 799               		.loc 2 116 13 is_stmt 0 view .LVU250
 800 0138 0E94 0000 		call data_in
 801               	.LVL77:
 116:../../tmk_core/protocol/ps2.h ****     return us;
 802               		.loc 2 116 11 view .LVU251
 803 013c 8111      		cpse r24,__zero_reg__
 804 013e 00C0      		rjmp .L41
 116:../../tmk_core/protocol/ps2.h ****     return us;
 805               		.loc 2 116 23 view .LVU252
 806 0140 2097      		sbiw r28,0
 807 0142 01F4      		brne .L42
 808               	.LVL78:
 809               	.L43:
 116:../../tmk_core/protocol/ps2.h ****     return us;
 810               		.loc 2 116 23 view .LVU253
 811               	.LBE87:
 812               	.LBE86:
 115:../../tmk_core/protocol/ps2_interrupt.c **** 
 813               		.loc 4 115 5 is_stmt 1 discriminator 1 view .LVU254
 814 0144 89E0      		ldi r24,lo8(9)
 815 0146 00C0      		rjmp .L48
 816               	.L46:
 817 0148 C2E3      		ldi r28,lo8(50)
 818 014a D0E0      		ldi r29,0
 819 014c 00C0      		rjmp .L40
 820               	.LVL79:
 821               	.L41:
 822               	.LBB91:
 823               	.LBB90:
 117:../../tmk_core/protocol/ps2.h **** }
 824               		.loc 2 117 5 view .LVU255
 117:../../tmk_core/protocol/ps2.h **** }
 825               		.loc 2 117 5 is_stmt 0 view .LVU256
 826               	.LBE90:
 827               	.LBE91:
 115:../../tmk_core/protocol/ps2_interrupt.c **** 
 828               		.loc 4 115 5 view .LVU257
 829 014e CD2B      		or r28,r29
 830 0150 01F0      		breq .L43
 115:../../tmk_core/protocol/ps2_interrupt.c **** 
 831               		.loc 4 115 5 is_stmt 1 view .LVU258
 117:../../tmk_core/protocol/ps2_interrupt.c ****     PS2_INT_ON();
 832               		.loc 4 117 5 view .LVU259
 833               	.LBB92:
 834               	.LBI92:
 121:../../tmk_core/protocol/ps2.h **** {
 835               		.loc 2 121 20 view .LVU260
 836               	.LBB93:
 123:../../tmk_core/protocol/ps2.h ****     data_hi();
 837               		.loc 2 123 5 view .LVU261
 838 0152 0E94 0000 		call clock_hi
 839               	.LVL80:
 124:../../tmk_core/protocol/ps2.h **** }
 840               		.loc 2 124 5 view .LVU262
 841 0156 0E94 0000 		call data_hi
 842               	.LVL81:
 843               	.LBE93:
 844               	.LBE92:
 118:../../tmk_core/protocol/ps2_interrupt.c ****     return ps2_host_recv_response();
 845               		.loc 4 118 5 view .LVU263
 118:../../tmk_core/protocol/ps2_interrupt.c ****     return ps2_host_recv_response();
 846               		.loc 4 118 5 view .LVU264
 847 015a E99A      		sbi 0x1d,1
 118:../../tmk_core/protocol/ps2_interrupt.c ****     return ps2_host_recv_response();
 848               		.loc 4 118 5 view .LVU265
 119:../../tmk_core/protocol/ps2_interrupt.c **** ERROR:
 849               		.loc 4 119 5 view .LVU266
 850               	/* epilogue start */
 124:../../tmk_core/protocol/ps2_interrupt.c **** 
 851               		.loc 4 124 1 is_stmt 0 view .LVU267
 852 015c DF91      		pop r29
 853 015e CF91      		pop r28
 854 0160 1F91      		pop r17
 855               	.LVL82:
 124:../../tmk_core/protocol/ps2_interrupt.c **** 
 856               		.loc 4 124 1 view .LVU268
 857 0162 0F91      		pop r16
 858 0164 FF90      		pop r15
 859 0166 EF90      		pop r14
 860               	.LVL83:
 119:../../tmk_core/protocol/ps2_interrupt.c **** ERROR:
 861               		.loc 4 119 12 view .LVU269
 862 0168 0C94 0000 		jmp ps2_host_recv_response
 863               	.LVL84:
 864               		.cfi_endproc
 865               	.LFE18:
 867               		.section	.text.ps2_host_recv,"ax",@progbits
 868               	.global	ps2_host_recv
 870               	ps2_host_recv:
 871               	.LFB20:
 135:../../tmk_core/protocol/ps2_interrupt.c **** 
 136:../../tmk_core/protocol/ps2_interrupt.c **** /* get data received by interrupt */
 137:../../tmk_core/protocol/ps2_interrupt.c **** uint8_t ps2_host_recv(void)
 138:../../tmk_core/protocol/ps2_interrupt.c **** {
 872               		.loc 4 138 1 is_stmt 1 view -0
 873               		.cfi_startproc
 874               	/* prologue: function */
 875               	/* frame size = 0 */
 876               	/* stack size = 0 */
 877               	.L__stack_usage = 0
 139:../../tmk_core/protocol/ps2_interrupt.c ****     if (pbuf_has_data()) {
 878               		.loc 4 139 5 view .LVU271
 879               	.LBB96:
 880               	.LBI96:
  41:../../tmk_core/protocol/pbuff.h **** {
 881               		.loc 1 41 20 view .LVU272
 882               	.LBB97:
  43:../../tmk_core/protocol/pbuff.h ****     cli();
 883               		.loc 1 43 5 view .LVU273
  43:../../tmk_core/protocol/pbuff.h ****     cli();
 884               		.loc 1 43 13 is_stmt 0 view .LVU274
 885 0000 4FB7      		in r20,__SREG__
 886               	.LVL85:
  44:../../tmk_core/protocol/pbuff.h ****     bool has_data = (pbuf_head != pbuf_tail);
 887               		.loc 1 44 5 is_stmt 1 view .LVU275
 888               	/* #APP */
 889               	 ;  44 "../../tmk_core/protocol/pbuff.h" 1
 890 0002 F894      		cli
 891               	 ;  0 "" 2
  45:../../tmk_core/protocol/pbuff.h ****     SREG = sreg;
 892               		.loc 1 45 5 view .LVU276
  45:../../tmk_core/protocol/pbuff.h ****     SREG = sreg;
 893               		.loc 1 45 32 is_stmt 0 view .LVU277
 894               	/* #NOAPP */
 895 0004 2091 0000 		lds r18,pbuf_head
 896 0008 3091 0000 		lds r19,pbuf_head+1
 897 000c 8091 0000 		lds r24,pbuf_tail
 898 0010 9091 0000 		lds r25,pbuf_tail+1
 899               	.LVL86:
  46:../../tmk_core/protocol/pbuff.h ****     return has_data;
 900               		.loc 1 46 5 is_stmt 1 view .LVU278
  46:../../tmk_core/protocol/pbuff.h ****     return has_data;
 901               		.loc 1 46 10 is_stmt 0 view .LVU279
 902 0014 4FBF      		out __SREG__,r20
 903               		.loc 1 47 5 is_stmt 1 view .LVU280
 904               	.LVL87:
 905               		.loc 1 47 5 is_stmt 0 view .LVU281
 906               	.LBE97:
 907               	.LBE96:
 908               		.loc 4 139 8 view .LVU282
 909 0016 2817      		cp r18,r24
 910 0018 3907      		cpc r19,r25
 911 001a 01F0      		breq .L50
 140:../../tmk_core/protocol/ps2_interrupt.c ****         ps2_error = PS2_ERR_NONE;
 912               		.loc 4 140 9 is_stmt 1 view .LVU283
 913               		.loc 4 140 19 is_stmt 0 view .LVU284
 914 001c 1092 0000 		sts ps2_error,__zero_reg__
 141:../../tmk_core/protocol/ps2_interrupt.c ****         return pbuf_dequeue();
 915               		.loc 4 141 9 is_stmt 1 view .LVU285
 916               		.loc 4 141 16 is_stmt 0 view .LVU286
 917 0020 0E94 0000 		call pbuf_dequeue
 918               	.LVL88:
 919 0024 0895      		ret
 920               	.L50:
 142:../../tmk_core/protocol/ps2_interrupt.c ****     } else {
 143:../../tmk_core/protocol/ps2_interrupt.c ****         ps2_error = PS2_ERR_NODATA;
 921               		.loc 4 143 9 is_stmt 1 view .LVU287
 922               		.loc 4 143 19 is_stmt 0 view .LVU288
 923 0026 80E2      		ldi r24,lo8(32)
 924 0028 8093 0000 		sts ps2_error,r24
 144:../../tmk_core/protocol/ps2_interrupt.c ****         return 0;
 925               		.loc 4 144 9 is_stmt 1 view .LVU289
 926               		.loc 4 144 16 is_stmt 0 view .LVU290
 927 002c 80E0      		ldi r24,0
 928               	/* epilogue start */
 145:../../tmk_core/protocol/ps2_interrupt.c ****     }
 146:../../tmk_core/protocol/ps2_interrupt.c **** }
 929               		.loc 4 146 1 view .LVU291
 930 002e 0895      		ret
 931               		.cfi_endproc
 932               	.LFE20:
 934               		.section	.text.__vector_2,"ax",@progbits
 935               	.global	__vector_2
 937               	__vector_2:
 938               	.LFB21:
 147:../../tmk_core/protocol/ps2_interrupt.c **** 
 148:../../tmk_core/protocol/ps2_interrupt.c **** ISR(PS2_INT_VECT)
 149:../../tmk_core/protocol/ps2_interrupt.c **** {
 939               		.loc 4 149 1 is_stmt 1 view -0
 940               		.cfi_startproc
 941 0000 1F92      		push r1
 942               	.LCFI10:
 943               		.cfi_def_cfa_offset 3
 944               		.cfi_offset 1, -2
 945 0002 0F92      		push r0
 946               	.LCFI11:
 947               		.cfi_def_cfa_offset 4
 948               		.cfi_offset 0, -3
 949 0004 0FB6      		in r0,__SREG__
 950 0006 0F92      		push r0
 951 0008 1124      		clr __zero_reg__
 952 000a 2F93      		push r18
 953               	.LCFI12:
 954               		.cfi_def_cfa_offset 5
 955               		.cfi_offset 18, -4
 956 000c 3F93      		push r19
 957               	.LCFI13:
 958               		.cfi_def_cfa_offset 6
 959               		.cfi_offset 19, -5
 960 000e 4F93      		push r20
 961               	.LCFI14:
 962               		.cfi_def_cfa_offset 7
 963               		.cfi_offset 20, -6
 964 0010 5F93      		push r21
 965               	.LCFI15:
 966               		.cfi_def_cfa_offset 8
 967               		.cfi_offset 21, -7
 968 0012 6F93      		push r22
 969               	.LCFI16:
 970               		.cfi_def_cfa_offset 9
 971               		.cfi_offset 22, -8
 972 0014 7F93      		push r23
 973               	.LCFI17:
 974               		.cfi_def_cfa_offset 10
 975               		.cfi_offset 23, -9
 976 0016 8F93      		push r24
 977               	.LCFI18:
 978               		.cfi_def_cfa_offset 11
 979               		.cfi_offset 24, -10
 980 0018 9F93      		push r25
 981               	.LCFI19:
 982               		.cfi_def_cfa_offset 12
 983               		.cfi_offset 25, -11
 984 001a AF93      		push r26
 985               	.LCFI20:
 986               		.cfi_def_cfa_offset 13
 987               		.cfi_offset 26, -12
 988 001c BF93      		push r27
 989               	.LCFI21:
 990               		.cfi_def_cfa_offset 14
 991               		.cfi_offset 27, -13
 992 001e CF93      		push r28
 993               	.LCFI22:
 994               		.cfi_def_cfa_offset 15
 995               		.cfi_offset 28, -14
 996 0020 EF93      		push r30
 997               	.LCFI23:
 998               		.cfi_def_cfa_offset 16
 999               		.cfi_offset 30, -15
 1000 0022 FF93      		push r31
 1001               	.LCFI24:
 1002               		.cfi_def_cfa_offset 17
 1003               		.cfi_offset 31, -16
 1004               	/* prologue: Signal */
 1005               	/* frame size = 0 */
 1006               	/* stack size = 16 */
 1007               	.L__stack_usage = 16
 150:../../tmk_core/protocol/ps2_interrupt.c ****     static enum {
 1008               		.loc 4 150 5 view .LVU293
 151:../../tmk_core/protocol/ps2_interrupt.c ****         INIT,
 152:../../tmk_core/protocol/ps2_interrupt.c ****         START,
 153:../../tmk_core/protocol/ps2_interrupt.c ****         BIT0, BIT1, BIT2, BIT3, BIT4, BIT5, BIT6, BIT7,
 154:../../tmk_core/protocol/ps2_interrupt.c ****         PARITY,
 155:../../tmk_core/protocol/ps2_interrupt.c ****         STOP,
 156:../../tmk_core/protocol/ps2_interrupt.c ****     } state = INIT;
 157:../../tmk_core/protocol/ps2_interrupt.c ****     static uint8_t data = 0;
 1009               		.loc 4 157 5 view .LVU294
 158:../../tmk_core/protocol/ps2_interrupt.c ****     static uint8_t parity = 1;
 1010               		.loc 4 158 5 view .LVU295
 159:../../tmk_core/protocol/ps2_interrupt.c **** 
 160:../../tmk_core/protocol/ps2_interrupt.c ****     // TODO: abort if elapse 100us from previous interrupt
 161:../../tmk_core/protocol/ps2_interrupt.c **** 
 162:../../tmk_core/protocol/ps2_interrupt.c ****     // return unless falling edge
 163:../../tmk_core/protocol/ps2_interrupt.c ****     if (clock_in()) {
 1011               		.loc 4 163 5 view .LVU296
 1012               		.loc 4 163 9 is_stmt 0 view .LVU297
 1013 0024 0E94 0000 		call clock_in
 1014               	.LVL89:
 1015               		.loc 4 163 8 view .LVU298
 1016 0028 8111      		cpse r24,__zero_reg__
 1017 002a 00C0      		rjmp .L52
 164:../../tmk_core/protocol/ps2_interrupt.c ****         goto RETURN;
 165:../../tmk_core/protocol/ps2_interrupt.c ****     }
 166:../../tmk_core/protocol/ps2_interrupt.c **** 
 167:../../tmk_core/protocol/ps2_interrupt.c ****     state++;
 1018               		.loc 4 167 5 is_stmt 1 view .LVU299
 1019               		.loc 4 167 10 is_stmt 0 view .LVU300
 1020 002c 9091 0000 		lds r25,state.1944
 1021 0030 81E0      		ldi r24,lo8(1)
 1022 0032 890F      		add r24,r25
 1023 0034 8093 0000 		sts state.1944,r24
 168:../../tmk_core/protocol/ps2_interrupt.c ****     switch (state) {
 1024               		.loc 4 168 5 is_stmt 1 view .LVU301
 1025 0038 8A30      		cpi r24,lo8(10)
 1026 003a 01F4      		brne .+2
 1027 003c 00C0      		rjmp .L55
 1028 003e 00F4      		brsh .L56
 1029 0040 8130      		cpi r24,lo8(1)
 1030 0042 01F0      		breq .L57
 1031 0044 9150      		subi r25,lo8(-(-1))
 1032 0046 9830      		cpi r25,lo8(8)
 1033 0048 00F4      		brsh .+2
 1034 004a 00C0      		rjmp .L79
 1035               	.L58:
 169:../../tmk_core/protocol/ps2_interrupt.c ****         case START:
 170:../../tmk_core/protocol/ps2_interrupt.c ****             if (data_in())
 171:../../tmk_core/protocol/ps2_interrupt.c ****                 goto ERROR;
 172:../../tmk_core/protocol/ps2_interrupt.c ****             break;
 173:../../tmk_core/protocol/ps2_interrupt.c ****         case BIT0:
 174:../../tmk_core/protocol/ps2_interrupt.c ****         case BIT1:
 175:../../tmk_core/protocol/ps2_interrupt.c ****         case BIT2:
 176:../../tmk_core/protocol/ps2_interrupt.c ****         case BIT3:
 177:../../tmk_core/protocol/ps2_interrupt.c ****         case BIT4:
 178:../../tmk_core/protocol/ps2_interrupt.c ****         case BIT5:
 179:../../tmk_core/protocol/ps2_interrupt.c ****         case BIT6:
 180:../../tmk_core/protocol/ps2_interrupt.c ****         case BIT7:
 181:../../tmk_core/protocol/ps2_interrupt.c ****             data >>= 1;
 182:../../tmk_core/protocol/ps2_interrupt.c ****             if (data_in()) {
 183:../../tmk_core/protocol/ps2_interrupt.c ****                 data |= 0x80;
 184:../../tmk_core/protocol/ps2_interrupt.c ****                 parity++;
 185:../../tmk_core/protocol/ps2_interrupt.c ****             }
 186:../../tmk_core/protocol/ps2_interrupt.c ****             break;
 187:../../tmk_core/protocol/ps2_interrupt.c ****         case PARITY:
 188:../../tmk_core/protocol/ps2_interrupt.c ****             if (data_in()) {
 189:../../tmk_core/protocol/ps2_interrupt.c ****                 if (!(parity & 0x01))
 190:../../tmk_core/protocol/ps2_interrupt.c ****                     goto ERROR;
 191:../../tmk_core/protocol/ps2_interrupt.c ****             } else {
 192:../../tmk_core/protocol/ps2_interrupt.c ****                 if (parity & 0x01)
 193:../../tmk_core/protocol/ps2_interrupt.c ****                     goto ERROR;
 194:../../tmk_core/protocol/ps2_interrupt.c ****             }
 195:../../tmk_core/protocol/ps2_interrupt.c ****             break;
 196:../../tmk_core/protocol/ps2_interrupt.c ****         case STOP:
 197:../../tmk_core/protocol/ps2_interrupt.c ****             if (!data_in())
 198:../../tmk_core/protocol/ps2_interrupt.c ****                 goto ERROR;
 199:../../tmk_core/protocol/ps2_interrupt.c ****             pbuf_enqueue(data);
 200:../../tmk_core/protocol/ps2_interrupt.c ****             goto DONE;
 201:../../tmk_core/protocol/ps2_interrupt.c ****             break;
 202:../../tmk_core/protocol/ps2_interrupt.c ****         default:
 203:../../tmk_core/protocol/ps2_interrupt.c ****             goto ERROR;
 204:../../tmk_core/protocol/ps2_interrupt.c ****     }
 205:../../tmk_core/protocol/ps2_interrupt.c ****     goto RETURN;
 206:../../tmk_core/protocol/ps2_interrupt.c **** ERROR:
 207:../../tmk_core/protocol/ps2_interrupt.c ****     ps2_error = state;
 1036               		.loc 4 207 5 view .LVU302
 1037               		.loc 4 207 15 is_stmt 0 view .LVU303
 1038 004c 8091 0000 		lds r24,state.1944
 1039 0050 8093 0000 		sts ps2_error,r24
 1040 0054 00C0      		rjmp .L66
 1041               	.L56:
 168:../../tmk_core/protocol/ps2_interrupt.c ****     switch (state) {
 1042               		.loc 4 168 5 view .LVU304
 1043 0056 8B30      		cpi r24,lo8(11)
 1044 0058 01F4      		brne .L58
 197:../../tmk_core/protocol/ps2_interrupt.c ****                 goto ERROR;
 1045               		.loc 4 197 13 is_stmt 1 view .LVU305
 197:../../tmk_core/protocol/ps2_interrupt.c ****                 goto ERROR;
 1046               		.loc 4 197 18 is_stmt 0 view .LVU306
 1047 005a 0E94 0000 		call data_in
 1048               	.LVL90:
 197:../../tmk_core/protocol/ps2_interrupt.c ****                 goto ERROR;
 1049               		.loc 4 197 16 view .LVU307
 1050 005e 8823      		tst r24
 1051 0060 01F0      		breq .L58
 199:../../tmk_core/protocol/ps2_interrupt.c ****             goto DONE;
 1052               		.loc 4 199 13 is_stmt 1 view .LVU308
 1053 0062 4091 0000 		lds r20,data.1945
 1054 0066 50E0      		ldi r21,0
 1055               	.LVL91:
 1056               	.LBB101:
 1057               	.LBI101:
  14:../../tmk_core/protocol/pbuff.h **** {
 1058               		.loc 1 14 20 view .LVU309
 1059               	.LBB102:
  16:../../tmk_core/protocol/pbuff.h ****     cli();
 1060               		.loc 1 16 5 view .LVU310
  16:../../tmk_core/protocol/pbuff.h ****     cli();
 1061               		.loc 1 16 13 is_stmt 0 view .LVU311
 1062 0068 CFB7      		in r28,__SREG__
 1063               	.LVL92:
  17:../../tmk_core/protocol/pbuff.h ****     uint16_t next = (pbuf_head + 1) % PBUF_SIZE;
 1064               		.loc 1 17 5 is_stmt 1 view .LVU312
 1065               	/* #APP */
 1066               	 ;  17 "../../tmk_core/protocol/pbuff.h" 1
 1067 006a F894      		cli
 1068               	 ;  0 "" 2
  18:../../tmk_core/protocol/pbuff.h ****     if (next != pbuf_tail) {
 1069               		.loc 1 18 5 view .LVU313
  18:../../tmk_core/protocol/pbuff.h ****     if (next != pbuf_tail) {
 1070               		.loc 1 18 32 is_stmt 0 view .LVU314
 1071               	/* #NOAPP */
 1072 006c 8091 0000 		lds r24,pbuf_head
 1073 0070 9091 0000 		lds r25,pbuf_head+1
 1074 0074 9C01      		movw r18,r24
 1075 0076 2F5F      		subi r18,-1
 1076 0078 3F4F      		sbci r19,-1
  18:../../tmk_core/protocol/pbuff.h ****     if (next != pbuf_tail) {
 1077               		.loc 1 18 14 view .LVU315
 1078 007a 2F71      		andi r18,31
 1079 007c 3327      		clr r19
 1080               	.LVL93:
  19:../../tmk_core/protocol/pbuff.h ****         pbuf[pbuf_head] = data;
 1081               		.loc 1 19 5 is_stmt 1 view .LVU316
  19:../../tmk_core/protocol/pbuff.h ****         pbuf[pbuf_head] = data;
 1082               		.loc 1 19 8 is_stmt 0 view .LVU317
 1083 007e 6091 0000 		lds r22,pbuf_tail
 1084 0082 7091 0000 		lds r23,pbuf_tail+1
 1085 0086 2617      		cp r18,r22
 1086 0088 3707      		cpc r19,r23
 1087 008a 01F4      		brne .+2
 1088 008c 00C0      		rjmp .L64
  20:../../tmk_core/protocol/pbuff.h ****         pbuf_head = next;
 1089               		.loc 1 20 9 is_stmt 1 view .LVU318
  20:../../tmk_core/protocol/pbuff.h ****         pbuf_head = next;
 1090               		.loc 1 20 25 is_stmt 0 view .LVU319
 1091 008e 880F      		lsl r24
 1092 0090 991F      		rol r25
 1093 0092 FC01      		movw r30,r24
 1094 0094 E050      		subi r30,lo8(-(pbuf))
 1095 0096 F040      		sbci r31,hi8(-(pbuf))
 1096 0098 5183      		std Z+1,r21
 1097 009a 4083      		st Z,r20
  21:../../tmk_core/protocol/pbuff.h ****     } else {
 1098               		.loc 1 21 9 is_stmt 1 view .LVU320
  21:../../tmk_core/protocol/pbuff.h ****     } else {
 1099               		.loc 1 21 19 is_stmt 0 view .LVU321
 1100 009c 3093 0000 		sts pbuf_head+1,r19
 1101 00a0 2093 0000 		sts pbuf_head,r18
 1102               	.LVL94:
 1103               	.L65:
  25:../../tmk_core/protocol/pbuff.h **** }
 1104               		.loc 1 25 5 is_stmt 1 view .LVU322
  25:../../tmk_core/protocol/pbuff.h **** }
 1105               		.loc 1 25 10 is_stmt 0 view .LVU323
 1106 00a4 CFBF      		out __SREG__,r28
 1107               	.LVL95:
  25:../../tmk_core/protocol/pbuff.h **** }
 1108               		.loc 1 25 10 view .LVU324
 1109               	.LBE102:
 1110               	.LBE101:
 200:../../tmk_core/protocol/ps2_interrupt.c ****             break;
 1111               		.loc 4 200 13 is_stmt 1 view .LVU325
 1112               	.L66:
 208:../../tmk_core/protocol/ps2_interrupt.c **** DONE:
 209:../../tmk_core/protocol/ps2_interrupt.c ****     state = INIT;
 1113               		.loc 4 209 5 view .LVU326
 1114               		.loc 4 209 11 is_stmt 0 view .LVU327
 1115 00a6 1092 0000 		sts state.1944,__zero_reg__
 210:../../tmk_core/protocol/ps2_interrupt.c ****     data = 0;
 1116               		.loc 4 210 5 is_stmt 1 view .LVU328
 1117               		.loc 4 210 10 is_stmt 0 view .LVU329
 1118 00aa 1092 0000 		sts data.1945,__zero_reg__
 211:../../tmk_core/protocol/ps2_interrupt.c ****     parity = 1;
 1119               		.loc 4 211 5 is_stmt 1 view .LVU330
 1120               		.loc 4 211 12 is_stmt 0 view .LVU331
 1121 00ae 81E0      		ldi r24,lo8(1)
 1122 00b0 00C0      		rjmp .L80
 1123               	.L57:
 170:../../tmk_core/protocol/ps2_interrupt.c ****                 goto ERROR;
 1124               		.loc 4 170 13 is_stmt 1 view .LVU332
 170:../../tmk_core/protocol/ps2_interrupt.c ****                 goto ERROR;
 1125               		.loc 4 170 17 is_stmt 0 view .LVU333
 1126 00b2 0E94 0000 		call data_in
 1127               	.LVL96:
 170:../../tmk_core/protocol/ps2_interrupt.c ****                 goto ERROR;
 1128               		.loc 4 170 16 view .LVU334
 1129 00b6 8111      		cpse r24,__zero_reg__
 1130 00b8 00C0      		rjmp .L58
 1131               	.L54:
 1132               	.L52:
 1133               	/* epilogue start */
 212:../../tmk_core/protocol/ps2_interrupt.c **** RETURN:
 213:../../tmk_core/protocol/ps2_interrupt.c ****     return;
 214:../../tmk_core/protocol/ps2_interrupt.c **** }
 1134               		.loc 4 214 1 view .LVU335
 1135 00ba FF91      		pop r31
 1136 00bc EF91      		pop r30
 1137 00be CF91      		pop r28
 1138 00c0 BF91      		pop r27
 1139 00c2 AF91      		pop r26
 1140 00c4 9F91      		pop r25
 1141 00c6 8F91      		pop r24
 1142 00c8 7F91      		pop r23
 1143 00ca 6F91      		pop r22
 1144 00cc 5F91      		pop r21
 1145 00ce 4F91      		pop r20
 1146 00d0 3F91      		pop r19
 1147 00d2 2F91      		pop r18
 1148 00d4 0F90      		pop r0
 1149 00d6 0FBE      		out __SREG__,r0
 1150 00d8 0F90      		pop r0
 1151 00da 1F90      		pop r1
 1152 00dc 1895      		reti
 1153               	.L79:
 181:../../tmk_core/protocol/ps2_interrupt.c ****             if (data_in()) {
 1154               		.loc 4 181 13 is_stmt 1 view .LVU336
 181:../../tmk_core/protocol/ps2_interrupt.c ****             if (data_in()) {
 1155               		.loc 4 181 18 is_stmt 0 view .LVU337
 1156 00de 8091 0000 		lds r24,data.1945
 1157 00e2 8695      		lsr r24
 1158 00e4 8093 0000 		sts data.1945,r24
 182:../../tmk_core/protocol/ps2_interrupt.c ****                 data |= 0x80;
 1159               		.loc 4 182 13 is_stmt 1 view .LVU338
 182:../../tmk_core/protocol/ps2_interrupt.c ****                 data |= 0x80;
 1160               		.loc 4 182 17 is_stmt 0 view .LVU339
 1161 00e8 0E94 0000 		call data_in
 1162               	.LVL97:
 182:../../tmk_core/protocol/ps2_interrupt.c ****                 data |= 0x80;
 1163               		.loc 4 182 16 view .LVU340
 1164 00ec 8823      		tst r24
 1165 00ee 01F0      		breq .L52
 183:../../tmk_core/protocol/ps2_interrupt.c ****                 parity++;
 1166               		.loc 4 183 17 is_stmt 1 view .LVU341
 183:../../tmk_core/protocol/ps2_interrupt.c ****                 parity++;
 1167               		.loc 4 183 22 is_stmt 0 view .LVU342
 1168 00f0 8091 0000 		lds r24,data.1945
 1169 00f4 8068      		ori r24,lo8(-128)
 1170 00f6 8093 0000 		sts data.1945,r24
 184:../../tmk_core/protocol/ps2_interrupt.c ****             }
 1171               		.loc 4 184 17 is_stmt 1 view .LVU343
 184:../../tmk_core/protocol/ps2_interrupt.c ****             }
 1172               		.loc 4 184 23 is_stmt 0 view .LVU344
 1173 00fa 8091 0000 		lds r24,parity.1946
 1174 00fe 8F5F      		subi r24,lo8(-(1))
 1175               	.L80:
 211:../../tmk_core/protocol/ps2_interrupt.c **** RETURN:
 1176               		.loc 4 211 12 view .LVU345
 1177 0100 8093 0000 		sts parity.1946,r24
 213:../../tmk_core/protocol/ps2_interrupt.c **** }
 1178               		.loc 4 213 5 is_stmt 1 view .LVU346
 1179 0104 00C0      		rjmp .L52
 1180               	.L55:
 188:../../tmk_core/protocol/ps2_interrupt.c ****                 if (!(parity & 0x01))
 1181               		.loc 4 188 13 view .LVU347
 188:../../tmk_core/protocol/ps2_interrupt.c ****                 if (!(parity & 0x01))
 1182               		.loc 4 188 17 is_stmt 0 view .LVU348
 1183 0106 0E94 0000 		call data_in
 1184               	.LVL98:
 1185 010a 9091 0000 		lds r25,parity.1946
 188:../../tmk_core/protocol/ps2_interrupt.c ****                 if (!(parity & 0x01))
 1186               		.loc 4 188 16 view .LVU349
 1187 010e 8823      		tst r24
 1188 0110 01F0      		breq .L62
 189:../../tmk_core/protocol/ps2_interrupt.c ****                     goto ERROR;
 1189               		.loc 4 189 17 is_stmt 1 view .LVU350
 189:../../tmk_core/protocol/ps2_interrupt.c ****                     goto ERROR;
 1190               		.loc 4 189 20 is_stmt 0 view .LVU351
 1191 0112 90FF      		sbrs r25,0
 1192 0114 00C0      		rjmp .L58
 1193 0116 00C0      		rjmp .L52
 1194               	.L62:
 192:../../tmk_core/protocol/ps2_interrupt.c ****                     goto ERROR;
 1195               		.loc 4 192 17 is_stmt 1 view .LVU352
 192:../../tmk_core/protocol/ps2_interrupt.c ****                     goto ERROR;
 1196               		.loc 4 192 20 is_stmt 0 view .LVU353
 1197 0118 90FD      		sbrc r25,0
 1198 011a 00C0      		rjmp .L58
 1199 011c 00C0      		rjmp .L52
 1200               	.LVL99:
 1201               	.L64:
 1202               	.LBB105:
 1203               	.LBB103:
  23:../../tmk_core/protocol/pbuff.h ****     }
 1204               		.loc 1 23 9 is_stmt 1 view .LVU354
 1205               	.LBE103:
 1206               	.LBE105:
  23:../../tmk_core/protocol/pbuff.h ****     }
 1207               		.loc 1 23 9 view .LVU355
  23:../../tmk_core/protocol/pbuff.h ****     }
 1208               		.loc 1 23 9 view .LVU356
 1209               	.LBB106:
 1210               	.LBB104:
 1211 011e 80E0      		ldi r24,lo8(__c.1830)
 1212 0120 90E0      		ldi r25,hi8(__c.1830)
 1213 0122 0E94 0000 		call xputs
 1214               	.LVL100:
  23:../../tmk_core/protocol/pbuff.h ****     }
 1215               		.loc 1 23 9 is_stmt 0 view .LVU357
 1216 0126 00C0      		rjmp .L65
 1217               	.LBE104:
 1218               	.LBE106:
 1219               		.cfi_endproc
 1220               	.LFE21:
 1222               		.section	.text.ps2_host_set_led,"ax",@progbits
 1223               	.global	ps2_host_set_led
 1225               	ps2_host_set_led:
 1226               	.LVL101:
 1227               	.LFB22:
 215:../../tmk_core/protocol/ps2_interrupt.c **** 
 216:../../tmk_core/protocol/ps2_interrupt.c **** /* send LED state to keyboard */
 217:../../tmk_core/protocol/ps2_interrupt.c **** void ps2_host_set_led(uint8_t led)
 218:../../tmk_core/protocol/ps2_interrupt.c **** {
 1228               		.loc 4 218 1 is_stmt 1 view -0
 1229               		.cfi_startproc
 1230               		.loc 4 218 1 is_stmt 0 view .LVU359
 1231 0000 CF93      		push r28
 1232               	.LCFI25:
 1233               		.cfi_def_cfa_offset 3
 1234               		.cfi_offset 28, -2
 1235               	/* prologue: function */
 1236               	/* frame size = 0 */
 1237               	/* stack size = 1 */
 1238               	.L__stack_usage = 1
 1239 0002 C82F      		mov r28,r24
 219:../../tmk_core/protocol/ps2_interrupt.c ****     ps2_host_send(0xED);
 1240               		.loc 4 219 5 is_stmt 1 view .LVU360
 1241 0004 8DEE      		ldi r24,lo8(-19)
 1242               	.LVL102:
 1243               		.loc 4 219 5 is_stmt 0 view .LVU361
 1244 0006 0E94 0000 		call ps2_host_send
 1245               	.LVL103:
 220:../../tmk_core/protocol/ps2_interrupt.c ****     ps2_host_send(led);
 1246               		.loc 4 220 5 is_stmt 1 view .LVU362
 1247 000a 8C2F      		mov r24,r28
 1248               	/* epilogue start */
 221:../../tmk_core/protocol/ps2_interrupt.c **** }
 1249               		.loc 4 221 1 is_stmt 0 view .LVU363
 1250 000c CF91      		pop r28
 1251               	.LVL104:
 220:../../tmk_core/protocol/ps2_interrupt.c ****     ps2_host_send(led);
 1252               		.loc 4 220 5 view .LVU364
 1253 000e 0C94 0000 		jmp ps2_host_send
 1254               	.LVL105:
 220:../../tmk_core/protocol/ps2_interrupt.c ****     ps2_host_send(led);
 1255               		.loc 4 220 5 view .LVU365
 1256               		.cfi_endproc
 1257               	.LFE22:
 1259               		.section	.progmem.data.__c.1830,"a"
 1262               	__c.1830:
 1263 0000 7062 7566 		.string	"pbuf: full\n"
 1263      3A20 6675 
 1263      6C6C 0A00 
 1264               		.section	.data.parity.1946,"aw"
 1267               	parity.1946:
 1268 0000 01        		.byte	1
 1269               		.section	.bss.data.1945,"aw",@nobits
 1272               	data.1945:
 1273 0000 00        		.zero	1
 1274               		.section	.bss.state.1944,"aw",@nobits
 1277               	state.1944:
 1278 0000 00        		.zero	1
 1279               	.global	ps2_error
 1280               		.section	.bss.ps2_error,"aw",@nobits
 1283               	ps2_error:
 1284 0000 00        		.zero	1
 1285               		.section	.bss.pbuf_tail,"aw",@nobits
 1288               	pbuf_tail:
 1289 0000 0000      		.zero	2
 1290               		.section	.bss.pbuf_head,"aw",@nobits
 1293               	pbuf_head:
 1294 0000 0000      		.zero	2
 1295               		.section	.bss.pbuf,"aw",@nobits
 1298               	pbuf:
 1299 0000 0000 0000 		.zero	64
 1299      0000 0000 
 1299      0000 0000 
 1299      0000 0000 
 1299      0000 0000 
 1300               		.text
 1301               	.Letext0:
 1302               		.file 5 "/usr/avr/include/stdint.h"
 1303               		.file 6 "../../tmk_core/common/avr/xprintf.h"
 1304               		.file 7 "../../tmk_core/protocol/ps2_io.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ps2_interrupt.c
     /tmp/ccPn2Ait.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccPn2Ait.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccPn2Ait.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccPn2Ait.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccPn2Ait.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccPn2Ait.s:12     .text.pbuf_dequeue:0000000000000000 pbuf_dequeue
     /tmp/ccPn2Ait.s:1288   .bss.pbuf_tail:0000000000000000 pbuf_tail
     /tmp/ccPn2Ait.s:1293   .bss.pbuf_head:0000000000000000 pbuf_head
     /tmp/ccPn2Ait.s:1298   .bss.pbuf:0000000000000000 pbuf
     /tmp/ccPn2Ait.s:83     .text.wait_clock_lo:0000000000000000 wait_clock_lo
     /tmp/ccPn2Ait.s:160    .text.wait_clock_hi.constprop.0:0000000000000000 wait_clock_hi.constprop.0
     /tmp/ccPn2Ait.s:236    .text.ps2_host_init:0000000000000000 ps2_host_init
     /tmp/ccPn2Ait.s:279    .text.ps2_host_recv_response:0000000000000000 ps2_host_recv_response
     /tmp/ccPn2Ait.s:372    .text.ps2_host_send:0000000000000000 ps2_host_send
     /tmp/ccPn2Ait.s:1283   .bss.ps2_error:0000000000000000 ps2_error
     /tmp/ccPn2Ait.s:870    .text.ps2_host_recv:0000000000000000 ps2_host_recv
     /tmp/ccPn2Ait.s:937    .text.__vector_2:0000000000000000 __vector_2
     /tmp/ccPn2Ait.s:1277   .bss.state.1944:0000000000000000 state.1944
     /tmp/ccPn2Ait.s:1272   .bss.data.1945:0000000000000000 data.1945
     /tmp/ccPn2Ait.s:1267   .data.parity.1946:0000000000000000 parity.1946
     /tmp/ccPn2Ait.s:1262   .progmem.data.__c.1830:0000000000000000 __c.1830
     /tmp/ccPn2Ait.s:1225   .text.ps2_host_set_led:0000000000000000 ps2_host_set_led

UNDEFINED SYMBOLS
clock_in
clock_hi
data_hi
clock_lo
data_lo
data_in
xputs
__do_copy_data
__do_clear_bss
