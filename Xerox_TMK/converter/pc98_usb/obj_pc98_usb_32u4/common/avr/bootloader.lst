   1               		.file	"bootloader.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.bootloader_jump,"ax",@progbits
  11               	.global	bootloader_jump
  13               	bootloader_jump:
  14               	.LFB103:
  15               		.file 1 "../../tmk_core/common/avr/bootloader.c"
   1:../../tmk_core/common/avr/bootloader.c **** #include <stdint.h>
   2:../../tmk_core/common/avr/bootloader.c **** #include <stdbool.h>
   3:../../tmk_core/common/avr/bootloader.c **** #include <avr/io.h>
   4:../../tmk_core/common/avr/bootloader.c **** #include <avr/interrupt.h>
   5:../../tmk_core/common/avr/bootloader.c **** #include <avr/wdt.h>
   6:../../tmk_core/common/avr/bootloader.c **** #include <avr/boot.h>
   7:../../tmk_core/common/avr/bootloader.c **** #include <util/delay.h>
   8:../../tmk_core/common/avr/bootloader.c **** #include "bootloader.h"
   9:../../tmk_core/common/avr/bootloader.c **** 
  10:../../tmk_core/common/avr/bootloader.c **** #ifdef PROTOCOL_LUFA
  11:../../tmk_core/common/avr/bootloader.c **** #include <LUFA/Drivers/USB/USB.h>
  12:../../tmk_core/common/avr/bootloader.c **** #endif
  13:../../tmk_core/common/avr/bootloader.c **** 
  14:../../tmk_core/common/avr/bootloader.c **** 
  15:../../tmk_core/common/avr/bootloader.c **** /* Bootloader Size in *bytes*
  16:../../tmk_core/common/avr/bootloader.c ****  *
  17:../../tmk_core/common/avr/bootloader.c ****  * AVR Boot section size are defined by setting BOOTSZ fuse in fact. Consult with your MCU datashee
  18:../../tmk_core/common/avr/bootloader.c ****  * Note that 'Word'(2 bytes) size and address are used in datasheet while TMK uses 'Byte'.
  19:../../tmk_core/common/avr/bootloader.c ****  *
  20:../../tmk_core/common/avr/bootloader.c ****  * Size of Bootloaders in bytes:
  21:../../tmk_core/common/avr/bootloader.c ****  *   Atmel DFU loader(ATmega32U2)   4096
  22:../../tmk_core/common/avr/bootloader.c ****  *   Atmel DFU loader(ATmega32U4)   4096
  23:../../tmk_core/common/avr/bootloader.c ****  *   Atmel DFU loader(AT90USB128)   8192
  24:../../tmk_core/common/avr/bootloader.c ****  *   LUFA bootloader(ATmega32U4)    4096
  25:../../tmk_core/common/avr/bootloader.c ****  *   Arduino Caterina(ATmega32U4)   4096
  26:../../tmk_core/common/avr/bootloader.c ****  *   USBaspLoader(ATmega***)        2048
  27:../../tmk_core/common/avr/bootloader.c ****  *   Teensy   halfKay(ATmega32U4)   512
  28:../../tmk_core/common/avr/bootloader.c ****  *   Teensy++ halfKay(AT90USB128)   1024
  29:../../tmk_core/common/avr/bootloader.c ****  *
  30:../../tmk_core/common/avr/bootloader.c ****  *
  31:../../tmk_core/common/avr/bootloader.c ****  * AVR Boot section is located at the end of Flash memory.
  32:../../tmk_core/common/avr/bootloader.c ****  *
  33:../../tmk_core/common/avr/bootloader.c ****  * byte     ATMega32u4 with 4096-byte Boot section
  34:../../tmk_core/common/avr/bootloader.c ****  * 0x0000   +---------------+
  35:../../tmk_core/common/avr/bootloader.c ****  *          |               |
  36:../../tmk_core/common/avr/bootloader.c ****  *          |               |
  37:../../tmk_core/common/avr/bootloader.c ****  *          |  Application  | 28KB
  38:../../tmk_core/common/avr/bootloader.c ****  *          |               |
  39:../../tmk_core/common/avr/bootloader.c ****  *          =               =
  40:../../tmk_core/common/avr/bootloader.c ****  *          |               |
  41:../../tmk_core/common/avr/bootloader.c ****  * 0x7000   +---------------+ <---- BOOTLOADER_START
  42:../../tmk_core/common/avr/bootloader.c ****  *          |  Bootloader   | 4KB   BOOTLOADER_SIZE
  43:../../tmk_core/common/avr/bootloader.c ****  * 0x7FFF   +---------------+ <---- FLASHEND
  44:../../tmk_core/common/avr/bootloader.c ****  */
  45:../../tmk_core/common/avr/bootloader.c **** 
  46:../../tmk_core/common/avr/bootloader.c **** /* bootloader start address in byte */
  47:../../tmk_core/common/avr/bootloader.c **** #define BOOTLOADER_START      (FLASHEND - bootloader_size() + 1)
  48:../../tmk_core/common/avr/bootloader.c **** 
  49:../../tmk_core/common/avr/bootloader.c **** /* boot section size in byte */
  50:../../tmk_core/common/avr/bootloader.c **** static inline uint16_t bootloader_size(void)
  51:../../tmk_core/common/avr/bootloader.c **** {
  52:../../tmk_core/common/avr/bootloader.c **** #if defined(BOOTLOADER_SIZE)
  53:../../tmk_core/common/avr/bootloader.c ****     return BOOTLOADER_SIZE;
  54:../../tmk_core/common/avr/bootloader.c **** #else
  55:../../tmk_core/common/avr/bootloader.c ****     #if defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega32U2__) || \
  56:../../tmk_core/common/avr/bootloader.c ****             defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega16U2__) || \
  57:../../tmk_core/common/avr/bootloader.c ****             defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__)
  58:../../tmk_core/common/avr/bootloader.c ****         uint8_t hfuse = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
  59:../../tmk_core/common/avr/bootloader.c ****         switch ((hfuse >> 1) & 3) {
  60:../../tmk_core/common/avr/bootloader.c ****             case 0: return 4096;
  61:../../tmk_core/common/avr/bootloader.c ****             case 1: return 2048;
  62:../../tmk_core/common/avr/bootloader.c ****             case 2: return 1024;
  63:../../tmk_core/common/avr/bootloader.c ****             case 3: return 512;
  64:../../tmk_core/common/avr/bootloader.c ****         }
  65:../../tmk_core/common/avr/bootloader.c ****         return 4096;
  66:../../tmk_core/common/avr/bootloader.c ****     #elif defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB647__) || \
  67:../../tmk_core/common/avr/bootloader.c ****             defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__)
  68:../../tmk_core/common/avr/bootloader.c ****         uint8_t hfuse = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
  69:../../tmk_core/common/avr/bootloader.c ****         switch ((hfuse >> 1) & 3) {
  70:../../tmk_core/common/avr/bootloader.c ****             case 0: return 8192;
  71:../../tmk_core/common/avr/bootloader.c ****             case 1: return 4096;
  72:../../tmk_core/common/avr/bootloader.c ****             case 2: return 2048;
  73:../../tmk_core/common/avr/bootloader.c ****             case 3: return 1024;
  74:../../tmk_core/common/avr/bootloader.c ****         }
  75:../../tmk_core/common/avr/bootloader.c ****         return 8192;
  76:../../tmk_core/common/avr/bootloader.c ****     #else
  77:../../tmk_core/common/avr/bootloader.c ****         #error Set Boot section size to BOOTLOADER_SIZE in config.h
  78:../../tmk_core/common/avr/bootloader.c ****     #endif
  79:../../tmk_core/common/avr/bootloader.c **** #endif
  80:../../tmk_core/common/avr/bootloader.c **** }
  81:../../tmk_core/common/avr/bootloader.c **** 
  82:../../tmk_core/common/avr/bootloader.c **** 
  83:../../tmk_core/common/avr/bootloader.c **** /*
  84:../../tmk_core/common/avr/bootloader.c ****  * Entering the Bootloader via Software
  85:../../tmk_core/common/avr/bootloader.c ****  * http://www.fourwalledcubicle.com/files/LUFA/Doc/120730/html/_page__software_bootloader_start.htm
  86:../../tmk_core/common/avr/bootloader.c ****  */
  87:../../tmk_core/common/avr/bootloader.c **** #define BOOTLOADER_RESET_KEY 0xB007B007
  88:../../tmk_core/common/avr/bootloader.c **** uint32_t reset_key  __attribute__ ((section (".noinit")));
  89:../../tmk_core/common/avr/bootloader.c **** 
  90:../../tmk_core/common/avr/bootloader.c **** /* initialize MCU status by watchdog reset */
  91:../../tmk_core/common/avr/bootloader.c **** void bootloader_jump(void) {
  16               		.loc 1 91 28 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  92:../../tmk_core/common/avr/bootloader.c **** #ifdef PROTOCOL_LUFA
  93:../../tmk_core/common/avr/bootloader.c ****     USB_Disable();
  22               		.loc 1 93 5 view .LVU1
  23 0000 0E94 0000 		call USB_Disable
  24               	.LVL0:
  94:../../tmk_core/common/avr/bootloader.c ****     cli();
  25               		.loc 1 94 5 view .LVU2
  26               	/* #APP */
  27               	 ;  94 "../../tmk_core/common/avr/bootloader.c" 1
  28 0004 F894      		cli
  29               	 ;  0 "" 2
  95:../../tmk_core/common/avr/bootloader.c **** #endif
  96:../../tmk_core/common/avr/bootloader.c **** 
  97:../../tmk_core/common/avr/bootloader.c **** #ifdef PROTOCOL_PJRC
  98:../../tmk_core/common/avr/bootloader.c ****     cli();
  99:../../tmk_core/common/avr/bootloader.c ****     UDCON = 1;
 100:../../tmk_core/common/avr/bootloader.c ****     USBCON = (1<<FRZCLK);
 101:../../tmk_core/common/avr/bootloader.c ****     UCSR1B = 0;
 102:../../tmk_core/common/avr/bootloader.c ****     _delay_ms(5);
 103:../../tmk_core/common/avr/bootloader.c **** #endif
 104:../../tmk_core/common/avr/bootloader.c **** 
 105:../../tmk_core/common/avr/bootloader.c **** #ifndef NO_BOOTLOADER_CATERINA_BOOTKEY
 106:../../tmk_core/common/avr/bootloader.c ****     // Set bootkey for Arduino Leonardo and Pro Micro bootloader
 107:../../tmk_core/common/avr/bootloader.c ****     // Watchdog reset with bootkey causes the bootloader to enter program mode instead of starting 
 108:../../tmk_core/common/avr/bootloader.c ****     // https://github.com/arduino/ArduinoCore-avr/blob/master/bootloaders/caterina/Caterina.c#L68-L
 109:../../tmk_core/common/avr/bootloader.c ****     // https://github.com/sparkfun/SF32u4_boards/blob/master/sparkfun/avr/bootloaders/caterina/Cate
 110:../../tmk_core/common/avr/bootloader.c ****     *(volatile uint16_t *)0x0800 = 0x7777;
  30               		.loc 1 110 5 view .LVU3
  31               		.loc 1 110 34 is_stmt 0 view .LVU4
  32               	/* #NOAPP */
  33 0006 87E7      		ldi r24,lo8(119)
  34 0008 97E7      		ldi r25,lo8(119)
  35 000a 9093 0108 		sts 2048+1,r25
  36 000e 8093 0008 		sts 2048,r24
 111:../../tmk_core/common/avr/bootloader.c **** #endif
 112:../../tmk_core/common/avr/bootloader.c **** 
 113:../../tmk_core/common/avr/bootloader.c ****     // watchdog reset
 114:../../tmk_core/common/avr/bootloader.c ****     reset_key = BOOTLOADER_RESET_KEY;
  37               		.loc 1 114 5 is_stmt 1 view .LVU5
  38               		.loc 1 114 15 is_stmt 0 view .LVU6
  39 0012 87E0      		ldi r24,lo8(7)
  40 0014 90EB      		ldi r25,lo8(-80)
  41 0016 DC01      		movw r26,r24
  42 0018 8093 0000 		sts reset_key,r24
  43 001c 9093 0000 		sts reset_key+1,r25
  44 0020 A093 0000 		sts reset_key+2,r26
  45 0024 B093 0000 		sts reset_key+3,r27
 115:../../tmk_core/common/avr/bootloader.c ****     wdt_enable(WDTO_250MS);
  46               		.loc 1 115 5 is_stmt 1 view .LVU7
  47               	.LVL1:
  48               	.LBB12:
  49               	.LBI12:
  50               		.file 2 "/usr/avr/include/avr/wdt.h"
   1:/usr/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/avr/include/avr/wdt.h **** 
   5:/usr/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/avr/include/avr/wdt.h **** 
   8:/usr/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/avr/include/avr/wdt.h **** 
  11:/usr/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/avr/include/avr/wdt.h ****      distribution.
  15:/usr/avr/include/avr/wdt.h **** 
  16:/usr/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/avr/include/avr/wdt.h **** 
  20:/usr/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/avr/include/avr/wdt.h **** 
  32:/usr/avr/include/avr/wdt.h **** /* $Id: wdt.h 2503 2016-02-07 22:59:47Z joerg_wunsch $ */
  33:/usr/avr/include/avr/wdt.h **** 
  34:/usr/avr/include/avr/wdt.h **** /*
  35:/usr/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/avr/include/avr/wdt.h ****  */
  37:/usr/avr/include/avr/wdt.h **** 
  38:/usr/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/avr/include/avr/wdt.h **** 
  41:/usr/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/avr/include/avr/wdt.h **** 
  44:/usr/avr/include/avr/wdt.h **** /** \file */
  45:/usr/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/avr/include/avr/wdt.h **** 
  48:/usr/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/avr/include/avr/wdt.h **** 
  57:/usr/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/avr/include/avr/wdt.h **** 
  61:/usr/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/avr/include/avr/wdt.h ****     the following:
  68:/usr/avr/include/avr/wdt.h **** 
  69:/usr/avr/include/avr/wdt.h ****     \code
  70:/usr/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/avr/include/avr/wdt.h **** 
  73:/usr/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/avr/include/avr/wdt.h **** 
  75:/usr/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/avr/include/avr/wdt.h ****     {
  80:/usr/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/avr/include/avr/wdt.h ****     }
  84:/usr/avr/include/avr/wdt.h ****     \endcode
  85:/usr/avr/include/avr/wdt.h **** 
  86:/usr/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/avr/include/avr/wdt.h **** */
  91:/usr/avr/include/avr/wdt.h **** 
  92:/usr/avr/include/avr/wdt.h **** /**
  93:/usr/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/avr/include/avr/wdt.h **** */
  98:/usr/avr/include/avr/wdt.h **** 
  99:/usr/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/avr/include/avr/wdt.h **** 
 101:/usr/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/avr/include/avr/wdt.h **** 
 103:/usr/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/avr/include/avr/wdt.h **** #else
 106:/usr/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/avr/include/avr/wdt.h **** #endif
 108:/usr/avr/include/avr/wdt.h **** 
 109:/usr/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/avr/include/avr/wdt.h **** #else
 114:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/avr/include/avr/wdt.h **** #endif
 116:/usr/avr/include/avr/wdt.h **** 
 117:/usr/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/avr/include/avr/wdt.h **** #else
 120:/usr/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/avr/include/avr/wdt.h **** #endif
 122:/usr/avr/include/avr/wdt.h **** 
 123:/usr/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/avr/include/avr/wdt.h **** 
 125:/usr/avr/include/avr/wdt.h **** 
 126:/usr/avr/include/avr/wdt.h **** /**
 127:/usr/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/avr/include/avr/wdt.h **** 
 134:/usr/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/avr/include/avr/wdt.h **** */
 136:/usr/avr/include/avr/wdt.h **** 
 137:/usr/avr/include/avr/wdt.h **** 
 138:/usr/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/avr/include/avr/wdt.h **** 
 140:/usr/avr/include/avr/wdt.h **** /*
 141:/usr/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 142:/usr/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 143:/usr/avr/include/avr/wdt.h ****    registers to the CCP register
 144:/usr/avr/include/avr/wdt.h **** ** At the same time,
 145:/usr/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 146:/usr/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 147:/usr/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 148:/usr/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 149:/usr/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 150:/usr/avr/include/avr/wdt.h ****    sync is finished).
 151:/usr/avr/include/avr/wdt.h **** */
 152:/usr/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 153:/usr/avr/include/avr/wdt.h **** do { \
 154:/usr/avr/include/avr/wdt.h **** uint8_t temp; \
 155:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 156:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 157:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 158:/usr/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 159:/usr/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 160:/usr/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 161:/usr/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 162:/usr/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 163:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 164:/usr/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 165:/usr/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 166:/usr/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 167:/usr/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 168:/usr/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 169:/usr/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 170:/usr/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 171:/usr/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 172:/usr/avr/include/avr/wdt.h ****     : "r0" \
 173:/usr/avr/include/avr/wdt.h **** ); \
 174:/usr/avr/include/avr/wdt.h **** } while(0)
 175:/usr/avr/include/avr/wdt.h **** 
 176:/usr/avr/include/avr/wdt.h **** #define wdt_disable() \
 177:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 178:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 179:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 180:/usr/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 181:/usr/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 182:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 183:/usr/avr/include/avr/wdt.h ****     : \
 184:/usr/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 185:/usr/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 186:/usr/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 187:/usr/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 188:/usr/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 189:/usr/avr/include/avr/wdt.h ****     : "r0" \
 190:/usr/avr/include/avr/wdt.h **** );
 191:/usr/avr/include/avr/wdt.h **** 
 192:/usr/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 193:/usr/avr/include/avr/wdt.h **** 
 194:/usr/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 195:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 196:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 197:/usr/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 198:/usr/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 199:/usr/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 200:/usr/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 201:/usr/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 202:/usr/avr/include/avr/wdt.h ****     : /* no outputs */  \
 203:/usr/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 204:/usr/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 205:/usr/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 206:/usr/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 207:/usr/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 208:/usr/avr/include/avr/wdt.h ****     : "r16" \
 209:/usr/avr/include/avr/wdt.h **** )
 210:/usr/avr/include/avr/wdt.h **** 
 211:/usr/avr/include/avr/wdt.h **** #define wdt_disable() \
 212:/usr/avr/include/avr/wdt.h **** do { \
 213:/usr/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 214:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 215:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 216:/usr/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 217:/usr/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 218:/usr/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 219:/usr/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 220:/usr/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 221:/usr/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 222:/usr/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 223:/usr/avr/include/avr/wdt.h ****     : /*no output */ \
 224:/usr/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 225:/usr/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 226:/usr/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 227:/usr/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 228:/usr/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 229:/usr/avr/include/avr/wdt.h ****     : "r16" \
 230:/usr/avr/include/avr/wdt.h **** ); \
 231:/usr/avr/include/avr/wdt.h **** }while(0)
 232:/usr/avr/include/avr/wdt.h **** 
 233:/usr/avr/include/avr/wdt.h **** #elif defined(CCP)
 234:/usr/avr/include/avr/wdt.h **** 
 235:/usr/avr/include/avr/wdt.h **** static __inline__
 236:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 237:/usr/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 238:/usr/avr/include/avr/wdt.h **** {
 239:/usr/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 240:/usr/avr/include/avr/wdt.h **** 	{
 241:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 242:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 243:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 244:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 245:/usr/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 246:/usr/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 247:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 248:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 249:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 250:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 251:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 252:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 253:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 254:/usr/avr/include/avr/wdt.h **** 			: "r0"
 255:/usr/avr/include/avr/wdt.h **** 			);
 256:/usr/avr/include/avr/wdt.h **** 	}
 257:/usr/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 258:/usr/avr/include/avr/wdt.h **** 	{
 259:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 260:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 261:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 262:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 263:/usr/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 264:/usr/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 265:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 266:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 267:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 268:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 269:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 270:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 271:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 272:/usr/avr/include/avr/wdt.h **** 			: "r0"
 273:/usr/avr/include/avr/wdt.h **** 			);
 274:/usr/avr/include/avr/wdt.h **** 	}
 275:/usr/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 276:/usr/avr/include/avr/wdt.h **** 	{
 277:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 278:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 279:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 280:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 281:/usr/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 282:/usr/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 283:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 284:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 285:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 286:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 287:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 288:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 289:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 290:/usr/avr/include/avr/wdt.h **** 			: "r0"
 291:/usr/avr/include/avr/wdt.h **** 			);
 292:/usr/avr/include/avr/wdt.h **** 	}
 293:/usr/avr/include/avr/wdt.h **** 	else
 294:/usr/avr/include/avr/wdt.h ****  	{
 295:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 296:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 297:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 298:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 299:/usr/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 300:/usr/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 301:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 302:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 303:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 304:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 305:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 306:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 307:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 308:/usr/avr/include/avr/wdt.h **** 			: "r0"
 309:/usr/avr/include/avr/wdt.h **** 			);
 310:/usr/avr/include/avr/wdt.h **** 	}
 311:/usr/avr/include/avr/wdt.h **** }
 312:/usr/avr/include/avr/wdt.h **** 
 313:/usr/avr/include/avr/wdt.h **** static __inline__
 314:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 315:/usr/avr/include/avr/wdt.h **** void wdt_disable (void)
 316:/usr/avr/include/avr/wdt.h **** {
 317:/usr/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 318:/usr/avr/include/avr/wdt.h **** 	{
 319:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 320:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 321:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 322:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 323:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 324:/usr/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 325:/usr/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 326:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 327:/usr/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 328:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 330:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 331:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 334:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 335:/usr/avr/include/avr/wdt.h **** 				: "r0"
 336:/usr/avr/include/avr/wdt.h **** 				);
 337:/usr/avr/include/avr/wdt.h **** 	}
 338:/usr/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 339:/usr/avr/include/avr/wdt.h **** 	{
 340:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 341:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 342:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 343:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 344:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 345:/usr/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 346:/usr/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 347:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 348:/usr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 349:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 350:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 351:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 352:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 353:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 354:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 355:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 356:/usr/avr/include/avr/wdt.h **** 				: "r0"
 357:/usr/avr/include/avr/wdt.h **** 				);
 358:/usr/avr/include/avr/wdt.h **** 	}
 359:/usr/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 360:/usr/avr/include/avr/wdt.h **** 	{
 361:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 362:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 363:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 364:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 365:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 366:/usr/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 367:/usr/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 368:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 369:/usr/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 370:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 371:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 372:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 373:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 374:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 375:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 376:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 377:/usr/avr/include/avr/wdt.h **** 				: "r0"
 378:/usr/avr/include/avr/wdt.h **** 				);
 379:/usr/avr/include/avr/wdt.h **** 	}
 380:/usr/avr/include/avr/wdt.h **** 	else
 381:/usr/avr/include/avr/wdt.h **** 	{
 382:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 383:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 384:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 385:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 386:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 387:/usr/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 388:/usr/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 389:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 390:/usr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 391:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 392:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 393:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 394:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 395:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 396:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 397:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 398:/usr/avr/include/avr/wdt.h **** 				: "r0"
 399:/usr/avr/include/avr/wdt.h **** 				);
 400:/usr/avr/include/avr/wdt.h **** 	}
 401:/usr/avr/include/avr/wdt.h **** }
 402:/usr/avr/include/avr/wdt.h **** 
 403:/usr/avr/include/avr/wdt.h **** #else
 404:/usr/avr/include/avr/wdt.h **** 
 405:/usr/avr/include/avr/wdt.h **** static __inline__
 406:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 407:/usr/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
  51               		.loc 2 407 6 view .LVU8
  52               	.LBB13:
 408:/usr/avr/include/avr/wdt.h **** {
 409:/usr/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
  53               		.loc 2 409 2 view .LVU9
 410:/usr/avr/include/avr/wdt.h **** 	{
 411:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 412:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 413:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 414:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 415:/usr/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 416:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 417:/usr/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 418:/usr/avr/include/avr/wdt.h **** 				: /* no outputs */
 419:/usr/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 420:/usr/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 421:/usr/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 422:/usr/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 423:/usr/avr/include/avr/wdt.h **** 				: "r0"
 424:/usr/avr/include/avr/wdt.h **** 		);
 425:/usr/avr/include/avr/wdt.h **** 	}
 426:/usr/avr/include/avr/wdt.h **** 	else
 427:/usr/avr/include/avr/wdt.h **** 	{
 428:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
  54               		.loc 2 428 3 view .LVU10
  55 0028 88E1      		ldi r24,lo8(24)
  56 002a 9CE0      		ldi r25,lo8(12)
  57               	/* #APP */
  58               	 ;  428 "/usr/avr/include/avr/wdt.h" 1
  59 002c 0FB6      		in __tmp_reg__,__SREG__
  60 002e F894      		cli
  61 0030 A895      		wdr
  62 0032 8093 6000 		sts 96, r24
  63 0036 0FBE      		out __SREG__,__tmp_reg__
  64 0038 9093 6000 		sts 96, r25
  65               	 	
  66               	 ;  0 "" 2
  67               	/* #NOAPP */
  68               	.L2:
  69               	.LBE13:
  70               	.LBE12:
 116:../../tmk_core/common/avr/bootloader.c ****     for (;;);
  71               		.loc 1 116 5 discriminator 1 view .LVU11
  72               		.loc 1 116 13 discriminator 1 view .LVU12
  73 003c 00C0      		rjmp .L2
  74               		.cfi_endproc
  75               	.LFE103:
  77               		.section	.init3,"ax",@progbits
  78               	.global	bootloader_jump_after_watchdog_reset
  80               	bootloader_jump_after_watchdog_reset:
  81               	.LFB104:
 117:../../tmk_core/common/avr/bootloader.c **** }
 118:../../tmk_core/common/avr/bootloader.c **** 
 119:../../tmk_core/common/avr/bootloader.c **** 
 120:../../tmk_core/common/avr/bootloader.c **** /* this runs before main() */
 121:../../tmk_core/common/avr/bootloader.c **** void bootloader_jump_after_watchdog_reset(void) __attribute__ ((used, naked, section (".init3")));
 122:../../tmk_core/common/avr/bootloader.c **** void bootloader_jump_after_watchdog_reset(void)
 123:../../tmk_core/common/avr/bootloader.c **** {
  82               		.loc 1 123 1 view -0
  83               		.cfi_startproc
  84               	/* prologue: naked */
  85               	/* frame size = 0 */
  86               	/* stack size = 0 */
  87               	.L__stack_usage = 0
 124:../../tmk_core/common/avr/bootloader.c ****     if ((MCUSR & (1<<WDRF)) && reset_key == BOOTLOADER_RESET_KEY) {
  88               		.loc 1 124 5 view .LVU14
  89               		.loc 1 124 8 is_stmt 0 view .LVU15
  90 0000 04B6      		in __tmp_reg__,0x34
  91 0002 03FE      		sbrs __tmp_reg__,3
  92 0004 00C0      		rjmp .L3
  93               		.loc 1 124 29 discriminator 1 view .LVU16
  94 0006 8091 0000 		lds r24,reset_key
  95 000a 9091 0000 		lds r25,reset_key+1
  96 000e A091 0000 		lds r26,reset_key+2
  97 0012 B091 0000 		lds r27,reset_key+3
  98 0016 8730      		cpi r24,7
  99 0018 904B      		sbci r25,-80
 100 001a A740      		sbci r26,7
 101 001c B04B      		sbci r27,-80
 102 001e 01F4      		brne .L3
 125:../../tmk_core/common/avr/bootloader.c ****         reset_key = 0;
 103               		.loc 1 125 9 is_stmt 1 view .LVU17
 104               		.loc 1 125 19 is_stmt 0 view .LVU18
 105 0020 1092 0000 		sts reset_key,__zero_reg__
 106 0024 1092 0000 		sts reset_key+1,__zero_reg__
 107 0028 1092 0000 		sts reset_key+2,__zero_reg__
 108 002c 1092 0000 		sts reset_key+3,__zero_reg__
 126:../../tmk_core/common/avr/bootloader.c **** 
 127:../../tmk_core/common/avr/bootloader.c ****         // some of bootloaders may need to preseve?
 128:../../tmk_core/common/avr/bootloader.c ****         MCUSR = 0;
 109               		.loc 1 128 9 is_stmt 1 view .LVU19
 110               		.loc 1 128 15 is_stmt 0 view .LVU20
 111 0030 14BE      		out 0x34,__zero_reg__
 129:../../tmk_core/common/avr/bootloader.c **** 
 130:../../tmk_core/common/avr/bootloader.c ****         // disable watchdog timer
 131:../../tmk_core/common/avr/bootloader.c ****         wdt_disable();
 112               		.loc 1 131 9 is_stmt 1 view .LVU21
 113               	.LBB14:
 114               	.LBI14:
 429:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 433:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 434:/usr/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 435:/usr/avr/include/avr/wdt.h **** 				: /* no outputs */
 436:/usr/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 437:/usr/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 438:/usr/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 439:/usr/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 440:/usr/avr/include/avr/wdt.h **** 				: "r0"
 441:/usr/avr/include/avr/wdt.h **** 		);
 442:/usr/avr/include/avr/wdt.h **** 	}
 443:/usr/avr/include/avr/wdt.h **** }
 444:/usr/avr/include/avr/wdt.h **** 
 445:/usr/avr/include/avr/wdt.h **** static __inline__
 446:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 447:/usr/avr/include/avr/wdt.h **** void wdt_disable (void)
 115               		.loc 2 447 6 view .LVU22
 116               	.LBE14:
 448:/usr/avr/include/avr/wdt.h **** {
 449:/usr/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 117               		.loc 2 449 2 view .LVU23
 118               	.LBB16:
 119               	.LBB15:
 450:/usr/avr/include/avr/wdt.h **** 	{
 451:/usr/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 452:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 453:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 454:/usr/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 455:/usr/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 456:/usr/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 457:/usr/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 458:/usr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 459:/usr/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 460:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 461:/usr/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 462:/usr/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 463:/usr/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 464:/usr/avr/include/avr/wdt.h **** 				: "r0"
 465:/usr/avr/include/avr/wdt.h **** 		);
 466:/usr/avr/include/avr/wdt.h **** 	}
 467:/usr/avr/include/avr/wdt.h **** 	else
 468:/usr/avr/include/avr/wdt.h **** 	{
 469:/usr/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 120               		.loc 2 469 9 view .LVU24
 470:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 121               		.loc 2 470 3 view .LVU25
 122               	/* #APP */
 123               	 ;  470 "/usr/avr/include/avr/wdt.h" 1
 124 0032 0FB6      		in __tmp_reg__,__SREG__
 125 0034 F894      		cli
 126 0036 A895      		wdr
 127 0038 8091 6000 		lds r24,96
 128 003c 8861      		ori r24,24
 129 003e 8093 6000 		sts 96,r24
 130 0042 1092 6000 		sts 96,__zero_reg__
 131 0046 0FBE      		out __SREG__,__tmp_reg__
 132               		
 133               	 ;  0 "" 2
 134               	/* #NOAPP */
 135               	.LBE15:
 136               	.LBE16:
 132:../../tmk_core/common/avr/bootloader.c **** 
 133:../../tmk_core/common/avr/bootloader.c **** #ifndef NO_BOOTLOADER_CATERINA_BOOTKEY
 134:../../tmk_core/common/avr/bootloader.c ****         // Clear bootkey of Caterina bootloader for other bootloaders
 135:../../tmk_core/common/avr/bootloader.c ****         // Leonardo and Pro Micro with Arduino default fuse setting don't reach here
 136:../../tmk_core/common/avr/bootloader.c ****         // because bootloader section are executed before application everytime.
 137:../../tmk_core/common/avr/bootloader.c ****         *(volatile uint16_t *)0x0800 = 0;
 137               		.loc 1 137 9 view .LVU26
 138               		.loc 1 137 38 is_stmt 0 view .LVU27
 139 0048 1092 0108 		sts 2048+1,__zero_reg__
 140 004c 1092 0008 		sts 2048,__zero_reg__
 138:../../tmk_core/common/avr/bootloader.c **** #endif
 139:../../tmk_core/common/avr/bootloader.c **** 
 140:../../tmk_core/common/avr/bootloader.c ****         // This is compled into 'icall', address should be in word unit, not byte.
 141:../../tmk_core/common/avr/bootloader.c ****         ((void (*)(void))( (uint16_t)(BOOTLOADER_START / 2) ))();
 141               		.loc 1 141 9 is_stmt 1 view .LVU28
  53:../../tmk_core/common/avr/bootloader.c **** #else
 142               		.loc 1 53 5 view .LVU29
 143               		.loc 1 141 10 is_stmt 0 view .LVU30
 144 0050 E0E0      		ldi r30,0
 145 0052 F8E3      		ldi r31,lo8(56)
 146 0054 0995      		icall
 147               	.LVL2:
 148               	.L3:
 149               	/* epilogue start */
 142:../../tmk_core/common/avr/bootloader.c ****     }
 143:../../tmk_core/common/avr/bootloader.c **** }
 150               		.loc 1 143 1 view .LVU31
 151               		.cfi_endproc
 152               	.LFE104:
 154               	.global	reset_key
 155               		.section	.noinit,"aw"
 158               	reset_key:
 159 0000 0000 0000 		.zero	4
 160               		.text
 161               	.Letext0:
 162               		.file 3 "/usr/avr/include/stdint.h"
 163               		.file 4 "../../tmk_core/protocol/lufa/lufa-abcminiuser/LUFA/Drivers/USB/Core/AVR8/../StdRequestTyp
 164               		.file 5 "../../tmk_core/protocol/lufa/lufa-abcminiuser/LUFA/Drivers/USB/Core/AVR8/../DeviceStandar
 165               		.file 6 "../../tmk_core/protocol/lufa/lufa-abcminiuser/LUFA/Drivers/USB/Core/USBTask.h"
 166               		.file 7 "../../tmk_core/protocol/lufa/lufa-abcminiuser/LUFA/Drivers/USB/Core/HostStandardReq.h"
 167               		.file 8 "/usr/avr/include/stdio.h"
 168               		.file 9 "../../tmk_core/protocol/lufa/lufa-abcminiuser/LUFA/Drivers/USB/Core/AVR8/USBController_AV
DEFINED SYMBOLS
                            *ABS*:0000000000000000 bootloader.c
     /tmp/ccy2DPVn.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccy2DPVn.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccy2DPVn.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccy2DPVn.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccy2DPVn.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccy2DPVn.s:13     .text.bootloader_jump:0000000000000000 bootloader_jump
     /tmp/ccy2DPVn.s:158    .noinit:0000000000000000 reset_key
     /tmp/ccy2DPVn.s:80     .init3:0000000000000000 bootloader_jump_after_watchdog_reset

UNDEFINED SYMBOLS
USB_Disable
