   1               		.file	"xt_interrupt.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.xt_host_init,"ax",@progbits
  11               	.global	xt_host_init
  13               	xt_host_init:
  14               	.LFB14:
  15               		.file 1 "../../tmk_core/protocol/xt_interrupt.c"
   1:../../tmk_core/protocol/xt_interrupt.c **** /*
   2:../../tmk_core/protocol/xt_interrupt.c **** Copyright 2018 Jun WAKO <wakojun@gmail.com>
   3:../../tmk_core/protocol/xt_interrupt.c **** Copyright 2016 Ethan Apodaca <papodaca@gmail.com>
   4:../../tmk_core/protocol/xt_interrupt.c **** 
   5:../../tmk_core/protocol/xt_interrupt.c **** This software is licensed with a Modified BSD License.
   6:../../tmk_core/protocol/xt_interrupt.c **** All of this is supposed to be Free Software, Open Source, DFSG-free,
   7:../../tmk_core/protocol/xt_interrupt.c **** GPL-compatible, and OK to use in both free and proprietary applications.
   8:../../tmk_core/protocol/xt_interrupt.c **** Additions and corrections to this file are welcome.
   9:../../tmk_core/protocol/xt_interrupt.c **** 
  10:../../tmk_core/protocol/xt_interrupt.c **** 
  11:../../tmk_core/protocol/xt_interrupt.c **** Redistribution and use in source and binary forms, with or without
  12:../../tmk_core/protocol/xt_interrupt.c **** modification, are permitted provided that the following conditions are met:
  13:../../tmk_core/protocol/xt_interrupt.c **** 
  14:../../tmk_core/protocol/xt_interrupt.c **** * Redistributions of source code must retain the above copyright
  15:../../tmk_core/protocol/xt_interrupt.c ****   notice, this list of conditions and the following disclaimer.
  16:../../tmk_core/protocol/xt_interrupt.c **** 
  17:../../tmk_core/protocol/xt_interrupt.c **** * Redistributions in binary form must reproduce the above copyright
  18:../../tmk_core/protocol/xt_interrupt.c ****   notice, this list of conditions and the following disclaimer in
  19:../../tmk_core/protocol/xt_interrupt.c ****   the documentation and/or other materials provided with the
  20:../../tmk_core/protocol/xt_interrupt.c ****   distribution.
  21:../../tmk_core/protocol/xt_interrupt.c **** 
  22:../../tmk_core/protocol/xt_interrupt.c **** * Neither the name of the copyright holders nor the names of
  23:../../tmk_core/protocol/xt_interrupt.c ****   contributors may be used to endorse or promote products derived
  24:../../tmk_core/protocol/xt_interrupt.c ****   from this software without specific prior written permission.
  25:../../tmk_core/protocol/xt_interrupt.c **** 
  26:../../tmk_core/protocol/xt_interrupt.c **** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  27:../../tmk_core/protocol/xt_interrupt.c **** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  28:../../tmk_core/protocol/xt_interrupt.c **** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  29:../../tmk_core/protocol/xt_interrupt.c **** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  30:../../tmk_core/protocol/xt_interrupt.c **** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  31:../../tmk_core/protocol/xt_interrupt.c **** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  32:../../tmk_core/protocol/xt_interrupt.c **** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  33:../../tmk_core/protocol/xt_interrupt.c **** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  34:../../tmk_core/protocol/xt_interrupt.c **** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  35:../../tmk_core/protocol/xt_interrupt.c **** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  36:../../tmk_core/protocol/xt_interrupt.c **** POSSIBILITY OF SUCH DAMAGE.
  37:../../tmk_core/protocol/xt_interrupt.c **** */
  38:../../tmk_core/protocol/xt_interrupt.c **** 
  39:../../tmk_core/protocol/xt_interrupt.c **** #include <stdbool.h>
  40:../../tmk_core/protocol/xt_interrupt.c **** #include <avr/interrupt.h>
  41:../../tmk_core/protocol/xt_interrupt.c **** #include <util/delay.h>
  42:../../tmk_core/protocol/xt_interrupt.c **** #include "xt.h"
  43:../../tmk_core/protocol/xt_interrupt.c **** #include "wait.h"
  44:../../tmk_core/protocol/xt_interrupt.c **** #include "print.h"
  45:../../tmk_core/protocol/xt_interrupt.c **** #include "ringbuf.h"
  46:../../tmk_core/protocol/xt_interrupt.c **** 
  47:../../tmk_core/protocol/xt_interrupt.c **** 
  48:../../tmk_core/protocol/xt_interrupt.c **** #define BUF_SIZE 16
  49:../../tmk_core/protocol/xt_interrupt.c **** static uint8_t buf[BUF_SIZE];
  50:../../tmk_core/protocol/xt_interrupt.c **** static ringbuf_t rb = {
  51:../../tmk_core/protocol/xt_interrupt.c ****     .buffer = buf,
  52:../../tmk_core/protocol/xt_interrupt.c ****     .head = 0,
  53:../../tmk_core/protocol/xt_interrupt.c ****     .tail = 0,
  54:../../tmk_core/protocol/xt_interrupt.c ****     .size_mask = BUF_SIZE - 1
  55:../../tmk_core/protocol/xt_interrupt.c **** };
  56:../../tmk_core/protocol/xt_interrupt.c **** 
  57:../../tmk_core/protocol/xt_interrupt.c **** void xt_host_init(void)
  58:../../tmk_core/protocol/xt_interrupt.c **** {
  16               		.loc 1 58 1 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  59:../../tmk_core/protocol/xt_interrupt.c ****     XT_INT_INIT();
  22               		.loc 1 59 5 view .LVU1
  23               		.loc 1 59 5 view .LVU2
  24 0000 E9E6      		ldi r30,lo8(105)
  25 0002 F0E0      		ldi r31,0
  26 0004 8081      		ld r24,Z
  27 0006 8860      		ori r24,lo8(8)
  28 0008 8083      		st Z,r24
  60:../../tmk_core/protocol/xt_interrupt.c ****     XT_INT_OFF();
  29               		.loc 1 60 5 view .LVU3
  30               		.loc 1 60 5 view .LVU4
  31 000a E998      		cbi 0x1d,1
  61:../../tmk_core/protocol/xt_interrupt.c **** 
  62:../../tmk_core/protocol/xt_interrupt.c ****     /* hard reset */
  63:../../tmk_core/protocol/xt_interrupt.c **** #ifdef XT_RESET
  64:../../tmk_core/protocol/xt_interrupt.c ****     XT_RESET();
  32               		.loc 1 64 5 view .LVU5
  33               		.loc 1 64 5 view .LVU6
  34 000c 2F98      		cbi 0x5,7
  35               		.loc 1 64 5 view .LVU7
  36 000e 279A      		sbi 0x4,7
  37               		.loc 1 64 5 view .LVU8
  38               	.LVL0:
  39               	.LBB13:
  40               	.LBI13:
  41               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
  42               		.loc 2 166 1 view .LVU9
  43               	.LBB14:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
  44               		.loc 2 168 2 view .LVU10
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
  45               		.loc 2 172 2 view .LVU11
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  46               		.loc 2 173 2 view .LVU12
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
  47               		.loc 2 174 2 view .LVU13
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
  48               		.loc 2 184 3 view .LVU14
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  49               		.loc 2 187 2 view .LVU15
  50 0010 2FEF      		ldi r18,lo8(1599999)
  51 0012 89E6      		ldi r24,hi8(1599999)
  52 0014 98E1      		ldi r25,hlo8(1599999)
  53 0016 2150      	1:	subi r18,1
  54 0018 8040      		sbci r24,0
  55 001a 9040      		sbci r25,0
  56 001c 01F4      		brne 1b
  57 001e 00C0      		rjmp .
  58 0020 0000      		nop
  59               	.LVL1:
  60               		.loc 2 187 2 is_stmt 0 view .LVU16
  61               	.LBE14:
  62               	.LBE13:
  63               		.loc 1 64 5 is_stmt 1 view .LVU17
  64 0022 2798      		cbi 0x4,7
  65:../../tmk_core/protocol/xt_interrupt.c **** #endif
  66:../../tmk_core/protocol/xt_interrupt.c **** 
  67:../../tmk_core/protocol/xt_interrupt.c ****     /* soft reset: pull clock line down for 20ms */
  68:../../tmk_core/protocol/xt_interrupt.c ****     XT_DATA_LO();
  65               		.loc 1 68 5 view .LVU18
  66               		.loc 1 68 5 view .LVU19
  67 0024 5898      		cbi 0xb,0
  68               		.loc 1 68 5 view .LVU20
  69 0026 509A      		sbi 0xa,0
  69:../../tmk_core/protocol/xt_interrupt.c ****     XT_CLOCK_LO();
  70               		.loc 1 69 5 view .LVU21
  71               		.loc 1 69 5 view .LVU22
  72 0028 5998      		cbi 0xb,1
  73               		.loc 1 69 5 view .LVU23
  74 002a 519A      		sbi 0xa,1
  70:../../tmk_core/protocol/xt_interrupt.c ****     _delay_ms(20);
  75               		.loc 1 70 5 view .LVU24
  76               	.LVL2:
  77               	.LBB15:
  78               	.LBI15:
 166:/usr/avr/include/util/delay.h **** {
  79               		.loc 2 166 1 view .LVU25
  80               	.LBB16:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  81               		.loc 2 168 2 view .LVU26
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  82               		.loc 2 172 2 view .LVU27
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
  83               		.loc 2 173 2 view .LVU28
 174:/usr/avr/include/util/delay.h **** 
  84               		.loc 2 174 2 view .LVU29
 184:/usr/avr/include/util/delay.h **** 	#endif
  85               		.loc 2 184 3 view .LVU30
  86               		.loc 2 187 2 view .LVU31
  87 002c 2FEF      		ldi r18,lo8(63999)
  88 002e 89EF      		ldi r24,hi8(63999)
  89 0030 90E0      		ldi r25,hlo8(63999)
  90 0032 2150      	1:	subi r18,1
  91 0034 8040      		sbci r24,0
  92 0036 9040      		sbci r25,0
  93 0038 01F4      		brne 1b
  94 003a 00C0      		rjmp .
  95 003c 0000      		nop
  96               	.LVL3:
  97               		.loc 2 187 2 is_stmt 0 view .LVU32
  98               	.LBE16:
  99               	.LBE15:
  71:../../tmk_core/protocol/xt_interrupt.c **** 
  72:../../tmk_core/protocol/xt_interrupt.c ****     /* input mode with pullup */
  73:../../tmk_core/protocol/xt_interrupt.c ****     XT_CLOCK_IN();
 100               		.loc 1 73 5 is_stmt 1 view .LVU33
 101               		.loc 1 73 5 view .LVU34
 102 003e 5198      		cbi 0xa,1
 103               		.loc 1 73 5 view .LVU35
 104 0040 599A      		sbi 0xb,1
  74:../../tmk_core/protocol/xt_interrupt.c ****     XT_DATA_IN();
 105               		.loc 1 74 5 view .LVU36
 106               		.loc 1 74 5 view .LVU37
 107 0042 5098      		cbi 0xa,0
 108               		.loc 1 74 5 view .LVU38
 109 0044 589A      		sbi 0xb,0
  75:../../tmk_core/protocol/xt_interrupt.c **** 
  76:../../tmk_core/protocol/xt_interrupt.c ****     XT_INT_ON();
 110               		.loc 1 76 5 view .LVU39
 111               		.loc 1 76 5 view .LVU40
 112 0046 E19A      		sbi 0x1c,1
 113               		.loc 1 76 5 view .LVU41
 114 0048 E99A      		sbi 0x1d,1
 115               	/* epilogue start */
  77:../../tmk_core/protocol/xt_interrupt.c **** }
 116               		.loc 1 77 1 is_stmt 0 view .LVU42
 117 004a 0895      		ret
 118               		.cfi_endproc
 119               	.LFE14:
 121               		.section	.text.xt_host_recv,"ax",@progbits
 122               	.global	xt_host_recv
 124               	xt_host_recv:
 125               	.LFB15:
  78:../../tmk_core/protocol/xt_interrupt.c **** 
  79:../../tmk_core/protocol/xt_interrupt.c **** /* get data received by interrupt */
  80:../../tmk_core/protocol/xt_interrupt.c **** uint8_t xt_host_recv(void)
  81:../../tmk_core/protocol/xt_interrupt.c **** {
 126               		.loc 1 81 1 is_stmt 1 view -0
 127               		.cfi_startproc
 128               	/* prologue: function */
 129               	/* frame size = 0 */
 130               	/* stack size = 0 */
 131               	.L__stack_usage = 0
  82:../../tmk_core/protocol/xt_interrupt.c ****     if (ringbuf_is_empty(&rb)) {
 132               		.loc 1 82 5 view .LVU44
 133               	.LVL4:
 134               	.LBB24:
 135               	.LBI24:
 136               		.file 3 "../../tmk_core/common/ringbuf.h"
   1:../../tmk_core/common/ringbuf.h **** #ifndef RINGBUF_H
   2:../../tmk_core/common/ringbuf.h **** #define RINGBUF_H
   3:../../tmk_core/common/ringbuf.h **** 
   4:../../tmk_core/common/ringbuf.h **** #include <stdint.h>
   5:../../tmk_core/common/ringbuf.h **** #include <stdbool.h>
   6:../../tmk_core/common/ringbuf.h **** 
   7:../../tmk_core/common/ringbuf.h **** // NOTE: buffer size must be 2^n and up to 255. size_mask should be 2^n - 1 due to using &(AND) ins
   8:../../tmk_core/common/ringbuf.h **** typedef struct {
   9:../../tmk_core/common/ringbuf.h ****     uint8_t *buffer;
  10:../../tmk_core/common/ringbuf.h ****     uint8_t head;
  11:../../tmk_core/common/ringbuf.h ****     uint8_t tail;
  12:../../tmk_core/common/ringbuf.h ****     uint8_t size_mask;
  13:../../tmk_core/common/ringbuf.h **** } ringbuf_t;
  14:../../tmk_core/common/ringbuf.h **** 
  15:../../tmk_core/common/ringbuf.h **** static inline void ringbuf_init(ringbuf_t *buf, uint8_t *array, uint8_t size);
  16:../../tmk_core/common/ringbuf.h **** static inline int16_t ringbuf_get(ringbuf_t *buf);
  17:../../tmk_core/common/ringbuf.h **** static inline bool ringbuf_put(ringbuf_t *buf, uint8_t data);
  18:../../tmk_core/common/ringbuf.h **** static inline void ringbuf_write(ringbuf_t *buf, uint8_t data);
  19:../../tmk_core/common/ringbuf.h **** static inline bool ringbuf_is_empty(ringbuf_t *buf);
  20:../../tmk_core/common/ringbuf.h **** static inline bool ringbuf_is_full(ringbuf_t *buf);
  21:../../tmk_core/common/ringbuf.h **** static inline void ringbuf_reset(ringbuf_t *buf);
  22:../../tmk_core/common/ringbuf.h **** 
  23:../../tmk_core/common/ringbuf.h **** static inline void ringbuf_init(ringbuf_t *buf, uint8_t *array, uint8_t size)
  24:../../tmk_core/common/ringbuf.h **** {
  25:../../tmk_core/common/ringbuf.h ****     buf->buffer = array;
  26:../../tmk_core/common/ringbuf.h ****     buf->head = 0;
  27:../../tmk_core/common/ringbuf.h ****     buf->tail = 0;
  28:../../tmk_core/common/ringbuf.h ****     buf->size_mask = size - 1;
  29:../../tmk_core/common/ringbuf.h **** }
  30:../../tmk_core/common/ringbuf.h **** static inline int16_t ringbuf_get(ringbuf_t *buf)
  31:../../tmk_core/common/ringbuf.h **** {
  32:../../tmk_core/common/ringbuf.h ****     if (ringbuf_is_empty(buf)) return -1;
  33:../../tmk_core/common/ringbuf.h ****     uint8_t data = buf->buffer[buf->tail];
  34:../../tmk_core/common/ringbuf.h ****     buf->tail++;
  35:../../tmk_core/common/ringbuf.h ****     buf->tail &= buf->size_mask;
  36:../../tmk_core/common/ringbuf.h ****     return  data;
  37:../../tmk_core/common/ringbuf.h **** }
  38:../../tmk_core/common/ringbuf.h **** static inline bool ringbuf_put(ringbuf_t *buf, uint8_t data)
  39:../../tmk_core/common/ringbuf.h **** {
  40:../../tmk_core/common/ringbuf.h ****     if (ringbuf_is_full(buf)) {
  41:../../tmk_core/common/ringbuf.h ****         return false;
  42:../../tmk_core/common/ringbuf.h ****     }
  43:../../tmk_core/common/ringbuf.h ****     buf->buffer[buf->head] = data;
  44:../../tmk_core/common/ringbuf.h ****     buf->head++;
  45:../../tmk_core/common/ringbuf.h ****     buf->head &= buf->size_mask;
  46:../../tmk_core/common/ringbuf.h ****     return true;
  47:../../tmk_core/common/ringbuf.h **** }
  48:../../tmk_core/common/ringbuf.h **** // this overrides data in buffer when it is full
  49:../../tmk_core/common/ringbuf.h **** static inline void ringbuf_write(ringbuf_t *buf, uint8_t data)
  50:../../tmk_core/common/ringbuf.h **** {
  51:../../tmk_core/common/ringbuf.h ****     buf->buffer[buf->head] = data;
  52:../../tmk_core/common/ringbuf.h ****     buf->head++;
  53:../../tmk_core/common/ringbuf.h ****     buf->head &= buf->size_mask;
  54:../../tmk_core/common/ringbuf.h ****     // eat tail: override data yet to be consumed
  55:../../tmk_core/common/ringbuf.h ****     if (buf->head == buf->tail) {
  56:../../tmk_core/common/ringbuf.h ****         buf->tail++;
  57:../../tmk_core/common/ringbuf.h ****         buf->tail &= buf->size_mask;
  58:../../tmk_core/common/ringbuf.h ****     }
  59:../../tmk_core/common/ringbuf.h **** }
  60:../../tmk_core/common/ringbuf.h **** static inline bool ringbuf_is_empty(ringbuf_t *buf)
 137               		.loc 3 60 20 view .LVU45
 138               	.LBB25:
  61:../../tmk_core/common/ringbuf.h **** {
  62:../../tmk_core/common/ringbuf.h ****     return (buf->head == buf->tail);
 139               		.loc 3 62 5 view .LVU46
 140               		.loc 3 62 29 is_stmt 0 view .LVU47
 141 0000 9091 0000 		lds r25,rb+3
 142               	.LVL5:
 143               		.loc 3 62 29 view .LVU48
 144               	.LBE25:
 145               	.LBE24:
 146               		.loc 1 82 8 view .LVU49
 147 0004 8091 0000 		lds r24,rb+2
 148 0008 8917      		cp r24,r25
 149 000a 01F0      		breq .L4
 150               	.LBB26:
  83:../../tmk_core/protocol/xt_interrupt.c ****         return 0;
  84:../../tmk_core/protocol/xt_interrupt.c ****     } else {
  85:../../tmk_core/protocol/xt_interrupt.c ****         int16_t d = ringbuf_get(&rb);
 151               		.loc 1 85 9 is_stmt 1 view .LVU50
 152               	.LBB27:
 153               	.LBI27:
  30:../../tmk_core/common/ringbuf.h **** {
 154               		.loc 3 30 23 view .LVU51
 155               	.LVL6:
 156               	.LBB28:
  32:../../tmk_core/common/ringbuf.h ****     uint8_t data = buf->buffer[buf->tail];
 157               		.loc 3 32 5 view .LVU52
  32:../../tmk_core/common/ringbuf.h ****     uint8_t data = buf->buffer[buf->tail];
 158               		.loc 3 32 5 is_stmt 0 view .LVU53
 159               	.LBE28:
 160               	.LBE27:
 161               	.LBE26:
 162               		.loc 3 62 5 is_stmt 1 view .LVU54
 163               	.LBB31:
 164               	.LBB30:
 165               	.LBB29:
  33:../../tmk_core/common/ringbuf.h ****     buf->tail++;
 166               		.loc 3 33 5 view .LVU55
  33:../../tmk_core/common/ringbuf.h ****     buf->tail++;
 167               		.loc 3 33 13 is_stmt 0 view .LVU56
 168 000c E091 0000 		lds r30,rb
 169 0010 F091 0000 		lds r31,rb+1
 170 0014 E90F      		add r30,r25
 171 0016 F11D      		adc r31,__zero_reg__
 172 0018 8081      		ld r24,Z
 173               	.LVL7:
  34:../../tmk_core/common/ringbuf.h ****     buf->tail &= buf->size_mask;
 174               		.loc 3 34 5 is_stmt 1 view .LVU57
  35:../../tmk_core/common/ringbuf.h ****     return  data;
 175               		.loc 3 35 5 view .LVU58
  34:../../tmk_core/common/ringbuf.h ****     buf->tail &= buf->size_mask;
 176               		.loc 3 34 14 is_stmt 0 view .LVU59
 177 001a 9F5F      		subi r25,lo8(-(1))
  35:../../tmk_core/common/ringbuf.h ****     return  data;
 178               		.loc 3 35 15 view .LVU60
 179 001c 2091 0000 		lds r18,rb+4
 180 0020 9223      		and r25,r18
 181 0022 9093 0000 		sts rb+3,r25
  36:../../tmk_core/common/ringbuf.h **** }
 182               		.loc 3 36 5 is_stmt 1 view .LVU61
 183               	.LVL8:
  36:../../tmk_core/common/ringbuf.h **** }
 184               		.loc 3 36 5 is_stmt 0 view .LVU62
 185               	.LBE29:
 186               	.LBE30:
  86:../../tmk_core/protocol/xt_interrupt.c ****         XT_DATA_IN();  // ready to receive from keyboard
 187               		.loc 1 86 9 is_stmt 1 view .LVU63
 188               		.loc 1 86 9 view .LVU64
 189 0026 5098      		cbi 0xa,0
 190               		.loc 1 86 9 view .LVU65
 191 0028 589A      		sbi 0xb,0
  87:../../tmk_core/protocol/xt_interrupt.c ****         return d;
 192               		.loc 1 87 9 view .LVU66
 193               		.loc 1 87 16 is_stmt 0 view .LVU67
 194 002a 0895      		ret
 195               	.LVL9:
 196               	.L4:
 197               		.loc 1 87 16 view .LVU68
 198               	.LBE31:
  83:../../tmk_core/protocol/xt_interrupt.c ****     } else {
 199               		.loc 1 83 16 view .LVU69
 200 002c 80E0      		ldi r24,0
 201               	/* epilogue start */
  88:../../tmk_core/protocol/xt_interrupt.c ****     }
  89:../../tmk_core/protocol/xt_interrupt.c **** }
 202               		.loc 1 89 1 view .LVU70
 203 002e 0895      		ret
 204               		.cfi_endproc
 205               	.LFE15:
 207               		.section	.text.__vector_2,"ax",@progbits
 208               	.global	__vector_2
 210               	__vector_2:
 211               	.LFB16:
  90:../../tmk_core/protocol/xt_interrupt.c **** 
  91:../../tmk_core/protocol/xt_interrupt.c **** ISR(XT_INT_VECT)
  92:../../tmk_core/protocol/xt_interrupt.c **** {
 212               		.loc 1 92 1 is_stmt 1 view -0
 213               		.cfi_startproc
 214 0000 1F92      		push r1
 215               	.LCFI0:
 216               		.cfi_def_cfa_offset 3
 217               		.cfi_offset 1, -2
 218 0002 0F92      		push r0
 219               	.LCFI1:
 220               		.cfi_def_cfa_offset 4
 221               		.cfi_offset 0, -3
 222 0004 0FB6      		in r0,__SREG__
 223 0006 0F92      		push r0
 224 0008 1124      		clr __zero_reg__
 225 000a 2F93      		push r18
 226               	.LCFI2:
 227               		.cfi_def_cfa_offset 5
 228               		.cfi_offset 18, -4
 229 000c 3F93      		push r19
 230               	.LCFI3:
 231               		.cfi_def_cfa_offset 6
 232               		.cfi_offset 19, -5
 233 000e 4F93      		push r20
 234               	.LCFI4:
 235               		.cfi_def_cfa_offset 7
 236               		.cfi_offset 20, -6
 237 0010 5F93      		push r21
 238               	.LCFI5:
 239               		.cfi_def_cfa_offset 8
 240               		.cfi_offset 21, -7
 241 0012 6F93      		push r22
 242               	.LCFI6:
 243               		.cfi_def_cfa_offset 9
 244               		.cfi_offset 22, -8
 245 0014 7F93      		push r23
 246               	.LCFI7:
 247               		.cfi_def_cfa_offset 10
 248               		.cfi_offset 23, -9
 249 0016 8F93      		push r24
 250               	.LCFI8:
 251               		.cfi_def_cfa_offset 11
 252               		.cfi_offset 24, -10
 253 0018 9F93      		push r25
 254               	.LCFI9:
 255               		.cfi_def_cfa_offset 12
 256               		.cfi_offset 25, -11
 257 001a AF93      		push r26
 258               	.LCFI10:
 259               		.cfi_def_cfa_offset 13
 260               		.cfi_offset 26, -12
 261 001c BF93      		push r27
 262               	.LCFI11:
 263               		.cfi_def_cfa_offset 14
 264               		.cfi_offset 27, -13
 265 001e EF93      		push r30
 266               	.LCFI12:
 267               		.cfi_def_cfa_offset 15
 268               		.cfi_offset 30, -14
 269 0020 FF93      		push r31
 270               	.LCFI13:
 271               		.cfi_def_cfa_offset 16
 272               		.cfi_offset 31, -15
 273               	/* prologue: Signal */
 274               	/* frame size = 0 */
 275               	/* stack size = 15 */
 276               	.L__stack_usage = 15
  93:../../tmk_core/protocol/xt_interrupt.c ****     /*
  94:../../tmk_core/protocol/xt_interrupt.c ****      * XT signal format consits of 10 or 9 clocks and sends start bits and 8-bit data,
  95:../../tmk_core/protocol/xt_interrupt.c ****      * which should be read on falling edge of clock.
  96:../../tmk_core/protocol/xt_interrupt.c ****      *
  97:../../tmk_core/protocol/xt_interrupt.c ****      *  start(0), start(1), bit0, bit1, bit2, bit3, bit4, bit5, bit6, bit7
  98:../../tmk_core/protocol/xt_interrupt.c ****      *
  99:../../tmk_core/protocol/xt_interrupt.c ****      * Original IBM XT keyboard sends start(0) bit while some of clones don't.
 100:../../tmk_core/protocol/xt_interrupt.c ****      * Start(0) bit is read as low on data line while start(1) as high.
 101:../../tmk_core/protocol/xt_interrupt.c ****      *
 102:../../tmk_core/protocol/xt_interrupt.c ****      * https://github.com/tmk/tmk_keyboard/wiki/IBM-PC-XT-Keyboard-Protocol
 103:../../tmk_core/protocol/xt_interrupt.c ****      */
 104:../../tmk_core/protocol/xt_interrupt.c ****     static enum {
 277               		.loc 1 104 5 view .LVU72
 105:../../tmk_core/protocol/xt_interrupt.c ****         START, BIT0, BIT1, BIT2, BIT3, BIT4, BIT5, BIT6, BIT7
 106:../../tmk_core/protocol/xt_interrupt.c ****     } state = START;
 107:../../tmk_core/protocol/xt_interrupt.c ****     static uint8_t data = 0;
 278               		.loc 1 107 5 view .LVU73
 108:../../tmk_core/protocol/xt_interrupt.c **** 
 109:../../tmk_core/protocol/xt_interrupt.c ****     uint8_t dbit = XT_DATA_READ();
 279               		.loc 1 109 5 view .LVU74
 280               		.loc 1 109 20 is_stmt 0 view .LVU75
 281 0022 29B1      		in r18,0x9
 282               		.loc 1 109 13 view .LVU76
 283 0024 2170      		andi r18,lo8(1)
 284               	.LVL10:
 110:../../tmk_core/protocol/xt_interrupt.c **** 
 111:../../tmk_core/protocol/xt_interrupt.c ****     // This is needed if using PCINT which can be called on both falling and rising edge
 112:../../tmk_core/protocol/xt_interrupt.c ****     //if (XT_CLOCK_READ()) return;
 113:../../tmk_core/protocol/xt_interrupt.c **** 
 114:../../tmk_core/protocol/xt_interrupt.c ****     switch (state) {
 285               		.loc 1 114 5 is_stmt 1 view .LVU77
 286 0026 9091 0000 		lds r25,state.1951
 287 002a 9923      		tst r25
 288 002c 01F0      		breq .L6
 289 002e 9930      		cpi r25,lo8(9)
 290 0030 00F4      		brsh .L7
 115:../../tmk_core/protocol/xt_interrupt.c ****         case START:
 116:../../tmk_core/protocol/xt_interrupt.c ****             // ignore start(0) bit
 117:../../tmk_core/protocol/xt_interrupt.c ****             if (!dbit) return;
 118:../../tmk_core/protocol/xt_interrupt.c ****             break;
 119:../../tmk_core/protocol/xt_interrupt.c ****         case BIT0 ... BIT7:
 120:../../tmk_core/protocol/xt_interrupt.c ****             data >>= 1;
 291               		.loc 1 120 13 view .LVU78
 292               		.loc 1 120 18 is_stmt 0 view .LVU79
 293 0032 8091 0000 		lds r24,data.1952
 294 0036 8695      		lsr r24
 121:../../tmk_core/protocol/xt_interrupt.c ****             if (dbit)
 295               		.loc 1 121 13 is_stmt 1 view .LVU80
 296               		.loc 1 121 16 is_stmt 0 view .LVU81
 297 0038 2111      		cpse r18,__zero_reg__
 298 003a 00C0      		rjmp .L11
 299               	.L20:
 122:../../tmk_core/protocol/xt_interrupt.c ****                 data |= 0x80;
 300               		.loc 1 122 22 view .LVU82
 301 003c 8093 0000 		sts data.1952,r24
 302               	.L7:
 123:../../tmk_core/protocol/xt_interrupt.c ****             break;
 124:../../tmk_core/protocol/xt_interrupt.c ****     }
 125:../../tmk_core/protocol/xt_interrupt.c ****     if (state++ == BIT7) {
 303               		.loc 1 125 5 is_stmt 1 view .LVU83
 304               		.loc 1 125 14 is_stmt 0 view .LVU84
 305 0040 81E0      		ldi r24,lo8(1)
 306 0042 890F      		add r24,r25
 307 0044 8093 0000 		sts state.1951,r24
 308               		.loc 1 125 8 view .LVU85
 309 0048 9830      		cpi r25,lo8(8)
 310 004a 01F4      		brne .L5
 126:../../tmk_core/protocol/xt_interrupt.c ****         ringbuf_put(&rb, data);
 311               		.loc 1 126 9 is_stmt 1 view .LVU86
 312               	.LVL11:
 313               	.LBB39:
 314               	.LBI39:
  38:../../tmk_core/common/ringbuf.h **** {
 315               		.loc 3 38 20 view .LVU87
 316               	.LBB40:
  40:../../tmk_core/common/ringbuf.h ****         return false;
 317               		.loc 3 40 5 view .LVU88
 318               	.LBB41:
 319               	.LBI41:
  63:../../tmk_core/common/ringbuf.h **** }
  64:../../tmk_core/common/ringbuf.h **** static inline bool ringbuf_is_full(ringbuf_t *buf)
 320               		.loc 3 64 20 view .LVU89
 321               	.LBB42:
  65:../../tmk_core/common/ringbuf.h **** {
  66:../../tmk_core/common/ringbuf.h ****     return (((buf->head + 1) & buf->size_mask) == buf->tail);
 322               		.loc 3 66 5 view .LVU90
 323               		.loc 3 66 18 is_stmt 0 view .LVU91
 324 004c 8091 0000 		lds r24,rb+2
 325               	.LVL12:
 326               		.loc 3 66 18 view .LVU92
 327 0050 90E0      		ldi r25,0
 328               		.loc 3 66 25 view .LVU93
 329 0052 9C01      		movw r18,r24
 330               	.LVL13:
 331               		.loc 3 66 25 view .LVU94
 332 0054 2F5F      		subi r18,-1
 333 0056 3F4F      		sbci r19,-1
 334               		.loc 3 66 35 view .LVU95
 335 0058 4091 0000 		lds r20,rb+4
 336 005c 50E0      		ldi r21,0
 337               		.loc 3 66 30 view .LVU96
 338 005e 2423      		and r18,r20
 339 0060 3523      		and r19,r21
 340               		.loc 3 66 54 view .LVU97
 341 0062 4091 0000 		lds r20,rb+3
 342               	.LBE42:
 343               	.LBE41:
  40:../../tmk_core/common/ringbuf.h ****         return false;
 344               		.loc 3 40 8 view .LVU98
 345 0066 4217      		cp r20,r18
 346 0068 1306      		cpc __zero_reg__,r19
 347 006a 01F4      		brne .L13
 348               	.LVL14:
 349               	.L15:
  40:../../tmk_core/common/ringbuf.h ****         return false;
 350               		.loc 3 40 8 view .LVU99
 351               	.LBE40:
 352               	.LBE39:
 127:../../tmk_core/protocol/xt_interrupt.c ****         if (ringbuf_is_full(&rb)) {
 128:../../tmk_core/protocol/xt_interrupt.c ****             XT_DATA_LO();  // inhibit keyboard sending
 353               		.loc 1 128 13 is_stmt 1 view .LVU100
 354               		.loc 1 128 13 view .LVU101
 355 006c 5898      		cbi 0xb,0
 356               		.loc 1 128 13 view .LVU102
 357 006e 509A      		sbi 0xa,0
 129:../../tmk_core/protocol/xt_interrupt.c ****             print("Full");
 358               		.loc 1 129 13 view .LVU103
 359               	.LBB44:
 360               		.loc 1 129 13 view .LVU104
 361               		.loc 1 129 13 view .LVU105
 362               	.LBE44:
 363 0070 80E0      		ldi r24,lo8(__c.1957)
 364 0072 90E0      		ldi r25,hi8(__c.1957)
 365 0074 0E94 0000 		call xputs
 366               	.LVL15:
 367               	.L14:
 130:../../tmk_core/protocol/xt_interrupt.c ****         }
 131:../../tmk_core/protocol/xt_interrupt.c ****         state = START;
 368               		.loc 1 131 9 view .LVU106
 369               		.loc 1 131 15 is_stmt 0 view .LVU107
 370 0078 1092 0000 		sts state.1951,__zero_reg__
 132:../../tmk_core/protocol/xt_interrupt.c ****         data = 0;
 371               		.loc 1 132 9 is_stmt 1 view .LVU108
 372               		.loc 1 132 14 is_stmt 0 view .LVU109
 373 007c 1092 0000 		sts data.1952,__zero_reg__
 374 0080 00C0      		rjmp .L5
 375               	.LVL16:
 376               	.L6:
 117:../../tmk_core/protocol/xt_interrupt.c ****             break;
 377               		.loc 1 117 13 is_stmt 1 view .LVU110
 117:../../tmk_core/protocol/xt_interrupt.c ****             break;
 378               		.loc 1 117 16 is_stmt 0 view .LVU111
 379 0082 2111      		cpse r18,__zero_reg__
 380 0084 00C0      		rjmp .L7
 381               	.LVL17:
 382               	.L5:
 383               	/* epilogue start */
 133:../../tmk_core/protocol/xt_interrupt.c ****     }
 134:../../tmk_core/protocol/xt_interrupt.c ****     return;
 135:../../tmk_core/protocol/xt_interrupt.c **** }
 384               		.loc 1 135 1 view .LVU112
 385 0086 FF91      		pop r31
 386 0088 EF91      		pop r30
 387 008a BF91      		pop r27
 388 008c AF91      		pop r26
 389 008e 9F91      		pop r25
 390 0090 8F91      		pop r24
 391 0092 7F91      		pop r23
 392 0094 6F91      		pop r22
 393 0096 5F91      		pop r21
 394 0098 4F91      		pop r20
 395 009a 3F91      		pop r19
 396 009c 2F91      		pop r18
 397 009e 0F90      		pop r0
 398 00a0 0FBE      		out __SREG__,r0
 399 00a2 0F90      		pop r0
 400 00a4 1F90      		pop r1
 401 00a6 1895      		reti
 402               	.LVL18:
 403               	.L11:
 122:../../tmk_core/protocol/xt_interrupt.c ****             break;
 404               		.loc 1 122 17 is_stmt 1 view .LVU113
 122:../../tmk_core/protocol/xt_interrupt.c ****             break;
 405               		.loc 1 122 22 is_stmt 0 view .LVU114
 406 00a8 8068      		ori r24,lo8(-128)
 407 00aa 00C0      		rjmp .L20
 408               	.LVL19:
 409               	.L13:
 410               	.LBB45:
 411               	.LBB43:
  43:../../tmk_core/common/ringbuf.h ****     buf->head++;
 412               		.loc 3 43 5 is_stmt 1 view .LVU115
  43:../../tmk_core/common/ringbuf.h ****     buf->head++;
 413               		.loc 3 43 28 is_stmt 0 view .LVU116
 414 00ac 2091 0000 		lds r18,rb
 415 00b0 3091 0000 		lds r19,rb+1
 416 00b4 820F      		add r24,r18
 417 00b6 931F      		adc r25,r19
 418 00b8 2091 0000 		lds r18,data.1952
 419 00bc FC01      		movw r30,r24
 420 00be 2083      		st Z,r18
  44:../../tmk_core/common/ringbuf.h ****     buf->head &= buf->size_mask;
 421               		.loc 3 44 5 is_stmt 1 view .LVU117
  45:../../tmk_core/common/ringbuf.h ****     return true;
 422               		.loc 3 45 5 view .LVU118
  45:../../tmk_core/common/ringbuf.h ****     return true;
 423               		.loc 3 45 21 is_stmt 0 view .LVU119
 424 00c0 2091 0000 		lds r18,rb+4
  44:../../tmk_core/common/ringbuf.h ****     buf->head &= buf->size_mask;
 425               		.loc 3 44 14 view .LVU120
 426 00c4 8091 0000 		lds r24,rb+2
 427 00c8 8F5F      		subi r24,lo8(-(1))
  45:../../tmk_core/common/ringbuf.h ****     return true;
 428               		.loc 3 45 15 view .LVU121
 429 00ca 8223      		and r24,r18
 430 00cc 8093 0000 		sts rb+2,r24
  46:../../tmk_core/common/ringbuf.h **** }
 431               		.loc 3 46 5 is_stmt 1 view .LVU122
 432               	.LVL20:
  46:../../tmk_core/common/ringbuf.h **** }
 433               		.loc 3 46 5 is_stmt 0 view .LVU123
 434               	.LBE43:
 435               	.LBE45:
 127:../../tmk_core/protocol/xt_interrupt.c ****             XT_DATA_LO();  // inhibit keyboard sending
 436               		.loc 1 127 9 is_stmt 1 view .LVU124
 437               	.LBB46:
 438               	.LBI46:
  64:../../tmk_core/common/ringbuf.h **** {
 439               		.loc 3 64 20 view .LVU125
 440               	.LBB47:
 441               		.loc 3 66 5 view .LVU126
 442               		.loc 3 66 18 is_stmt 0 view .LVU127
 443 00d0 90E0      		ldi r25,0
 444               		.loc 3 66 25 view .LVU128
 445 00d2 0196      		adiw r24,1
 446               		.loc 3 66 35 view .LVU129
 447 00d4 30E0      		ldi r19,0
 448               		.loc 3 66 30 view .LVU130
 449 00d6 8223      		and r24,r18
 450 00d8 9323      		and r25,r19
 451               		.loc 3 66 54 view .LVU131
 452 00da 2091 0000 		lds r18,rb+3
 453               	.LBE47:
 454               	.LBE46:
 127:../../tmk_core/protocol/xt_interrupt.c ****             XT_DATA_LO();  // inhibit keyboard sending
 455               		.loc 1 127 12 view .LVU132
 456 00de 2817      		cp r18,r24
 457 00e0 1906      		cpc __zero_reg__,r25
 458 00e2 01F4      		brne .L14
 459 00e4 00C0      		rjmp .L15
 460               		.cfi_endproc
 461               	.LFE16:
 463               		.section	.progmem.data.__c.1957,"a"
 466               	__c.1957:
 467 0000 4675 6C6C 		.string	"Full"
 467      00
 468               		.section	.bss.data.1952,"aw",@nobits
 471               	data.1952:
 472 0000 00        		.zero	1
 473               		.section	.bss.state.1951,"aw",@nobits
 476               	state.1951:
 477 0000 00        		.zero	1
 478               		.section	.data.rb,"aw"
 481               	rb:
 482 0000 0000      		.word	buf
 483 0002 00        		.byte	0
 484 0003 00        		.byte	0
 485 0004 0F        		.byte	15
 486               		.section	.bss.buf,"aw",@nobits
 489               	buf:
 490 0000 0000 0000 		.zero	16
 490      0000 0000 
 490      0000 0000 
 490      0000 0000 
 491               		.text
 492               	.Letext0:
 493               		.file 4 "/usr/avr/include/stdint.h"
 494               		.file 5 "../../tmk_core/common/avr/xprintf.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 xt_interrupt.c
     /tmp/cc7hp6Wr.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc7hp6Wr.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc7hp6Wr.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc7hp6Wr.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc7hp6Wr.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc7hp6Wr.s:13     .text.xt_host_init:0000000000000000 xt_host_init
     /tmp/cc7hp6Wr.s:124    .text.xt_host_recv:0000000000000000 xt_host_recv
     /tmp/cc7hp6Wr.s:481    .data.rb:0000000000000000 rb
     /tmp/cc7hp6Wr.s:210    .text.__vector_2:0000000000000000 __vector_2
     /tmp/cc7hp6Wr.s:476    .bss.state.1951:0000000000000000 state.1951
     /tmp/cc7hp6Wr.s:471    .bss.data.1952:0000000000000000 data.1952
     /tmp/cc7hp6Wr.s:466    .progmem.data.__c.1957:0000000000000000 __c.1957
     /tmp/cc7hp6Wr.s:489    .bss.buf:0000000000000000 buf

UNDEFINED SYMBOLS
xputs
__do_copy_data
__do_clear_bss
