   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.file 1 "quantum/matrix.c"
  11               		.section	.text.matrix_init_user,"ax",@progbits
  12               		.weak	matrix_init_user
  14               	matrix_init_user:
  15               	.LFB14:
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012 Jun Wako
   3:quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:quantum/matrix.c **** 
   5:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:quantum/matrix.c **** (at your option) any later version.
   9:quantum/matrix.c **** 
  10:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:quantum/matrix.c **** GNU General Public License for more details.
  14:quantum/matrix.c **** 
  15:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:quantum/matrix.c **** */
  18:quantum/matrix.c **** #include <stdint.h>
  19:quantum/matrix.c **** #include <stdbool.h>
  20:quantum/matrix.c **** #if defined(__AVR__)
  21:quantum/matrix.c **** #include <avr/io.h>
  22:quantum/matrix.c **** #endif
  23:quantum/matrix.c **** #include "wait.h"
  24:quantum/matrix.c **** #include "print.h"
  25:quantum/matrix.c **** #include "debug.h"
  26:quantum/matrix.c **** #include "util.h"
  27:quantum/matrix.c **** #include "matrix.h"
  28:quantum/matrix.c **** #include "timer.h"
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  34:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  35:quantum/matrix.c **** #endif
  36:quantum/matrix.c **** 
  37:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  38:quantum/matrix.c ****     static uint16_t debouncing_time;
  39:quantum/matrix.c ****     static bool debouncing = false;
  40:quantum/matrix.c **** #endif
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  43:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  44:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  45:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  46:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  47:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  48:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  49:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  50:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  51:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  52:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  53:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  54:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  55:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  56:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  57:quantum/matrix.c **** #endif
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** #ifdef MATRIX_MASKED
  60:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  61:quantum/matrix.c **** #endif
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** 
  66:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  67:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** static matrix_row_t matrix_raw[MATRIX_ROWS];
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #else // ROW2COL
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  16               		.loc 1 108 29 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 109:quantum/matrix.c **** }
  22               		.loc 1 109 1 view .LVU1
  23               	/* epilogue start */
  24 0000 0895      		ret
  25               		.cfi_endproc
  26               	.LFE14:
  28               		.set	matrix_init_user.localalias,matrix_init_user
  29               		.section	.text.matrix_init_kb,"ax",@progbits
  30               		.weak	matrix_init_kb
  32               	matrix_init_kb:
  33               	.LFB12:
  98:quantum/matrix.c ****     matrix_init_user();
  34               		.loc 1 98 27 view -0
  35               		.cfi_startproc
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  40               		.loc 1 99 5 view .LVU3
  41 0000 0C94 0000 		jmp matrix_init_user
  42               	.LVL0:
  43               		.cfi_endproc
  44               	.LFE12:
  46               		.section	.text.matrix_init_quantum,"ax",@progbits
  47               		.weak	matrix_init_quantum
  49               	matrix_init_quantum:
  50               	.LFB10:
  88:quantum/matrix.c ****     matrix_init_kb();
  51               		.loc 1 88 32 view -0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  57               		.loc 1 89 5 view .LVU5
  58 0000 0C94 0000 		jmp matrix_init_kb
  59               	.LVL1:
  60               		.cfi_endproc
  61               	.LFE10:
  63               		.section	.text.matrix_scan_user,"ax",@progbits
  64               		.weak	matrix_scan_user
  66               	matrix_scan_user:
  67               	.LFB31:
  68               		.cfi_startproc
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
  69               		.loc 1 112 6 view -0
  70               	/* prologue: function */
  71               	/* frame size = 0 */
  72               	/* stack size = 0 */
  73               	.L__stack_usage = 0
  74               	/* epilogue start */
  75 0000 0895      		ret
  76               		.cfi_endproc
  77               	.LFE31:
  79               		.section	.text.matrix_scan_kb,"ax",@progbits
  80               		.weak	matrix_scan_kb
  82               	matrix_scan_kb:
  83               	.LFB13:
 103:quantum/matrix.c ****     matrix_scan_user();
  84               		.loc 1 103 27 view -0
  85               		.cfi_startproc
  86               	/* prologue: function */
  87               	/* frame size = 0 */
  88               	/* stack size = 0 */
  89               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  90               		.loc 1 104 5 view .LVU8
  91 0000 0C94 0000 		jmp matrix_scan_user
  92               	.LVL2:
  93               		.cfi_endproc
  94               	.LFE13:
  96               		.section	.text.matrix_scan_quantum,"ax",@progbits
  97               		.weak	matrix_scan_quantum
  99               	matrix_scan_quantum:
 100               	.LFB11:
  93:quantum/matrix.c ****     matrix_scan_kb();
 101               		.loc 1 93 32 view -0
 102               		.cfi_startproc
 103               	/* prologue: function */
 104               	/* frame size = 0 */
 105               	/* stack size = 0 */
 106               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 107               		.loc 1 94 5 view .LVU10
 108 0000 0C94 0000 		jmp matrix_scan_kb
 109               	.LVL3:
 110               		.cfi_endproc
 111               	.LFE11:
 113               		.section	.text.matrix_rows,"ax",@progbits
 114               	.global	matrix_rows
 116               	matrix_rows:
 117               	.LFB16:
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 118               		.loc 1 116 27 view -0
 119               		.cfi_startproc
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 124               		.loc 1 117 5 view .LVU12
 118:quantum/matrix.c **** }
 125               		.loc 1 118 1 is_stmt 0 view .LVU13
 126 0000 8DE0      		ldi r24,lo8(13)
 127               	/* epilogue start */
 128 0002 0895      		ret
 129               		.cfi_endproc
 130               	.LFE16:
 132               		.section	.text.matrix_cols,"ax",@progbits
 133               	.global	matrix_cols
 135               	matrix_cols:
 136               	.LFB17:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 137               		.loc 1 121 27 is_stmt 1 view -0
 138               		.cfi_startproc
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 0 */
 142               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 143               		.loc 1 122 5 view .LVU15
 123:quantum/matrix.c **** }
 144               		.loc 1 123 1 is_stmt 0 view .LVU16
 145 0000 88E0      		ldi r24,lo8(8)
 146               	/* epilogue start */
 147 0002 0895      		ret
 148               		.cfi_endproc
 149               	.LFE17:
 151               		.section	.text.matrix_init,"ax",@progbits
 152               	.global	matrix_init
 154               	matrix_init:
 155               	.LFB18:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #else
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 156               		.loc 1 149 24 is_stmt 1 view -0
 157               		.cfi_startproc
 158 0000 CF93      		push r28
 159               	.LCFI0:
 160               		.cfi_def_cfa_offset 3
 161               		.cfi_offset 28, -2
 162 0002 DF93      		push r29
 163               	.LCFI1:
 164               		.cfi_def_cfa_offset 4
 165               		.cfi_offset 29, -3
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 2 */
 169               	.L__stack_usage = 2
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 170               		.loc 1 153 9 view .LVU18
 171 0004 85B7      		in r24,0x35
 172               		.loc 1 153 15 is_stmt 0 view .LVU19
 173 0006 8068      		ori r24,lo8(-128)
 174 0008 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 175               		.loc 1 154 9 is_stmt 1 view .LVU20
 176 000a 85B7      		in r24,0x35
 177               		.loc 1 154 15 is_stmt 0 view .LVU21
 178 000c 8068      		ori r24,lo8(-128)
 179 000e 85BF      		out 0x35,r24
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #else // ROW2COL
 162:quantum/matrix.c ****     unselect_cols();
 180               		.loc 1 162 5 is_stmt 1 view .LVU22
 181               	.LBB21:
 182               	.LBI21:
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_raw[i] = 0;
 170:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 171:quantum/matrix.c ****     }
 172:quantum/matrix.c **** 
 173:quantum/matrix.c ****     matrix_init_quantum();
 174:quantum/matrix.c **** }
 175:quantum/matrix.c **** 
 176:quantum/matrix.c **** uint8_t matrix_scan(void)
 177:quantum/matrix.c **** {
 178:quantum/matrix.c **** 
 179:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Set row, read cols
 182:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 183:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 184:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 185:quantum/matrix.c **** 
 186:quantum/matrix.c ****             if (matrix_changed) {
 187:quantum/matrix.c ****                 debouncing = true;
 188:quantum/matrix.c ****                 debouncing_time = timer_read();
 189:quantum/matrix.c ****             }
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** #       else
 192:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 193:quantum/matrix.c **** #       endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     }
 196:quantum/matrix.c **** 
 197:quantum/matrix.c **** #else // ROW2COL
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // Set col, read rows
 200:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 201:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 202:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 203:quantum/matrix.c ****             if (matrix_changed) {
 204:quantum/matrix.c ****                 debouncing = true;
 205:quantum/matrix.c ****                 debouncing_time = timer_read();
 206:quantum/matrix.c ****             }
 207:quantum/matrix.c **** #       else
 208:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 209:quantum/matrix.c **** #       endif
 210:quantum/matrix.c **** 
 211:quantum/matrix.c ****     }
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #endif
 214:quantum/matrix.c **** 
 215:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 216:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 217:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 218:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 219:quantum/matrix.c ****             }
 220:quantum/matrix.c ****             debouncing = false;
 221:quantum/matrix.c ****         }
 222:quantum/matrix.c **** #   endif
 223:quantum/matrix.c **** 
 224:quantum/matrix.c ****     matrix_scan_quantum();
 225:quantum/matrix.c ****     return 1;
 226:quantum/matrix.c **** }
 227:quantum/matrix.c **** 
 228:quantum/matrix.c **** bool matrix_is_modified(void)
 229:quantum/matrix.c **** {
 230:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 231:quantum/matrix.c ****     if (debouncing) return false;
 232:quantum/matrix.c **** #endif
 233:quantum/matrix.c ****     return true;
 234:quantum/matrix.c **** }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c **** inline
 237:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 238:quantum/matrix.c **** {
 239:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** inline
 243:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 244:quantum/matrix.c **** {
 245:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 246:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 247:quantum/matrix.c **** #ifdef MATRIX_MASKED
 248:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 249:quantum/matrix.c **** #else
 250:quantum/matrix.c ****     return matrix[row];
 251:quantum/matrix.c **** #endif
 252:quantum/matrix.c **** }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c **** void matrix_print(void)
 255:quantum/matrix.c **** {
 256:quantum/matrix.c ****     print_matrix_header();
 257:quantum/matrix.c **** 
 258:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 259:quantum/matrix.c ****         phex(row); print(": ");
 260:quantum/matrix.c ****         print_matrix_row(row);
 261:quantum/matrix.c ****         print("\n");
 262:quantum/matrix.c ****     }
 263:quantum/matrix.c **** }
 264:quantum/matrix.c **** 
 265:quantum/matrix.c **** uint8_t matrix_key_count(void)
 266:quantum/matrix.c **** {
 267:quantum/matrix.c ****     uint8_t count = 0;
 268:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 269:quantum/matrix.c ****         count += matrix_bitpop(i);
 270:quantum/matrix.c ****     }
 271:quantum/matrix.c ****     return count;
 272:quantum/matrix.c **** }
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** 
 276:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 277:quantum/matrix.c **** 
 278:quantum/matrix.c **** static void init_cols(void)
 279:quantum/matrix.c **** {
 280:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 281:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 283:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 284:quantum/matrix.c ****     }
 285:quantum/matrix.c **** }
 286:quantum/matrix.c **** 
 287:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 288:quantum/matrix.c **** {
 289:quantum/matrix.c ****     // Store last value of row prior to reading
 290:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 291:quantum/matrix.c **** 
 292:quantum/matrix.c ****     // Clear data in matrix row
 293:quantum/matrix.c ****     current_matrix[current_row] = 0;
 294:quantum/matrix.c **** 
 295:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 296:quantum/matrix.c ****     select_row(current_row);
 297:quantum/matrix.c ****     wait_us(30);
 298:quantum/matrix.c **** 
 299:quantum/matrix.c ****     // For each col...
 300:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 301:quantum/matrix.c **** 
 302:quantum/matrix.c ****         // Select the col pin to read (active low)
 303:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 304:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 305:quantum/matrix.c **** 
 306:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 307:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 308:quantum/matrix.c ****     }
 309:quantum/matrix.c **** 
 310:quantum/matrix.c ****     // Unselect row
 311:quantum/matrix.c ****     unselect_row(current_row);
 312:quantum/matrix.c **** 
 313:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 314:quantum/matrix.c **** }
 315:quantum/matrix.c **** 
 316:quantum/matrix.c **** static void select_row(uint8_t row)
 317:quantum/matrix.c **** {
 318:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 320:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 321:quantum/matrix.c **** }
 322:quantum/matrix.c **** 
 323:quantum/matrix.c **** static void unselect_row(uint8_t row)
 324:quantum/matrix.c **** {
 325:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 327:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 328:quantum/matrix.c **** }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c **** static void unselect_rows(void)
 331:quantum/matrix.c **** {
 332:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 335:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 336:quantum/matrix.c ****     }
 337:quantum/matrix.c **** }
 338:quantum/matrix.c **** 
 339:quantum/matrix.c **** #else // ROW2COL
 340:quantum/matrix.c **** 
 341:quantum/matrix.c **** static void init_rows(void)
 342:quantum/matrix.c **** {
 343:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 344:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 346:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 347:quantum/matrix.c ****     }
 348:quantum/matrix.c **** }
 349:quantum/matrix.c **** 
 350:quantum/matrix.c **** static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col)
 351:quantum/matrix.c **** {
 352:quantum/matrix.c ****     bool matrix_changed = false;
 353:quantum/matrix.c **** 
 354:quantum/matrix.c ****     // Select col and wait for col selecton to stabilize
 355:quantum/matrix.c ****     select_col(current_col);
 356:quantum/matrix.c ****     wait_us(30);
 357:quantum/matrix.c **** 
 358:quantum/matrix.c ****     // For each row...
 359:quantum/matrix.c ****     for(uint8_t row_index = 0; row_index < MATRIX_ROWS; row_index++)
 360:quantum/matrix.c ****     {
 361:quantum/matrix.c **** 
 362:quantum/matrix.c ****         // Store last value of row prior to reading
 363:quantum/matrix.c ****         matrix_row_t last_row_value = current_matrix[row_index];
 364:quantum/matrix.c **** 
 365:quantum/matrix.c ****         // Check row pin state
 366:quantum/matrix.c ****         if ((_SFR_IO8(row_pins[row_index] >> 4) & _BV(row_pins[row_index] & 0xF)) == 0)
 367:quantum/matrix.c ****         {
 368:quantum/matrix.c ****             // Pin LO, set col bit
 369:quantum/matrix.c ****             current_matrix[row_index] |= (ROW_SHIFTER << current_col);
 370:quantum/matrix.c ****         }
 371:quantum/matrix.c ****         else
 372:quantum/matrix.c ****         {
 373:quantum/matrix.c ****             // Pin HI, clear col bit
 374:quantum/matrix.c ****             current_matrix[row_index] &= ~(ROW_SHIFTER << current_col);
 375:quantum/matrix.c ****         }
 376:quantum/matrix.c **** 
 377:quantum/matrix.c ****         // Determine if the matrix changed state
 378:quantum/matrix.c ****         if ((last_row_value != current_matrix[row_index]) && !(matrix_changed))
 379:quantum/matrix.c ****         {
 380:quantum/matrix.c ****             matrix_changed = true;
 381:quantum/matrix.c ****         }
 382:quantum/matrix.c ****     }
 383:quantum/matrix.c **** 
 384:quantum/matrix.c ****     // Unselect col
 385:quantum/matrix.c ****     unselect_col(current_col);
 386:quantum/matrix.c **** 
 387:quantum/matrix.c ****     return matrix_changed;
 388:quantum/matrix.c **** }
 389:quantum/matrix.c **** 
 390:quantum/matrix.c **** static void select_col(uint8_t col)
 391:quantum/matrix.c **** {
 392:quantum/matrix.c ****     uint8_t pin = col_pins[col];
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 394:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 395:quantum/matrix.c **** }
 396:quantum/matrix.c **** 
 397:quantum/matrix.c **** static void unselect_col(uint8_t col)
 398:quantum/matrix.c **** {
 399:quantum/matrix.c ****     uint8_t pin = col_pins[col];
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 401:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 402:quantum/matrix.c **** }
 403:quantum/matrix.c **** 
 404:quantum/matrix.c **** static void unselect_cols(void)
 183               		.loc 1 404 13 view .LVU23
 405:quantum/matrix.c **** {
 406:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 184               		.loc 1 406 5 view .LVU24
 185               	.LBB22:
 186               		.loc 1 406 9 view .LVU25
 187               	.LVL4:
 188               		.loc 1 406 26 view .LVU26
 189 0010 A0E0      		ldi r26,lo8(col_pins)
 190 0012 B0E0      		ldi r27,hi8(col_pins)
 191 0014 20E0      		ldi r18,lo8(col_pins+8)
 192 0016 30E0      		ldi r19,hi8(col_pins+8)
 193               	.LBB23:
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 408:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 194               		.loc 1 408 38 is_stmt 0 view .LVU27
 195 0018 61E0      		ldi r22,lo8(1)
 196 001a 70E0      		ldi r23,0
 197               	.LVL5:
 198               	.L10:
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 199               		.loc 1 407 9 is_stmt 1 view .LVU28
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 200               		.loc 1 407 17 is_stmt 0 view .LVU29
 201 001c 8D91      		ld r24,X+
 202               	.LVL6:
 203               		.loc 1 408 9 is_stmt 1 view .LVU30
 204 001e E82F      		mov r30,r24
 205 0020 E295      		swap r30
 206 0022 EF70      		andi r30,lo8(15)
 207 0024 F0E0      		ldi r31,0
 208 0026 41A1      		ldd r20,Z+33
 209               		.loc 1 408 38 is_stmt 0 view .LVU31
 210 0028 8F70      		andi r24,lo8(15)
 211               	.LVL7:
 212               		.loc 1 408 38 view .LVU32
 213 002a EB01      		movw r28,r22
 214 002c 00C0      		rjmp 2f
 215               		1:
 216 002e CC0F      		lsl r28
 217 0030 DD1F      		rol r29
 218               		2:
 219 0032 8A95      		dec r24
 220 0034 02F4      		brpl 1b
 221 0036 CE01      		movw r24,r28
 222               		.loc 1 408 34 view .LVU33
 223 0038 9C2F      		mov r25,r28
 224 003a 9095      		com r25
 225 003c 9423      		and r25,r20
 226 003e 91A3      		std Z+33,r25
 227               	.LVL8:
 409:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 228               		.loc 1 409 9 is_stmt 1 view .LVU34
 229 0040 92A1      		ldd r25,Z+34
 230               		.loc 1 409 34 is_stmt 0 view .LVU35
 231 0042 892B      		or r24,r25
 232 0044 82A3      		std Z+34,r24
 233               	.LBE23:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 234               		.loc 1 406 42 is_stmt 1 view .LVU36
 235               	.LVL9:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 236               		.loc 1 406 26 view .LVU37
 237 0046 2A17      		cp r18,r26
 238 0048 3B07      		cpc r19,r27
 239 004a 01F4      		brne .L10
 240 004c A0E0      		ldi r26,lo8(row_pins)
 241 004e B0E0      		ldi r27,hi8(row_pins)
 242               	.LVL10:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 243               		.loc 1 406 26 is_stmt 0 view .LVU38
 244 0050 20E0      		ldi r18,lo8(row_pins+13)
 245 0052 30E0      		ldi r19,hi8(row_pins+13)
 246               	.LBE22:
 247               	.LBE21:
 248               	.LBB24:
 249               	.LBB25:
 250               	.LBB26:
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 251               		.loc 1 345 38 view .LVU39
 252 0054 61E0      		ldi r22,lo8(1)
 253 0056 70E0      		ldi r23,0
 254               	.LVL11:
 255               	.L11:
 344:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 256               		.loc 1 344 9 is_stmt 1 view .LVU40
 344:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 257               		.loc 1 344 17 is_stmt 0 view .LVU41
 258 0058 8D91      		ld r24,X+
 259               	.LVL12:
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 260               		.loc 1 345 9 is_stmt 1 view .LVU42
 261 005a E82F      		mov r30,r24
 262 005c E295      		swap r30
 263 005e EF70      		andi r30,lo8(15)
 264 0060 F0E0      		ldi r31,0
 265 0062 41A1      		ldd r20,Z+33
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 266               		.loc 1 345 38 is_stmt 0 view .LVU43
 267 0064 8F70      		andi r24,lo8(15)
 268               	.LVL13:
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 269               		.loc 1 345 38 view .LVU44
 270 0066 EB01      		movw r28,r22
 271 0068 00C0      		rjmp 2f
 272               		1:
 273 006a CC0F      		lsl r28
 274 006c DD1F      		rol r29
 275               		2:
 276 006e 8A95      		dec r24
 277 0070 02F4      		brpl 1b
 278 0072 CE01      		movw r24,r28
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 279               		.loc 1 345 34 view .LVU45
 280 0074 9C2F      		mov r25,r28
 281 0076 9095      		com r25
 282 0078 9423      		and r25,r20
 283 007a 91A3      		std Z+33,r25
 284               	.LVL14:
 346:quantum/matrix.c ****     }
 285               		.loc 1 346 9 is_stmt 1 view .LVU46
 286 007c 92A1      		ldd r25,Z+34
 346:quantum/matrix.c ****     }
 287               		.loc 1 346 34 is_stmt 0 view .LVU47
 288 007e 892B      		or r24,r25
 289 0080 82A3      		std Z+34,r24
 290               	.LBE26:
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 291               		.loc 1 343 42 is_stmt 1 view .LVU48
 292               	.LVL15:
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 293               		.loc 1 343 26 view .LVU49
 294 0082 2A17      		cp r18,r26
 295 0084 3B07      		cpc r19,r27
 296 0086 01F4      		brne .L11
 297               	.LBE25:
 298               	.LBE24:
 299               	.LBB27:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 300               		.loc 1 168 19 is_stmt 0 view .LVU50
 301 0088 8DE0      		ldi r24,lo8(13)
 302 008a E0E0      		ldi r30,lo8(matrix)
 303 008c F0E0      		ldi r31,hi8(matrix)
 304 008e DF01      		movw r26,r30
 305               	.LVL16:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 306               		.loc 1 168 19 view .LVU51
 307 0090 C82F      		mov r28,r24
 308               		0:
 309 0092 1D92      		st X+,__zero_reg__
 310 0094 CA95      		dec r28
 311 0096 01F4      		brne 0b
 170:quantum/matrix.c ****     }
 312               		.loc 1 170 30 view .LVU52
 313 0098 E0E0      		ldi r30,lo8(matrix_debouncing)
 314 009a F0E0      		ldi r31,hi8(matrix_debouncing)
 315 009c DF01      		movw r26,r30
 316               		0:
 317 009e 1D92      		st X+,__zero_reg__
 318 00a0 8A95      		dec r24
 319 00a2 01F4      		brne 0b
 320               	.LVL17:
 170:quantum/matrix.c ****     }
 321               		.loc 1 170 30 view .LVU53
 322               	.LBE27:
 173:quantum/matrix.c **** }
 323               		.loc 1 173 5 is_stmt 1 view .LVU54
 324               	/* epilogue start */
 174:quantum/matrix.c **** 
 325               		.loc 1 174 1 is_stmt 0 view .LVU55
 326 00a4 DF91      		pop r29
 327 00a6 CF91      		pop r28
 173:quantum/matrix.c **** }
 328               		.loc 1 173 5 view .LVU56
 329 00a8 0C94 0000 		jmp matrix_init_quantum
 330               	.LVL18:
 331               		.cfi_endproc
 332               	.LFE18:
 334               		.section	.text.matrix_scan,"ax",@progbits
 335               	.global	matrix_scan
 337               	matrix_scan:
 338               	.LFB19:
 177:quantum/matrix.c **** 
 339               		.loc 1 177 1 is_stmt 1 view -0
 340               		.cfi_startproc
 341 0000 4F92      		push r4
 342               	.LCFI2:
 343               		.cfi_def_cfa_offset 3
 344               		.cfi_offset 4, -2
 345 0002 5F92      		push r5
 346               	.LCFI3:
 347               		.cfi_def_cfa_offset 4
 348               		.cfi_offset 5, -3
 349 0004 7F92      		push r7
 350               	.LCFI4:
 351               		.cfi_def_cfa_offset 5
 352               		.cfi_offset 7, -4
 353 0006 8F92      		push r8
 354               	.LCFI5:
 355               		.cfi_def_cfa_offset 6
 356               		.cfi_offset 8, -5
 357 0008 9F92      		push r9
 358               	.LCFI6:
 359               		.cfi_def_cfa_offset 7
 360               		.cfi_offset 9, -6
 361 000a AF92      		push r10
 362               	.LCFI7:
 363               		.cfi_def_cfa_offset 8
 364               		.cfi_offset 10, -7
 365 000c BF92      		push r11
 366               	.LCFI8:
 367               		.cfi_def_cfa_offset 9
 368               		.cfi_offset 11, -8
 369 000e CF92      		push r12
 370               	.LCFI9:
 371               		.cfi_def_cfa_offset 10
 372               		.cfi_offset 12, -9
 373 0010 DF92      		push r13
 374               	.LCFI10:
 375               		.cfi_def_cfa_offset 11
 376               		.cfi_offset 13, -10
 377 0012 EF92      		push r14
 378               	.LCFI11:
 379               		.cfi_def_cfa_offset 12
 380               		.cfi_offset 14, -11
 381 0014 FF92      		push r15
 382               	.LCFI12:
 383               		.cfi_def_cfa_offset 13
 384               		.cfi_offset 15, -12
 385 0016 0F93      		push r16
 386               	.LCFI13:
 387               		.cfi_def_cfa_offset 14
 388               		.cfi_offset 16, -13
 389 0018 1F93      		push r17
 390               	.LCFI14:
 391               		.cfi_def_cfa_offset 15
 392               		.cfi_offset 17, -14
 393 001a CF93      		push r28
 394               	.LCFI15:
 395               		.cfi_def_cfa_offset 16
 396               		.cfi_offset 28, -15
 397 001c DF93      		push r29
 398               	.LCFI16:
 399               		.cfi_def_cfa_offset 17
 400               		.cfi_offset 29, -16
 401               	/* prologue: function */
 402               	/* frame size = 0 */
 403               	/* stack size = 15 */
 404               	.L__stack_usage = 15
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 405               		.loc 1 200 5 view .LVU58
 406               	.LBB45:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 407               		.loc 1 200 10 view .LVU59
 408               	.LVL19:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 409               		.loc 1 200 47 view .LVU60
 410 001e 00E0      		ldi r16,lo8(col_pins)
 411 0020 10E0      		ldi r17,hi8(col_pins)
 412               	.LBE45:
 177:quantum/matrix.c **** 
 413               		.loc 1 177 1 is_stmt 0 view .LVU61
 414 0022 412C      		mov r4,__zero_reg__
 415 0024 512C      		mov r5,__zero_reg__
 416               	.LBB70:
 417               	.LBB46:
 418               	.LBB47:
 419               	.LBB48:
 420               	.LBB49:
 421               	.LBB50:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 422               		.loc 1 393 34 view .LVU62
 423 0026 CC24      		clr r12
 424 0028 C394      		inc r12
 425 002a D12C      		mov r13,__zero_reg__
 426 002c 90E0      		ldi r25,lo8(matrix_debouncing+13)
 427 002e E92E      		mov r14,r25
 428 0030 90E0      		ldi r25,hi8(matrix_debouncing+13)
 429 0032 F92E      		mov r15,r25
 430               	.LBE50:
 431               	.LBE49:
 432               	.LBB52:
 433               	.LBB53:
 434 0034 BB24      		clr r11
 435 0036 B394      		inc r11
 436               	.LVL20:
 437               	.L20:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 438               		.loc 1 393 34 view .LVU63
 439               	.LBE53:
 440               	.LBE52:
 441               	.LBE48:
 442               	.LBE47:
 202:quantum/matrix.c ****             if (matrix_changed) {
 443               		.loc 1 202 13 is_stmt 1 view .LVU64
 444               	.LBB67:
 445               	.LBI47:
 350:quantum/matrix.c **** {
 446               		.loc 1 350 13 view .LVU65
 447               	.LBB65:
 352:quantum/matrix.c **** 
 448               		.loc 1 352 5 view .LVU66
 355:quantum/matrix.c ****     wait_us(30);
 449               		.loc 1 355 5 view .LVU67
 450               	.LBB57:
 451               	.LBI49:
 390:quantum/matrix.c **** {
 452               		.loc 1 390 13 view .LVU68
 453               	.LBB51:
 392:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 454               		.loc 1 392 5 view .LVU69
 392:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 455               		.loc 1 392 13 is_stmt 0 view .LVU70
 456 0038 E801      		movw r28,r16
 457 003a 8991      		ld r24,Y+
 458 003c 8E01      		movw r16,r28
 459               	.LVL21:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 460               		.loc 1 393 5 is_stmt 1 view .LVU71
 461 003e E82F      		mov r30,r24
 462 0040 E295      		swap r30
 463 0042 EF70      		andi r30,lo8(15)
 464 0044 F0E0      		ldi r31,0
 465 0046 21A1      		ldd r18,Z+33
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 466               		.loc 1 393 34 is_stmt 0 view .LVU72
 467 0048 8F70      		andi r24,lo8(15)
 468               	.LVL22:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 469               		.loc 1 393 34 view .LVU73
 470 004a A601      		movw r20,r12
 471 004c 00C0      		rjmp 2f
 472               		1:
 473 004e 440F      		lsl r20
 474 0050 551F      		rol r21
 475               		2:
 476 0052 8A95      		dec r24
 477 0054 02F4      		brpl 1b
 478 0056 CA01      		movw r24,r20
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 479               		.loc 1 393 30 view .LVU74
 480 0058 242B      		or r18,r20
 481 005a 21A3      		std Z+33,r18
 482               	.LVL23:
 394:quantum/matrix.c **** }
 483               		.loc 1 394 5 is_stmt 1 view .LVU75
 484 005c 32A1      		ldd r19,Z+34
 394:quantum/matrix.c **** }
 485               		.loc 1 394 30 is_stmt 0 view .LVU76
 486 005e 242F      		mov r18,r20
 487 0060 2095      		com r18
 488 0062 3223      		and r19,r18
 489 0064 32A3      		std Z+34,r19
 490               	.LVL24:
 394:quantum/matrix.c **** }
 491               		.loc 1 394 30 view .LVU77
 492               	.LBE51:
 493               	.LBE57:
 356:quantum/matrix.c **** 
 494               		.loc 1 356 5 is_stmt 1 view .LVU78
 495               	.LBB58:
 496               	.LBI58:
 497               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2551 2020-10-10 20:33:35Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 498               		.loc 2 255 1 view .LVU79
 499               	.LBB59:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 500               		.loc 2 257 2 view .LVU80
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 501               		.loc 2 261 2 view .LVU81
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 502               		.loc 2 262 2 view .LVU82
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 503               		.loc 2 263 2 view .LVU83
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 504               		.loc 2 273 3 view .LVU84
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 505               		.loc 2 276 2 view .LVU85
 506 0066 50EA      		ldi r21,lo8(-96)
 507 0068 5A95      	1:	dec r21
 508 006a 01F4      		brne 1b
 509               	.LVL25:
 510               		.loc 2 276 2 is_stmt 0 view .LVU86
 511               	.LBE59:
 512               	.LBE58:
 359:quantum/matrix.c ****     {
 513               		.loc 1 359 5 is_stmt 1 view .LVU87
 514               	.LBB60:
 359:quantum/matrix.c ****     {
 515               		.loc 1 359 9 view .LVU88
 359:quantum/matrix.c ****     {
 516               		.loc 1 359 42 view .LVU89
 517               	.LBB54:
 374:quantum/matrix.c ****         }
 518               		.loc 1 374 56 is_stmt 0 view .LVU90
 519 006c A601      		movw r20,r12
 520 006e 042C      		mov r0,r4
 521 0070 00C0      		rjmp 2f
 522               		1:
 523 0072 440F      		lsl r20
 524               		2:
 525 0074 0A94      		dec r0
 526 0076 02F4      		brpl 1b
 374:quantum/matrix.c ****         }
 527               		.loc 1 374 39 view .LVU91
 528 0078 842E      		mov r8,r20
 529 007a 8094      		com r8
 530 007c 342F      		mov r19,r20
 531 007e A0E0      		ldi r26,lo8(matrix_debouncing)
 532 0080 B0E0      		ldi r27,hi8(matrix_debouncing)
 533 0082 40E0      		ldi r20,lo8(row_pins)
 534 0084 50E0      		ldi r21,hi8(row_pins)
 535               	.LBE54:
 536               	.LBE60:
 352:quantum/matrix.c **** 
 537               		.loc 1 352 10 view .LVU92
 538 0086 912C      		mov r9,__zero_reg__
 539               	.LVL26:
 540               	.L18:
 541               	.LBB61:
 542               	.LBB55:
 363:quantum/matrix.c **** 
 543               		.loc 1 363 9 is_stmt 1 view .LVU93
 363:quantum/matrix.c **** 
 544               		.loc 1 363 22 is_stmt 0 view .LVU94
 545 0088 AD90      		ld r10,X+
 546               	.LVL27:
 366:quantum/matrix.c ****         {
 547               		.loc 1 366 9 is_stmt 1 view .LVU95
 366:quantum/matrix.c ****         {
 548               		.loc 1 366 14 is_stmt 0 view .LVU96
 549 008a EA01      		movw r28,r20
 550 008c 7990      		ld r7,Y+
 551 008e AE01      		movw r20,r28
 552 0090 672D      		mov r22,r7
 553 0092 6295      		swap r22
 554 0094 6F70      		andi r22,lo8(15)
 555 0096 605E      		subi r22,lo8(-(32))
 556 0098 70E0      		ldi r23,0
 557 009a EB01      		movw r28,r22
 558 009c 6881      		ld r22,Y
 559 009e 70E0      		ldi r23,0
 366:quantum/matrix.c ****         {
 560               		.loc 1 366 51 view .LVU97
 561 00a0 D72D      		mov r29,r7
 562 00a2 DF70      		andi r29,lo8(15)
 366:quantum/matrix.c ****         {
 563               		.loc 1 366 83 view .LVU98
 564 00a4 00C0      		rjmp 2f
 565               		1:
 566 00a6 7595      		asr r23
 567 00a8 6795      		ror r22
 568               		2:
 569 00aa DA95      		dec r29
 570 00ac 02F4      		brpl 1b
 369:quantum/matrix.c ****         }
 571               		.loc 1 369 39 view .LVU99
 572 00ae 7A2C      		mov r7,r10
 366:quantum/matrix.c ****         {
 573               		.loc 1 366 12 view .LVU100
 574 00b0 60FD      		sbrc r22,0
 575 00b2 00C0      		rjmp .L15
 369:quantum/matrix.c ****         }
 576               		.loc 1 369 13 is_stmt 1 view .LVU101
 369:quantum/matrix.c ****         }
 577               		.loc 1 369 39 is_stmt 0 view .LVU102
 578 00b4 732A      		or r7,r19
 579               	.L16:
 580 00b6 BD01      		movw r22,r26
 581 00b8 6150      		subi r22,1
 582 00ba 7109      		sbc r23,__zero_reg__
 583 00bc EB01      		movw r28,r22
 584 00be 7882      		st Y,r7
 378:quantum/matrix.c ****         {
 585               		.loc 1 378 9 is_stmt 1 view .LVU103
 378:quantum/matrix.c ****         {
 586               		.loc 1 378 12 is_stmt 0 view .LVU104
 587 00c0 A714      		cp r10,r7
 588 00c2 01F0      		breq .L17
 589 00c4 9924      		clr r9
 590 00c6 9394      		inc r9
 591               	.LVL28:
 592               	.L17:
 378:quantum/matrix.c ****         {
 593               		.loc 1 378 12 view .LVU105
 594               	.LBE55:
 359:quantum/matrix.c ****     {
 595               		.loc 1 359 66 is_stmt 1 view .LVU106
 359:quantum/matrix.c ****     {
 596               		.loc 1 359 42 view .LVU107
 597 00c8 EA16      		cp r14,r26
 598 00ca FB06      		cpc r15,r27
 599 00cc 01F4      		brne .L18
 600               	.LBE61:
 385:quantum/matrix.c **** 
 601               		.loc 1 385 5 view .LVU108
 602               	.LVL29:
 603               	.LBB62:
 604               	.LBI62:
 397:quantum/matrix.c **** {
 605               		.loc 1 397 13 view .LVU109
 606               	.LBB63:
 399:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 607               		.loc 1 399 5 view .LVU110
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 608               		.loc 1 400 5 view .LVU111
 609 00ce 91A1      		ldd r25,Z+33
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 610               		.loc 1 400 30 is_stmt 0 view .LVU112
 611 00d0 2923      		and r18,r25
 612 00d2 21A3      		std Z+33,r18
 401:quantum/matrix.c **** }
 613               		.loc 1 401 5 is_stmt 1 view .LVU113
 614 00d4 92A1      		ldd r25,Z+34
 401:quantum/matrix.c **** }
 615               		.loc 1 401 30 is_stmt 0 view .LVU114
 616 00d6 892B      		or r24,r25
 617 00d8 82A3      		std Z+34,r24
 618               	.LVL30:
 401:quantum/matrix.c **** }
 619               		.loc 1 401 30 view .LVU115
 620               	.LBE63:
 621               	.LBE62:
 387:quantum/matrix.c **** }
 622               		.loc 1 387 5 is_stmt 1 view .LVU116
 387:quantum/matrix.c **** }
 623               		.loc 1 387 5 is_stmt 0 view .LVU117
 624               	.LBE65:
 625               	.LBE67:
 203:quantum/matrix.c ****                 debouncing = true;
 626               		.loc 1 203 13 is_stmt 1 view .LVU118
 203:quantum/matrix.c ****                 debouncing = true;
 627               		.loc 1 203 16 is_stmt 0 view .LVU119
 628 00da 9920      		tst r9
 629 00dc 01F0      		breq .L19
 630               	.LVL31:
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 631               		.loc 1 204 17 is_stmt 1 view .LVU120
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 632               		.loc 1 204 28 is_stmt 0 view .LVU121
 633 00de B092 0000 		sts debouncing,r11
 205:quantum/matrix.c ****             }
 634               		.loc 1 205 17 is_stmt 1 view .LVU122
 205:quantum/matrix.c ****             }
 635               		.loc 1 205 35 is_stmt 0 view .LVU123
 636 00e2 0E94 0000 		call timer_read
 637               	.LVL32:
 205:quantum/matrix.c ****             }
 638               		.loc 1 205 33 view .LVU124
 639 00e6 9093 0000 		sts debouncing_time+1,r25
 640 00ea 8093 0000 		sts debouncing_time,r24
 641               	.LVL33:
 642               	.L19:
 205:quantum/matrix.c ****             }
 643               		.loc 1 205 33 view .LVU125
 644               	.LBE46:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 645               		.loc 1 200 73 is_stmt 1 discriminator 2 view .LVU126
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 646               		.loc 1 200 47 discriminator 2 view .LVU127
 647 00ee DFEF      		ldi r29,-1
 648 00f0 4D1A      		sub r4,r29
 649 00f2 5D0A      		sbc r5,r29
 650               	.LVL34:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 651               		.loc 1 200 47 is_stmt 0 discriminator 2 view .LVU128
 652 00f4 E8E0      		ldi r30,8
 653 00f6 4E16      		cp r4,r30
 654 00f8 5104      		cpc r5,__zero_reg__
 655 00fa 01F0      		breq .+2
 656 00fc 00C0      		rjmp .L20
 657               	.LBE70:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 658               		.loc 1 216 9 is_stmt 1 view .LVU129
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 659               		.loc 1 216 12 is_stmt 0 view .LVU130
 660 00fe 8091 0000 		lds r24,debouncing
 661 0102 8823      		tst r24
 662 0104 01F0      		breq .L22
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 663               		.loc 1 216 28 discriminator 1 view .LVU131
 664 0106 8091 0000 		lds r24,debouncing_time
 665 010a 9091 0000 		lds r25,debouncing_time+1
 666 010e 0E94 0000 		call timer_elapsed
 667               	.LVL35:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 668               		.loc 1 216 24 discriminator 1 view .LVU132
 669 0112 0697      		sbiw r24,6
 670 0114 00F0      		brlo .L22
 671               	.LBB71:
 218:quantum/matrix.c ****             }
 672               		.loc 1 218 27 view .LVU133
 673 0116 8DE0      		ldi r24,lo8(13)
 674 0118 E0E0      		ldi r30,lo8(matrix_debouncing)
 675 011a F0E0      		ldi r31,hi8(matrix_debouncing)
 676 011c A0E0      		ldi r26,lo8(matrix)
 677 011e B0E0      		ldi r27,hi8(matrix)
 678               		0:
 679 0120 0190      		ld r0,Z+
 680 0122 0D92      		st X+,r0
 681 0124 8A95      		dec r24
 682 0126 01F4      		brne 0b
 683               	.LBE71:
 220:quantum/matrix.c ****         }
 684               		.loc 1 220 13 is_stmt 1 view .LVU134
 220:quantum/matrix.c ****         }
 685               		.loc 1 220 24 is_stmt 0 view .LVU135
 686 0128 1092 0000 		sts debouncing,__zero_reg__
 687               	.L22:
 224:quantum/matrix.c ****     return 1;
 688               		.loc 1 224 5 is_stmt 1 view .LVU136
 689 012c 0E94 0000 		call matrix_scan_quantum
 690               	.LVL36:
 225:quantum/matrix.c **** }
 691               		.loc 1 225 5 view .LVU137
 226:quantum/matrix.c **** 
 692               		.loc 1 226 1 is_stmt 0 view .LVU138
 693 0130 81E0      		ldi r24,lo8(1)
 694               	/* epilogue start */
 695 0132 DF91      		pop r29
 696 0134 CF91      		pop r28
 697 0136 1F91      		pop r17
 698 0138 0F91      		pop r16
 699 013a FF90      		pop r15
 700 013c EF90      		pop r14
 701 013e DF90      		pop r13
 702 0140 CF90      		pop r12
 703 0142 BF90      		pop r11
 704 0144 AF90      		pop r10
 705 0146 9F90      		pop r9
 706 0148 8F90      		pop r8
 707 014a 7F90      		pop r7
 708 014c 5F90      		pop r5
 709 014e 4F90      		pop r4
 710               	.LVL37:
 226:quantum/matrix.c **** 
 711               		.loc 1 226 1 view .LVU139
 712 0150 0895      		ret
 713               	.LVL38:
 714               	.L15:
 715               	.LBB72:
 716               	.LBB69:
 717               	.LBB68:
 718               	.LBB66:
 719               	.LBB64:
 720               	.LBB56:
 374:quantum/matrix.c ****         }
 721               		.loc 1 374 13 is_stmt 1 view .LVU140
 374:quantum/matrix.c ****         }
 722               		.loc 1 374 39 is_stmt 0 view .LVU141
 723 0152 7820      		and r7,r8
 724               	.LVL39:
 374:quantum/matrix.c ****         }
 725               		.loc 1 374 39 view .LVU142
 726 0154 00C0      		rjmp .L16
 727               	.LBE56:
 728               	.LBE64:
 729               	.LBE66:
 730               	.LBE68:
 731               	.LBE69:
 732               	.LBE72:
 733               		.cfi_endproc
 734               	.LFE19:
 736               		.section	.text.matrix_is_modified,"ax",@progbits
 737               	.global	matrix_is_modified
 739               	matrix_is_modified:
 740               	.LFB20:
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 741               		.loc 1 229 1 is_stmt 1 view -0
 742               		.cfi_startproc
 743               	/* prologue: function */
 744               	/* frame size = 0 */
 745               	/* stack size = 0 */
 746               	.L__stack_usage = 0
 231:quantum/matrix.c **** #endif
 747               		.loc 1 231 5 view .LVU144
 231:quantum/matrix.c **** #endif
 748               		.loc 1 231 8 is_stmt 0 view .LVU145
 749 0000 8091 0000 		lds r24,debouncing
 234:quantum/matrix.c **** 
 750               		.loc 1 234 1 view .LVU146
 751 0004 91E0      		ldi r25,lo8(1)
 752 0006 8927      		eor r24,r25
 753               	/* epilogue start */
 754 0008 0895      		ret
 755               		.cfi_endproc
 756               	.LFE20:
 758               		.section	.text.matrix_is_on,"ax",@progbits
 759               	.global	matrix_is_on
 761               	matrix_is_on:
 762               	.LVL40:
 763               	.LFB21:
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 764               		.loc 1 238 1 is_stmt 1 view -0
 765               		.cfi_startproc
 766               	/* prologue: function */
 767               	/* frame size = 0 */
 768               	/* stack size = 0 */
 769               	.L__stack_usage = 0
 239:quantum/matrix.c **** }
 770               		.loc 1 239 5 view .LVU148
 239:quantum/matrix.c **** }
 771               		.loc 1 239 19 is_stmt 0 view .LVU149
 772 0000 E82F      		mov r30,r24
 773 0002 F0E0      		ldi r31,0
 774 0004 E050      		subi r30,lo8(-(matrix))
 775 0006 F040      		sbci r31,hi8(-(matrix))
 776 0008 8081      		ld r24,Z
 777               	.LVL41:
 239:quantum/matrix.c **** }
 778               		.loc 1 239 19 view .LVU150
 779 000a 90E0      		ldi r25,0
 239:quantum/matrix.c **** }
 780               		.loc 1 239 43 view .LVU151
 781 000c 21E0      		ldi r18,lo8(1)
 782 000e 30E0      		ldi r19,0
 783 0010 6230      		cpi r22,lo8(2)
 784 0012 00F4      		brsh .L32
 785 0014 20E0      		ldi r18,0
 786 0016 30E0      		ldi r19,0
 787               	.L32:
 239:quantum/matrix.c **** }
 788               		.loc 1 239 25 view .LVU152
 789 0018 8223      		and r24,r18
 790 001a 9323      		and r25,r19
 240:quantum/matrix.c **** 
 791               		.loc 1 240 1 view .LVU153
 792 001c 8170      		andi r24,lo8(1)
 793               	/* epilogue start */
 794 001e 0895      		ret
 795               		.cfi_endproc
 796               	.LFE21:
 798               		.section	.text.matrix_get_row,"ax",@progbits
 799               	.global	matrix_get_row
 801               	matrix_get_row:
 802               	.LVL42:
 803               	.LFB22:
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 804               		.loc 1 244 1 is_stmt 1 view -0
 805               		.cfi_startproc
 806               	/* prologue: function */
 807               	/* frame size = 0 */
 808               	/* stack size = 0 */
 809               	.L__stack_usage = 0
 250:quantum/matrix.c **** #endif
 810               		.loc 1 250 5 view .LVU155
 250:quantum/matrix.c **** #endif
 811               		.loc 1 250 18 is_stmt 0 view .LVU156
 812 0000 E82F      		mov r30,r24
 813 0002 F0E0      		ldi r31,0
 814 0004 E050      		subi r30,lo8(-(matrix))
 815 0006 F040      		sbci r31,hi8(-(matrix))
 252:quantum/matrix.c **** 
 816               		.loc 1 252 1 view .LVU157
 817 0008 8081      		ld r24,Z
 818               	.LVL43:
 819               	/* epilogue start */
 252:quantum/matrix.c **** 
 820               		.loc 1 252 1 view .LVU158
 821 000a 0895      		ret
 822               		.cfi_endproc
 823               	.LFE22:
 825               		.section	.text.matrix_print,"ax",@progbits
 826               	.global	matrix_print
 828               	matrix_print:
 829               	.LFB23:
 255:quantum/matrix.c ****     print_matrix_header();
 830               		.loc 1 255 1 is_stmt 1 view -0
 831               		.cfi_startproc
 832               	/* prologue: function */
 833               	/* frame size = 0 */
 834               	/* stack size = 0 */
 835               	.L__stack_usage = 0
 256:quantum/matrix.c **** 
 836               		.loc 1 256 26 view .LVU160
 258:quantum/matrix.c ****         phex(row); print(": ");
 837               		.loc 1 258 5 view .LVU161
 258:quantum/matrix.c ****         phex(row); print(": ");
 838               		.loc 1 258 10 view .LVU162
 258:quantum/matrix.c ****         phex(row); print(": ");
 839               		.loc 1 258 31 view .LVU163
 840               	/* epilogue start */
 263:quantum/matrix.c **** 
 841               		.loc 1 263 1 is_stmt 0 view .LVU164
 842 0000 0895      		ret
 843               		.cfi_endproc
 844               	.LFE23:
 846               		.section	.text.matrix_key_count,"ax",@progbits
 847               	.global	matrix_key_count
 849               	matrix_key_count:
 850               	.LFB24:
 266:quantum/matrix.c ****     uint8_t count = 0;
 851               		.loc 1 266 1 is_stmt 1 view -0
 852               		.cfi_startproc
 853 0000 0F93      		push r16
 854               	.LCFI17:
 855               		.cfi_def_cfa_offset 3
 856               		.cfi_offset 16, -2
 857 0002 1F93      		push r17
 858               	.LCFI18:
 859               		.cfi_def_cfa_offset 4
 860               		.cfi_offset 17, -3
 861 0004 CF93      		push r28
 862               	.LCFI19:
 863               		.cfi_def_cfa_offset 5
 864               		.cfi_offset 28, -4
 865               	/* prologue: function */
 866               	/* frame size = 0 */
 867               	/* stack size = 3 */
 868               	.L__stack_usage = 3
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 869               		.loc 1 267 5 view .LVU166
 870               	.LVL44:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 871               		.loc 1 268 5 view .LVU167
 872               	.LBB73:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 873               		.loc 1 268 10 view .LVU168
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 874               		.loc 1 268 27 view .LVU169
 875 0006 00E0      		ldi r16,lo8(matrix)
 876 0008 10E0      		ldi r17,hi8(matrix)
 877               	.LBE73:
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 878               		.loc 1 267 13 is_stmt 0 view .LVU170
 879 000a C0E0      		ldi r28,0
 880               	.LVL45:
 881               	.L36:
 882               	.LBB74:
 269:quantum/matrix.c ****     }
 883               		.loc 1 269 9 is_stmt 1 discriminator 3 view .LVU171
 269:quantum/matrix.c ****     }
 884               		.loc 1 269 18 is_stmt 0 discriminator 3 view .LVU172
 885 000c F801      		movw r30,r16
 886 000e 8191      		ld r24,Z+
 887 0010 8F01      		movw r16,r30
 888               	.LVL46:
 269:quantum/matrix.c ****     }
 889               		.loc 1 269 18 discriminator 3 view .LVU173
 890 0012 0E94 0000 		call bitpop
 891               	.LVL47:
 269:quantum/matrix.c ****     }
 892               		.loc 1 269 15 discriminator 3 view .LVU174
 893 0016 C80F      		add r28,r24
 894               	.LVL48:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 895               		.loc 1 268 43 is_stmt 1 discriminator 3 view .LVU175
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 896               		.loc 1 268 27 discriminator 3 view .LVU176
 897 0018 F0E0      		ldi r31,hi8(matrix+13)
 898 001a 0030      		cpi r16,lo8(matrix+13)
 899 001c 1F07      		cpc r17,r31
 900 001e 01F4      		brne .L36
 901               	.LBE74:
 271:quantum/matrix.c **** }
 902               		.loc 1 271 5 view .LVU177
 272:quantum/matrix.c **** 
 903               		.loc 1 272 1 is_stmt 0 view .LVU178
 904 0020 8C2F      		mov r24,r28
 905               	/* epilogue start */
 906 0022 CF91      		pop r28
 907               	.LVL49:
 272:quantum/matrix.c **** 
 908               		.loc 1 272 1 view .LVU179
 909 0024 1F91      		pop r17
 910 0026 0F91      		pop r16
 911               	.LVL50:
 272:quantum/matrix.c **** 
 912               		.loc 1 272 1 view .LVU180
 913 0028 0895      		ret
 914               		.cfi_endproc
 915               	.LFE24:
 917               		.section	.bss.matrix_debouncing,"aw",@nobits
 920               	matrix_debouncing:
 921 0000 0000 0000 		.zero	13
 921      0000 0000 
 921      0000 0000 
 921      00
 922               		.section	.bss.matrix,"aw",@nobits
 925               	matrix:
 926 0000 0000 0000 		.zero	13
 926      0000 0000 
 926      0000 0000 
 926      00
 927               		.section	.rodata.col_pins,"a"
 930               	col_pins:
 931 0000 9697 3435 		.ascii	"\226\227456\367\366\365"
 931      36F7 F6F5 
 932               		.section	.rodata.row_pins,"a"
 935               	row_pins:
 936 0000 3031 3233 		.ascii	"01237\220\221\222\223fg\225\224"
 936      3790 9192 
 936      9366 6795 
 936      94
 937               		.section	.bss.debouncing,"aw",@nobits
 940               	debouncing:
 941 0000 00        		.zero	1
 942               		.section	.bss.debouncing_time,"aw",@nobits
 945               	debouncing_time:
 946 0000 0000      		.zero	2
 947               		.text
 948               	.Letext0:
 949               		.file 3 "/usr/avr/include/stdint.h"
 950               		.file 4 "./tmk_core/common/matrix.h"
 951               		.file 5 "./tmk_core/common/util.h"
 952               		.file 6 "./tmk_core/common/timer.h"
 953               		.file 7 "/usr/avr/include/math.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/cciufS4Q.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cciufS4Q.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cciufS4Q.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cciufS4Q.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cciufS4Q.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cciufS4Q.s:14     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/cciufS4Q.s:16     .text.matrix_init_user:0000000000000000 .Loc.0
     /tmp/cciufS4Q.s:17     .text.matrix_init_user:0000000000000000 L0
     /tmp/cciufS4Q.s:22     .text.matrix_init_user:0000000000000000 .Loc.1
     /tmp/cciufS4Q.s:25     .text.matrix_init_user:0000000000000002 L0
     /tmp/cciufS4Q.s:14     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias
     /tmp/cciufS4Q.s:32     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/cciufS4Q.s:34     .text.matrix_init_kb:0000000000000000 .Loc.2
     /tmp/cciufS4Q.s:35     .text.matrix_init_kb:0000000000000000 L0
     /tmp/cciufS4Q.s:40     .text.matrix_init_kb:0000000000000000 .Loc.3
     /tmp/cciufS4Q.s:43     .text.matrix_init_kb:0000000000000004 L0
     /tmp/cciufS4Q.s:49     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/cciufS4Q.s:51     .text.matrix_init_quantum:0000000000000000 .Loc.4
     /tmp/cciufS4Q.s:52     .text.matrix_init_quantum:0000000000000000 L0
     /tmp/cciufS4Q.s:57     .text.matrix_init_quantum:0000000000000000 .Loc.5
     /tmp/cciufS4Q.s:60     .text.matrix_init_quantum:0000000000000004 L0
     /tmp/cciufS4Q.s:66     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/cciufS4Q.s:68     .text.matrix_scan_user:0000000000000000 L0
     /tmp/cciufS4Q.s:69     .text.matrix_scan_user:0000000000000000 .Loc.6
     /tmp/cciufS4Q.s:76     .text.matrix_scan_user:0000000000000002 L0
     /tmp/cciufS4Q.s:82     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/cciufS4Q.s:84     .text.matrix_scan_kb:0000000000000000 .Loc.7
     /tmp/cciufS4Q.s:85     .text.matrix_scan_kb:0000000000000000 L0
     /tmp/cciufS4Q.s:90     .text.matrix_scan_kb:0000000000000000 .Loc.8
     /tmp/cciufS4Q.s:93     .text.matrix_scan_kb:0000000000000004 L0
     /tmp/cciufS4Q.s:99     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/cciufS4Q.s:101    .text.matrix_scan_quantum:0000000000000000 .Loc.9
     /tmp/cciufS4Q.s:102    .text.matrix_scan_quantum:0000000000000000 L0
     /tmp/cciufS4Q.s:107    .text.matrix_scan_quantum:0000000000000000 .Loc.10
     /tmp/cciufS4Q.s:110    .text.matrix_scan_quantum:0000000000000004 L0
     /tmp/cciufS4Q.s:116    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/cciufS4Q.s:118    .text.matrix_rows:0000000000000000 .Loc.11
     /tmp/cciufS4Q.s:119    .text.matrix_rows:0000000000000000 L0
     /tmp/cciufS4Q.s:124    .text.matrix_rows:0000000000000000 .Loc.12
     /tmp/cciufS4Q.s:125    .text.matrix_rows:0000000000000000 .Loc.13
     /tmp/cciufS4Q.s:129    .text.matrix_rows:0000000000000004 L0
     /tmp/cciufS4Q.s:135    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/cciufS4Q.s:137    .text.matrix_cols:0000000000000000 .Loc.14
     /tmp/cciufS4Q.s:138    .text.matrix_cols:0000000000000000 L0
     /tmp/cciufS4Q.s:143    .text.matrix_cols:0000000000000000 .Loc.15
     /tmp/cciufS4Q.s:144    .text.matrix_cols:0000000000000000 .Loc.16
     /tmp/cciufS4Q.s:148    .text.matrix_cols:0000000000000004 L0
     /tmp/cciufS4Q.s:154    .text.matrix_init:0000000000000000 matrix_init
     /tmp/cciufS4Q.s:156    .text.matrix_init:0000000000000000 .Loc.17
     /tmp/cciufS4Q.s:157    .text.matrix_init:0000000000000000 L0
     /tmp/cciufS4Q.s:170    .text.matrix_init:0000000000000004 .Loc.18
     /tmp/cciufS4Q.s:172    .text.matrix_init:0000000000000006 .Loc.19
     /tmp/cciufS4Q.s:175    .text.matrix_init:000000000000000a .Loc.20
     /tmp/cciufS4Q.s:177    .text.matrix_init:000000000000000c .Loc.21
     /tmp/cciufS4Q.s:180    .text.matrix_init:0000000000000010 .Loc.22
     /tmp/cciufS4Q.s:183    .text.matrix_init:0000000000000010 .Loc.23
     /tmp/cciufS4Q.s:184    .text.matrix_init:0000000000000010 .Loc.24
     /tmp/cciufS4Q.s:186    .text.matrix_init:0000000000000010 .Loc.25
     /tmp/cciufS4Q.s:188    .text.matrix_init:0000000000000010 .Loc.26
     /tmp/cciufS4Q.s:930    .rodata.col_pins:0000000000000000 col_pins
     /tmp/cciufS4Q.s:194    .text.matrix_init:0000000000000018 .Loc.27
     /tmp/cciufS4Q.s:199    .text.matrix_init:000000000000001c .Loc.28
     /tmp/cciufS4Q.s:200    .text.matrix_init:000000000000001c .Loc.29
     /tmp/cciufS4Q.s:203    .text.matrix_init:000000000000001e .Loc.30
     /tmp/cciufS4Q.s:209    .text.matrix_init:0000000000000028 .Loc.31
     /tmp/cciufS4Q.s:212    .text.matrix_init:000000000000002a .Loc.32
     /tmp/cciufS4Q.s:222    .text.matrix_init:0000000000000038 .Loc.33
     /tmp/cciufS4Q.s:228    .text.matrix_init:0000000000000040 .Loc.34
     /tmp/cciufS4Q.s:230    .text.matrix_init:0000000000000042 .Loc.35
     /tmp/cciufS4Q.s:234    .text.matrix_init:0000000000000046 .Loc.36
     /tmp/cciufS4Q.s:236    .text.matrix_init:0000000000000046 .Loc.37
     /tmp/cciufS4Q.s:935    .rodata.row_pins:0000000000000000 row_pins
     /tmp/cciufS4Q.s:243    .text.matrix_init:0000000000000050 .Loc.38
     /tmp/cciufS4Q.s:251    .text.matrix_init:0000000000000054 .Loc.39
     /tmp/cciufS4Q.s:256    .text.matrix_init:0000000000000058 .Loc.40
     /tmp/cciufS4Q.s:257    .text.matrix_init:0000000000000058 .Loc.41
     /tmp/cciufS4Q.s:260    .text.matrix_init:000000000000005a .Loc.42
     /tmp/cciufS4Q.s:266    .text.matrix_init:0000000000000064 .Loc.43
     /tmp/cciufS4Q.s:269    .text.matrix_init:0000000000000066 .Loc.44
     /tmp/cciufS4Q.s:279    .text.matrix_init:0000000000000074 .Loc.45
     /tmp/cciufS4Q.s:285    .text.matrix_init:000000000000007c .Loc.46
     /tmp/cciufS4Q.s:287    .text.matrix_init:000000000000007e .Loc.47
     /tmp/cciufS4Q.s:291    .text.matrix_init:0000000000000082 .Loc.48
     /tmp/cciufS4Q.s:293    .text.matrix_init:0000000000000082 .Loc.49
     /tmp/cciufS4Q.s:300    .text.matrix_init:0000000000000088 .Loc.50
     /tmp/cciufS4Q.s:925    .bss.matrix:0000000000000000 matrix
     /tmp/cciufS4Q.s:306    .text.matrix_init:0000000000000090 .Loc.51
     /tmp/cciufS4Q.s:312    .text.matrix_init:0000000000000098 .Loc.52
     /tmp/cciufS4Q.s:920    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/cciufS4Q.s:321    .text.matrix_init:00000000000000a4 .Loc.53
     /tmp/cciufS4Q.s:323    .text.matrix_init:00000000000000a4 .Loc.54
     /tmp/cciufS4Q.s:325    .text.matrix_init:00000000000000a4 .Loc.55
     /tmp/cciufS4Q.s:328    .text.matrix_init:00000000000000a8 .Loc.56
     /tmp/cciufS4Q.s:331    .text.matrix_init:00000000000000ac L0
     /tmp/cciufS4Q.s:337    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/cciufS4Q.s:339    .text.matrix_scan:0000000000000000 .Loc.57
     /tmp/cciufS4Q.s:340    .text.matrix_scan:0000000000000000 L0
     /tmp/cciufS4Q.s:405    .text.matrix_scan:000000000000001e .Loc.58
     /tmp/cciufS4Q.s:407    .text.matrix_scan:000000000000001e .Loc.59
     /tmp/cciufS4Q.s:409    .text.matrix_scan:000000000000001e .Loc.60
     /tmp/cciufS4Q.s:413    .text.matrix_scan:0000000000000022 .Loc.61
     /tmp/cciufS4Q.s:422    .text.matrix_scan:0000000000000026 .Loc.62
     /tmp/cciufS4Q.s:438    .text.matrix_scan:0000000000000038 .Loc.63
     /tmp/cciufS4Q.s:443    .text.matrix_scan:0000000000000038 .Loc.64
     /tmp/cciufS4Q.s:446    .text.matrix_scan:0000000000000038 .Loc.65
     /tmp/cciufS4Q.s:448    .text.matrix_scan:0000000000000038 .Loc.66
     /tmp/cciufS4Q.s:449    .text.matrix_scan:0000000000000038 .Loc.67
     /tmp/cciufS4Q.s:452    .text.matrix_scan:0000000000000038 .Loc.68
     /tmp/cciufS4Q.s:454    .text.matrix_scan:0000000000000038 .Loc.69
     /tmp/cciufS4Q.s:455    .text.matrix_scan:0000000000000038 .Loc.70
     /tmp/cciufS4Q.s:460    .text.matrix_scan:000000000000003e .Loc.71
     /tmp/cciufS4Q.s:466    .text.matrix_scan:0000000000000048 .Loc.72
     /tmp/cciufS4Q.s:469    .text.matrix_scan:000000000000004a .Loc.73
     /tmp/cciufS4Q.s:479    .text.matrix_scan:0000000000000058 .Loc.74
     /tmp/cciufS4Q.s:483    .text.matrix_scan:000000000000005c .Loc.75
     /tmp/cciufS4Q.s:485    .text.matrix_scan:000000000000005e .Loc.76
     /tmp/cciufS4Q.s:491    .text.matrix_scan:0000000000000066 .Loc.77
     /tmp/cciufS4Q.s:494    .text.matrix_scan:0000000000000066 .Loc.78
     /tmp/cciufS4Q.s:498    .text.matrix_scan:0000000000000066 .Loc.79
     /tmp/cciufS4Q.s:500    .text.matrix_scan:0000000000000066 .Loc.80
     /tmp/cciufS4Q.s:501    .text.matrix_scan:0000000000000066 .Loc.81
     /tmp/cciufS4Q.s:502    .text.matrix_scan:0000000000000066 .Loc.82
     /tmp/cciufS4Q.s:503    .text.matrix_scan:0000000000000066 .Loc.83
     /tmp/cciufS4Q.s:504    .text.matrix_scan:0000000000000066 .Loc.84
     /tmp/cciufS4Q.s:505    .text.matrix_scan:0000000000000066 .Loc.85
     /tmp/cciufS4Q.s:510    .text.matrix_scan:000000000000006c .Loc.86
     /tmp/cciufS4Q.s:513    .text.matrix_scan:000000000000006c .Loc.87
     /tmp/cciufS4Q.s:515    .text.matrix_scan:000000000000006c .Loc.88
     /tmp/cciufS4Q.s:516    .text.matrix_scan:000000000000006c .Loc.89
     /tmp/cciufS4Q.s:518    .text.matrix_scan:000000000000006c .Loc.90
     /tmp/cciufS4Q.s:527    .text.matrix_scan:0000000000000078 .Loc.91
     /tmp/cciufS4Q.s:537    .text.matrix_scan:0000000000000086 .Loc.92
     /tmp/cciufS4Q.s:543    .text.matrix_scan:0000000000000088 .Loc.93
     /tmp/cciufS4Q.s:544    .text.matrix_scan:0000000000000088 .Loc.94
     /tmp/cciufS4Q.s:547    .text.matrix_scan:000000000000008a .Loc.95
     /tmp/cciufS4Q.s:548    .text.matrix_scan:000000000000008a .Loc.96
     /tmp/cciufS4Q.s:560    .text.matrix_scan:00000000000000a0 .Loc.97
     /tmp/cciufS4Q.s:563    .text.matrix_scan:00000000000000a4 .Loc.98
     /tmp/cciufS4Q.s:571    .text.matrix_scan:00000000000000ae .Loc.99
     /tmp/cciufS4Q.s:573    .text.matrix_scan:00000000000000b0 .Loc.100
     /tmp/cciufS4Q.s:576    .text.matrix_scan:00000000000000b4 .Loc.101
     /tmp/cciufS4Q.s:577    .text.matrix_scan:00000000000000b4 .Loc.102
     /tmp/cciufS4Q.s:585    .text.matrix_scan:00000000000000c0 .Loc.103
     /tmp/cciufS4Q.s:586    .text.matrix_scan:00000000000000c0 .Loc.104
     /tmp/cciufS4Q.s:593    .text.matrix_scan:00000000000000c8 .Loc.105
     /tmp/cciufS4Q.s:595    .text.matrix_scan:00000000000000c8 .Loc.106
     /tmp/cciufS4Q.s:596    .text.matrix_scan:00000000000000c8 .Loc.107
     /tmp/cciufS4Q.s:601    .text.matrix_scan:00000000000000ce .Loc.108
     /tmp/cciufS4Q.s:605    .text.matrix_scan:00000000000000ce .Loc.109
     /tmp/cciufS4Q.s:607    .text.matrix_scan:00000000000000ce .Loc.110
     /tmp/cciufS4Q.s:608    .text.matrix_scan:00000000000000ce .Loc.111
     /tmp/cciufS4Q.s:610    .text.matrix_scan:00000000000000d0 .Loc.112
     /tmp/cciufS4Q.s:613    .text.matrix_scan:00000000000000d4 .Loc.113
     /tmp/cciufS4Q.s:615    .text.matrix_scan:00000000000000d6 .Loc.114
     /tmp/cciufS4Q.s:619    .text.matrix_scan:00000000000000da .Loc.115
     /tmp/cciufS4Q.s:622    .text.matrix_scan:00000000000000da .Loc.116
     /tmp/cciufS4Q.s:623    .text.matrix_scan:00000000000000da .Loc.117
     /tmp/cciufS4Q.s:626    .text.matrix_scan:00000000000000da .Loc.118
     /tmp/cciufS4Q.s:627    .text.matrix_scan:00000000000000da .Loc.119
     /tmp/cciufS4Q.s:631    .text.matrix_scan:00000000000000de .Loc.120
     /tmp/cciufS4Q.s:632    .text.matrix_scan:00000000000000de .Loc.121
     /tmp/cciufS4Q.s:940    .bss.debouncing:0000000000000000 debouncing
     /tmp/cciufS4Q.s:634    .text.matrix_scan:00000000000000e2 .Loc.122
     /tmp/cciufS4Q.s:635    .text.matrix_scan:00000000000000e2 .Loc.123
     /tmp/cciufS4Q.s:638    .text.matrix_scan:00000000000000e6 .Loc.124
     /tmp/cciufS4Q.s:945    .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/cciufS4Q.s:643    .text.matrix_scan:00000000000000ee .Loc.125
     /tmp/cciufS4Q.s:645    .text.matrix_scan:00000000000000ee .Loc.126
     /tmp/cciufS4Q.s:646    .text.matrix_scan:00000000000000ee .Loc.127
     /tmp/cciufS4Q.s:651    .text.matrix_scan:00000000000000f4 .Loc.128
     /tmp/cciufS4Q.s:655    .text.matrix_scan:00000000000000fc L0
     /tmp/cciufS4Q.s:658    .text.matrix_scan:00000000000000fe .Loc.129
     /tmp/cciufS4Q.s:659    .text.matrix_scan:00000000000000fe .Loc.130
     /tmp/cciufS4Q.s:663    .text.matrix_scan:0000000000000106 .Loc.131
     /tmp/cciufS4Q.s:668    .text.matrix_scan:0000000000000112 .Loc.132
     /tmp/cciufS4Q.s:672    .text.matrix_scan:0000000000000116 .Loc.133
     /tmp/cciufS4Q.s:684    .text.matrix_scan:0000000000000128 .Loc.134
     /tmp/cciufS4Q.s:685    .text.matrix_scan:0000000000000128 .Loc.135
     /tmp/cciufS4Q.s:688    .text.matrix_scan:000000000000012c .Loc.136
     /tmp/cciufS4Q.s:691    .text.matrix_scan:0000000000000130 .Loc.137
     /tmp/cciufS4Q.s:692    .text.matrix_scan:0000000000000130 .Loc.138
     /tmp/cciufS4Q.s:711    .text.matrix_scan:0000000000000150 .Loc.139
     /tmp/cciufS4Q.s:721    .text.matrix_scan:0000000000000152 .Loc.140
     /tmp/cciufS4Q.s:722    .text.matrix_scan:0000000000000152 .Loc.141
     /tmp/cciufS4Q.s:725    .text.matrix_scan:0000000000000154 .Loc.142
     /tmp/cciufS4Q.s:733    .text.matrix_scan:0000000000000156 L0
     /tmp/cciufS4Q.s:739    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/cciufS4Q.s:741    .text.matrix_is_modified:0000000000000000 .Loc.143
     /tmp/cciufS4Q.s:742    .text.matrix_is_modified:0000000000000000 L0
     /tmp/cciufS4Q.s:747    .text.matrix_is_modified:0000000000000000 .Loc.144
     /tmp/cciufS4Q.s:748    .text.matrix_is_modified:0000000000000000 .Loc.145
     /tmp/cciufS4Q.s:750    .text.matrix_is_modified:0000000000000004 .Loc.146
     /tmp/cciufS4Q.s:755    .text.matrix_is_modified:000000000000000a L0
     /tmp/cciufS4Q.s:761    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/cciufS4Q.s:764    .text.matrix_is_on:0000000000000000 .Loc.147
     /tmp/cciufS4Q.s:765    .text.matrix_is_on:0000000000000000 L0
     /tmp/cciufS4Q.s:770    .text.matrix_is_on:0000000000000000 .Loc.148
     /tmp/cciufS4Q.s:771    .text.matrix_is_on:0000000000000000 .Loc.149
     /tmp/cciufS4Q.s:778    .text.matrix_is_on:000000000000000a .Loc.150
     /tmp/cciufS4Q.s:780    .text.matrix_is_on:000000000000000c .Loc.151
     /tmp/cciufS4Q.s:788    .text.matrix_is_on:0000000000000018 .Loc.152
     /tmp/cciufS4Q.s:791    .text.matrix_is_on:000000000000001c .Loc.153
     /tmp/cciufS4Q.s:795    .text.matrix_is_on:0000000000000020 L0
     /tmp/cciufS4Q.s:801    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/cciufS4Q.s:804    .text.matrix_get_row:0000000000000000 .Loc.154
     /tmp/cciufS4Q.s:805    .text.matrix_get_row:0000000000000000 L0
     /tmp/cciufS4Q.s:810    .text.matrix_get_row:0000000000000000 .Loc.155
     /tmp/cciufS4Q.s:811    .text.matrix_get_row:0000000000000000 .Loc.156
     /tmp/cciufS4Q.s:816    .text.matrix_get_row:0000000000000008 .Loc.157
     /tmp/cciufS4Q.s:820    .text.matrix_get_row:000000000000000a .Loc.158
     /tmp/cciufS4Q.s:822    .text.matrix_get_row:000000000000000c L0
     /tmp/cciufS4Q.s:828    .text.matrix_print:0000000000000000 matrix_print
     /tmp/cciufS4Q.s:830    .text.matrix_print:0000000000000000 .Loc.159
     /tmp/cciufS4Q.s:831    .text.matrix_print:0000000000000000 L0
     /tmp/cciufS4Q.s:836    .text.matrix_print:0000000000000000 .Loc.160
     /tmp/cciufS4Q.s:837    .text.matrix_print:0000000000000000 .Loc.161
     /tmp/cciufS4Q.s:838    .text.matrix_print:0000000000000000 .Loc.162
     /tmp/cciufS4Q.s:839    .text.matrix_print:0000000000000000 .Loc.163
     /tmp/cciufS4Q.s:841    .text.matrix_print:0000000000000000 .Loc.164
     /tmp/cciufS4Q.s:843    .text.matrix_print:0000000000000002 L0
     /tmp/cciufS4Q.s:849    .text.matrix_key_count:0000000000000000 matrix_key_count
     /tmp/cciufS4Q.s:851    .text.matrix_key_count:0000000000000000 .Loc.165
     /tmp/cciufS4Q.s:852    .text.matrix_key_count:0000000000000000 L0
     /tmp/cciufS4Q.s:869    .text.matrix_key_count:0000000000000006 .Loc.166
     /tmp/cciufS4Q.s:871    .text.matrix_key_count:0000000000000006 .Loc.167
     /tmp/cciufS4Q.s:873    .text.matrix_key_count:0000000000000006 .Loc.168
     /tmp/cciufS4Q.s:874    .text.matrix_key_count:0000000000000006 .Loc.169
     /tmp/cciufS4Q.s:878    .text.matrix_key_count:000000000000000a .Loc.170
     /tmp/cciufS4Q.s:883    .text.matrix_key_count:000000000000000c .Loc.171
     /tmp/cciufS4Q.s:884    .text.matrix_key_count:000000000000000c .Loc.172
     /tmp/cciufS4Q.s:889    .text.matrix_key_count:0000000000000012 .Loc.173
     /tmp/cciufS4Q.s:892    .text.matrix_key_count:0000000000000016 .Loc.174
     /tmp/cciufS4Q.s:895    .text.matrix_key_count:0000000000000018 .Loc.175
     /tmp/cciufS4Q.s:896    .text.matrix_key_count:0000000000000018 .Loc.176
     /tmp/cciufS4Q.s:902    .text.matrix_key_count:0000000000000020 .Loc.177
     /tmp/cciufS4Q.s:903    .text.matrix_key_count:0000000000000020 .Loc.178
     /tmp/cciufS4Q.s:908    .text.matrix_key_count:0000000000000024 .Loc.179
     /tmp/cciufS4Q.s:912    .text.matrix_key_count:0000000000000028 .Loc.180
     /tmp/cciufS4Q.s:914    .text.matrix_key_count:000000000000002a L0
     /tmp/cciufS4Q.s:29     .text.matrix_init_user:0000000000000002 L0
     /tmp/cciufS4Q.s:46     .text.matrix_init_kb:0000000000000004 L0
     /tmp/cciufS4Q.s:63     .text.matrix_init_quantum:0000000000000004 L0
     /tmp/cciufS4Q.s:79     .text.matrix_scan_user:0000000000000002 L0
     /tmp/cciufS4Q.s:96     .text.matrix_scan_kb:0000000000000004 L0
     /tmp/cciufS4Q.s:113    .text.matrix_scan_quantum:0000000000000004 L0
     /tmp/cciufS4Q.s:132    .text.matrix_rows:0000000000000004 L0
     /tmp/cciufS4Q.s:151    .text.matrix_cols:0000000000000004 L0
     /tmp/cciufS4Q.s:334    .text.matrix_init:00000000000000ac L0
     /tmp/cciufS4Q.s:736    .text.matrix_scan:0000000000000156 L0
     /tmp/cciufS4Q.s:758    .text.matrix_is_modified:000000000000000a L0
     /tmp/cciufS4Q.s:798    .text.matrix_is_on:0000000000000020 L0
     /tmp/cciufS4Q.s:825    .text.matrix_get_row:000000000000000c L0
     /tmp/cciufS4Q.s:846    .text.matrix_print:0000000000000002 L0
     /tmp/cciufS4Q.s:917    .text.matrix_key_count:000000000000002a L0
                     .debug_frame:0000000000000000 L0
     /tmp/cciufS4Q.s:218    .text.matrix_init:0000000000000032 .L21
     /tmp/cciufS4Q.s:215    .text.matrix_init:000000000000002e .L11
     /tmp/cciufS4Q.s:198    .text.matrix_init:000000000000001c .L10
     /tmp/cciufS4Q.s:275    .text.matrix_init:000000000000006e .L22
     /tmp/cciufS4Q.s:272    .text.matrix_init:000000000000006a .L12
     /tmp/cciufS4Q.s:255    .text.matrix_init:0000000000000058 .L11
     /tmp/cciufS4Q.s:308    .text.matrix_init:0000000000000092 .L1
     /tmp/cciufS4Q.s:316    .text.matrix_init:000000000000009e .L2
     /tmp/cciufS4Q.s:475    .text.matrix_scan:0000000000000052 .L23
     /tmp/cciufS4Q.s:472    .text.matrix_scan:000000000000004e .L13
     /tmp/cciufS4Q.s:507    .text.matrix_scan:0000000000000068 .L14
     /tmp/cciufS4Q.s:524    .text.matrix_scan:0000000000000074 .L24
     /tmp/cciufS4Q.s:522    .text.matrix_scan:0000000000000072 .L15
     /tmp/cciufS4Q.s:568    .text.matrix_scan:00000000000000aa .L25
     /tmp/cciufS4Q.s:565    .text.matrix_scan:00000000000000a6 .L16
     /tmp/cciufS4Q.s:714    .text.matrix_scan:0000000000000152 .L15
     /tmp/cciufS4Q.s:592    .text.matrix_scan:00000000000000c8 .L17
     /tmp/cciufS4Q.s:540    .text.matrix_scan:0000000000000088 .L18
     /tmp/cciufS4Q.s:642    .text.matrix_scan:00000000000000ee .L19
     /tmp/cciufS4Q.s:437    .text.matrix_scan:0000000000000038 .L20
     /tmp/cciufS4Q.s:687    .text.matrix_scan:000000000000012c .L22
     /tmp/cciufS4Q.s:678    .text.matrix_scan:0000000000000120 .L3
     /tmp/cciufS4Q.s:579    .text.matrix_scan:00000000000000b6 .L16
     /tmp/cciufS4Q.s:787    .text.matrix_is_on:0000000000000018 .L32
     /tmp/cciufS4Q.s:881    .text.matrix_key_count:000000000000000c .L36
     /tmp/cciufS4Q.s:1880   .debug_abbrev:0000000000000000 .Ldebug_abbrev0
     /tmp/cciufS4Q.s:3518   .debug_ranges:0000000000000000 .Ldebug_ranges0
     /tmp/cciufS4Q.s:3606   .debug_line:0000000000000000 .Ldebug_line0
     /tmp/cciufS4Q.s:850    .text.matrix_key_count:0000000000000000 .LFB24
     /tmp/cciufS4Q.s:915    .text.matrix_key_count:000000000000002a .LFE24
     /tmp/cciufS4Q.s:2857   .debug_loc:0000000000000000 .LLST20
     /tmp/cciufS4Q.s:2891   .debug_loc:0000000000000042 .LLST21
     /tmp/cciufS4Q.s:2884   .debug_loc:000000000000003c .LVUS21
     /tmp/cciufS4Q.s:2916   .debug_loc:0000000000000074 .LLST22
     /tmp/cciufS4Q.s:2907   .debug_loc:000000000000006c .LVUS22
     /tmp/cciufS4Q.s:891    .text.matrix_key_count:0000000000000016 .LVL47
     /tmp/cciufS4Q.s:829    .text.matrix_print:0000000000000000 .LFB23
     /tmp/cciufS4Q.s:844    .text.matrix_print:0000000000000002 .LFE23
     /tmp/cciufS4Q.s:803    .text.matrix_get_row:0000000000000000 .LFB22
     /tmp/cciufS4Q.s:823    .text.matrix_get_row:000000000000000c .LFE22
     /tmp/cciufS4Q.s:2958   .debug_loc:00000000000000c7 .LLST19
     /tmp/cciufS4Q.s:2953   .debug_loc:00000000000000c3 .LVUS19
     /tmp/cciufS4Q.s:763    .text.matrix_is_on:0000000000000000 .LFB21
     /tmp/cciufS4Q.s:796    .text.matrix_is_on:0000000000000020 .LFE21
     /tmp/cciufS4Q.s:2977   .debug_loc:00000000000000ec .LLST18
     /tmp/cciufS4Q.s:2972   .debug_loc:00000000000000e8 .LVUS18
     /tmp/cciufS4Q.s:740    .text.matrix_is_modified:0000000000000000 .LFB20
     /tmp/cciufS4Q.s:756    .text.matrix_is_modified:000000000000000a .LFE20
     /tmp/cciufS4Q.s:338    .text.matrix_scan:0000000000000000 .LFB19
     /tmp/cciufS4Q.s:734    .text.matrix_scan:0000000000000156 .LFE19
     /tmp/cciufS4Q.s:2991   .debug_loc:000000000000010d .LLST5
     /tmp/cciufS4Q.s:3101   .debug_loc:00000000000001ef .LLST6
     /tmp/cciufS4Q.s:3090   .debug_loc:00000000000001e5 .LVUS6
     /tmp/cciufS4Q.s:3132   .debug_loc:0000000000000235 .LLST7
     /tmp/cciufS4Q.s:3127   .debug_loc:0000000000000231 .LVUS7
     /tmp/cciufS4Q.s:445    .text.matrix_scan:0000000000000038 .LBI47
     /tmp/cciufS4Q.s:3149   .debug_loc:0000000000000258 .LLST8
     /tmp/cciufS4Q.s:3144   .debug_loc:0000000000000254 .LVUS8
     /tmp/cciufS4Q.s:3167   .debug_loc:000000000000027c .LLST9
     /tmp/cciufS4Q.s:3160   .debug_loc:0000000000000276 .LVUS9
     /tmp/cciufS4Q.s:451    .text.matrix_scan:0000000000000038 .LBI49
     /tmp/cciufS4Q.s:3186   .debug_loc:00000000000002a8 .LLST10
     /tmp/cciufS4Q.s:3183   .debug_loc:00000000000002a6 .LVUS10
     /tmp/cciufS4Q.s:3198   .debug_loc:00000000000002bf .LLST11
     /tmp/cciufS4Q.s:3193   .debug_loc:00000000000002bb .LVUS11
     /tmp/cciufS4Q.s:3221   .debug_loc:00000000000002e8 .LLST12
     /tmp/cciufS4Q.s:3210   .debug_loc:00000000000002de .LVUS12
     /tmp/cciufS4Q.s:3276   .debug_loc:0000000000000352 .LLST13
     /tmp/cciufS4Q.s:3269   .debug_loc:000000000000034c .LVUS13
     /tmp/cciufS4Q.s:496    .text.matrix_scan:0000000000000066 .LBI58
     /tmp/cciufS4Q.s:495    .text.matrix_scan:0000000000000066 .LBB58
     /tmp/cciufS4Q.s:512    .text.matrix_scan:000000000000006c .LBE58
     /tmp/cciufS4Q.s:3294   .debug_loc:000000000000037d .LLST14
     /tmp/cciufS4Q.s:3291   .debug_loc:000000000000037b .LVUS14
     /tmp/cciufS4Q.s:3306   .debug_loc:0000000000000397 .LLST15
     /tmp/cciufS4Q.s:3303   .debug_loc:0000000000000395 .LVUS15
     /tmp/cciufS4Q.s:3318   .debug_loc:00000000000003b1 .LLST16
     /tmp/cciufS4Q.s:3315   .debug_loc:00000000000003af .LVUS16
     /tmp/cciufS4Q.s:604    .text.matrix_scan:00000000000000ce .LBI62
     /tmp/cciufS4Q.s:603    .text.matrix_scan:00000000000000ce .LBB62
     /tmp/cciufS4Q.s:621    .text.matrix_scan:00000000000000da .LBE62
     /tmp/cciufS4Q.s:3330   .debug_loc:00000000000003c9 .LLST17
     /tmp/cciufS4Q.s:3327   .debug_loc:00000000000003c7 .LVUS17
     /tmp/cciufS4Q.s:637    .text.matrix_scan:00000000000000e6 .LVL32
     /tmp/cciufS4Q.s:671    .text.matrix_scan:0000000000000116 .LBB71
     /tmp/cciufS4Q.s:683    .text.matrix_scan:0000000000000128 .LBE71
     /tmp/cciufS4Q.s:667    .text.matrix_scan:0000000000000112 .LVL35
     /tmp/cciufS4Q.s:690    .text.matrix_scan:0000000000000130 .LVL36
     /tmp/cciufS4Q.s:155    .text.matrix_init:0000000000000000 .LFB18
     /tmp/cciufS4Q.s:332    .text.matrix_init:00000000000000ac .LFE18
     /tmp/cciufS4Q.s:3337   .debug_loc:00000000000003dc .LLST0
     /tmp/cciufS4Q.s:299    .text.matrix_init:0000000000000088 .LBB27
     /tmp/cciufS4Q.s:322    .text.matrix_init:00000000000000a4 .LBE27
     /tmp/cciufS4Q.s:182    .text.matrix_init:0000000000000010 .LBI21
     /tmp/cciufS4Q.s:181    .text.matrix_init:0000000000000010 .LBB21
     /tmp/cciufS4Q.s:247    .text.matrix_init:0000000000000054 .LBE21
     /tmp/cciufS4Q.s:185    .text.matrix_init:0000000000000010 .LBB22
     /tmp/cciufS4Q.s:246    .text.matrix_init:0000000000000054 .LBE22
     /tmp/cciufS4Q.s:3367   .debug_loc:0000000000000413 .LLST1
     /tmp/cciufS4Q.s:3358   .debug_loc:000000000000040b .LVUS1
     /tmp/cciufS4Q.s:193    .text.matrix_init:0000000000000018 .LBB23
     /tmp/cciufS4Q.s:233    .text.matrix_init:0000000000000046 .LBE23
     /tmp/cciufS4Q.s:3409   .debug_loc:0000000000000466 .LLST2
     /tmp/cciufS4Q.s:3404   .debug_loc:0000000000000462 .LVUS2
     /tmp/cciufS4Q.s:248    .text.matrix_init:0000000000000054 .LBB24
     /tmp/cciufS4Q.s:298    .text.matrix_init:0000000000000088 .LBE24
     /tmp/cciufS4Q.s:249    .text.matrix_init:0000000000000054 .LBB25
     /tmp/cciufS4Q.s:297    .text.matrix_init:0000000000000088 .LBE25
     /tmp/cciufS4Q.s:3428   .debug_loc:000000000000048b .LLST3
     /tmp/cciufS4Q.s:3421   .debug_loc:0000000000000485 .LVUS3
     /tmp/cciufS4Q.s:250    .text.matrix_init:0000000000000054 .LBB26
     /tmp/cciufS4Q.s:290    .text.matrix_init:0000000000000082 .LBE26
     /tmp/cciufS4Q.s:3465   .debug_loc:00000000000004d2 .LLST4
     /tmp/cciufS4Q.s:3460   .debug_loc:00000000000004ce .LVUS4
     /tmp/cciufS4Q.s:330    .text.matrix_init:00000000000000ac .LVL18
     /tmp/cciufS4Q.s:136    .text.matrix_cols:0000000000000000 .LFB17
     /tmp/cciufS4Q.s:149    .text.matrix_cols:0000000000000004 .LFE17
     /tmp/cciufS4Q.s:117    .text.matrix_rows:0000000000000000 .LFB16
     /tmp/cciufS4Q.s:130    .text.matrix_rows:0000000000000004 .LFE16
     /tmp/cciufS4Q.s:15     .text.matrix_init_user:0000000000000000 .LFB14
     /tmp/cciufS4Q.s:26     .text.matrix_init_user:0000000000000002 .LFE14
     /tmp/cciufS4Q.s:83     .text.matrix_scan_kb:0000000000000000 .LFB13
     /tmp/cciufS4Q.s:94     .text.matrix_scan_kb:0000000000000004 .LFE13
     /tmp/cciufS4Q.s:92     .text.matrix_scan_kb:0000000000000004 .LVL2
     /tmp/cciufS4Q.s:33     .text.matrix_init_kb:0000000000000000 .LFB12
     /tmp/cciufS4Q.s:44     .text.matrix_init_kb:0000000000000004 .LFE12
     /tmp/cciufS4Q.s:42     .text.matrix_init_kb:0000000000000004 .LVL0
     /tmp/cciufS4Q.s:100    .text.matrix_scan_quantum:0000000000000000 .LFB11
     /tmp/cciufS4Q.s:111    .text.matrix_scan_quantum:0000000000000004 .LFE11
     /tmp/cciufS4Q.s:109    .text.matrix_scan_quantum:0000000000000004 .LVL3
     /tmp/cciufS4Q.s:50     .text.matrix_init_quantum:0000000000000000 .LFB10
     /tmp/cciufS4Q.s:61     .text.matrix_init_quantum:0000000000000004 .LFE10
     /tmp/cciufS4Q.s:59     .text.matrix_init_quantum:0000000000000004 .LVL1
     /tmp/cciufS4Q.s:854    .text.matrix_key_count:0000000000000002 .LCFI17
     /tmp/cciufS4Q.s:858    .text.matrix_key_count:0000000000000004 .LCFI18
     /tmp/cciufS4Q.s:862    .text.matrix_key_count:0000000000000006 .LCFI19
     /tmp/cciufS4Q.s:870    .text.matrix_key_count:0000000000000006 .LVL44
     /tmp/cciufS4Q.s:880    .text.matrix_key_count:000000000000000c .LVL45
     /tmp/cciufS4Q.s:907    .text.matrix_key_count:0000000000000024 .LVL49
     /tmp/cciufS4Q.s:888    .text.matrix_key_count:0000000000000012 .LVL46
     /tmp/cciufS4Q.s:894    .text.matrix_key_count:0000000000000018 .LVL48
     /tmp/cciufS4Q.s:911    .text.matrix_key_count:0000000000000028 .LVL50
     /tmp/cciufS4Q.s:802    .text.matrix_get_row:0000000000000000 .LVL42
     /tmp/cciufS4Q.s:818    .text.matrix_get_row:000000000000000a .LVL43
     /tmp/cciufS4Q.s:762    .text.matrix_is_on:0000000000000000 .LVL40
     /tmp/cciufS4Q.s:777    .text.matrix_is_on:000000000000000a .LVL41
     /tmp/cciufS4Q.s:342    .text.matrix_scan:0000000000000002 .LCFI2
     /tmp/cciufS4Q.s:346    .text.matrix_scan:0000000000000004 .LCFI3
     /tmp/cciufS4Q.s:350    .text.matrix_scan:0000000000000006 .LCFI4
     /tmp/cciufS4Q.s:354    .text.matrix_scan:0000000000000008 .LCFI5
     /tmp/cciufS4Q.s:358    .text.matrix_scan:000000000000000a .LCFI6
     /tmp/cciufS4Q.s:362    .text.matrix_scan:000000000000000c .LCFI7
     /tmp/cciufS4Q.s:366    .text.matrix_scan:000000000000000e .LCFI8
     /tmp/cciufS4Q.s:370    .text.matrix_scan:0000000000000010 .LCFI9
     /tmp/cciufS4Q.s:374    .text.matrix_scan:0000000000000012 .LCFI10
     /tmp/cciufS4Q.s:378    .text.matrix_scan:0000000000000014 .LCFI11
     /tmp/cciufS4Q.s:382    .text.matrix_scan:0000000000000016 .LCFI12
     /tmp/cciufS4Q.s:386    .text.matrix_scan:0000000000000018 .LCFI13
     /tmp/cciufS4Q.s:390    .text.matrix_scan:000000000000001a .LCFI14
     /tmp/cciufS4Q.s:394    .text.matrix_scan:000000000000001c .LCFI15
     /tmp/cciufS4Q.s:398    .text.matrix_scan:000000000000001e .LCFI16
     /tmp/cciufS4Q.s:408    .text.matrix_scan:000000000000001e .LVL19
     /tmp/cciufS4Q.s:436    .text.matrix_scan:0000000000000038 .LVL20
     /tmp/cciufS4Q.s:641    .text.matrix_scan:00000000000000ee .LVL33
     /tmp/cciufS4Q.s:650    .text.matrix_scan:00000000000000f4 .LVL34
     /tmp/cciufS4Q.s:710    .text.matrix_scan:0000000000000150 .LVL37
     /tmp/cciufS4Q.s:713    .text.matrix_scan:0000000000000152 .LVL38
     /tmp/cciufS4Q.s:618    .text.matrix_scan:00000000000000da .LVL30
     /tmp/cciufS4Q.s:630    .text.matrix_scan:00000000000000de .LVL31
     /tmp/cciufS4Q.s:539    .text.matrix_scan:0000000000000088 .LVL26
     /tmp/cciufS4Q.s:490    .text.matrix_scan:0000000000000066 .LVL24
     /tmp/cciufS4Q.s:459    .text.matrix_scan:000000000000003e .LVL21
     /tmp/cciufS4Q.s:468    .text.matrix_scan:000000000000004a .LVL22
     /tmp/cciufS4Q.s:482    .text.matrix_scan:000000000000005c .LVL23
     /tmp/cciufS4Q.s:509    .text.matrix_scan:000000000000006c .LVL25
     /tmp/cciufS4Q.s:546    .text.matrix_scan:000000000000008a .LVL27
     /tmp/cciufS4Q.s:591    .text.matrix_scan:00000000000000c8 .LVL28
     /tmp/cciufS4Q.s:724    .text.matrix_scan:0000000000000154 .LVL39
     /tmp/cciufS4Q.s:602    .text.matrix_scan:00000000000000ce .LVL29
     /tmp/cciufS4Q.s:159    .text.matrix_init:0000000000000002 .LCFI0
     /tmp/cciufS4Q.s:163    .text.matrix_init:0000000000000004 .LCFI1
     /tmp/cciufS4Q.s:187    .text.matrix_init:0000000000000010 .LVL4
     /tmp/cciufS4Q.s:197    .text.matrix_init:000000000000001c .LVL5
     /tmp/cciufS4Q.s:202    .text.matrix_init:000000000000001e .LVL6
     /tmp/cciufS4Q.s:235    .text.matrix_init:0000000000000046 .LVL9
     /tmp/cciufS4Q.s:242    .text.matrix_init:0000000000000050 .LVL10
     /tmp/cciufS4Q.s:211    .text.matrix_init:000000000000002a .LVL7
     /tmp/cciufS4Q.s:227    .text.matrix_init:0000000000000040 .LVL8
     /tmp/cciufS4Q.s:254    .text.matrix_init:0000000000000058 .LVL11
     /tmp/cciufS4Q.s:259    .text.matrix_init:000000000000005a .LVL12
     /tmp/cciufS4Q.s:292    .text.matrix_init:0000000000000082 .LVL15
     /tmp/cciufS4Q.s:305    .text.matrix_init:0000000000000090 .LVL16
     /tmp/cciufS4Q.s:268    .text.matrix_init:0000000000000066 .LVL13
     /tmp/cciufS4Q.s:284    .text.matrix_init:000000000000007c .LVL14
     /tmp/cciufS4Q.s:955    .debug_info:0000000000000000 .Ldebug_info0
     /tmp/cciufS4Q.s:67     .text.matrix_scan_user:0000000000000000 .LFB31
     /tmp/cciufS4Q.s:77     .text.matrix_scan_user:0000000000000002 .LFE31
     /tmp/cciufS4Q.s:406    .text.matrix_scan:000000000000001e .LBB45
     /tmp/cciufS4Q.s:412    .text.matrix_scan:0000000000000022 .LBE45
     /tmp/cciufS4Q.s:416    .text.matrix_scan:0000000000000026 .LBB70
     /tmp/cciufS4Q.s:657    .text.matrix_scan:00000000000000fe .LBE70
     /tmp/cciufS4Q.s:715    .text.matrix_scan:0000000000000152 .LBB72
     /tmp/cciufS4Q.s:732    .text.matrix_scan:0000000000000156 .LBE72
     /tmp/cciufS4Q.s:417    .text.matrix_scan:0000000000000026 .LBB46
     /tmp/cciufS4Q.s:644    .text.matrix_scan:00000000000000ee .LBE46
     /tmp/cciufS4Q.s:716    .text.matrix_scan:0000000000000152 .LBB69
     /tmp/cciufS4Q.s:731    .text.matrix_scan:0000000000000156 .LBE69
     /tmp/cciufS4Q.s:418    .text.matrix_scan:0000000000000026 .LBB47
     /tmp/cciufS4Q.s:442    .text.matrix_scan:0000000000000038 .LBE47
     /tmp/cciufS4Q.s:444    .text.matrix_scan:0000000000000038 .LBB67
     /tmp/cciufS4Q.s:625    .text.matrix_scan:00000000000000da .LBE67
     /tmp/cciufS4Q.s:717    .text.matrix_scan:0000000000000152 .LBB68
     /tmp/cciufS4Q.s:730    .text.matrix_scan:0000000000000156 .LBE68
     /tmp/cciufS4Q.s:420    .text.matrix_scan:0000000000000026 .LBB49
     /tmp/cciufS4Q.s:431    .text.matrix_scan:0000000000000034 .LBE49
     /tmp/cciufS4Q.s:450    .text.matrix_scan:0000000000000038 .LBB57
     /tmp/cciufS4Q.s:493    .text.matrix_scan:0000000000000066 .LBE57
     /tmp/cciufS4Q.s:432    .text.matrix_scan:0000000000000034 .LBB52
     /tmp/cciufS4Q.s:440    .text.matrix_scan:0000000000000038 .LBE52
     /tmp/cciufS4Q.s:514    .text.matrix_scan:000000000000006c .LBB60
     /tmp/cciufS4Q.s:536    .text.matrix_scan:0000000000000086 .LBE60
     /tmp/cciufS4Q.s:541    .text.matrix_scan:0000000000000088 .LBB61
     /tmp/cciufS4Q.s:600    .text.matrix_scan:00000000000000ce .LBE61
     /tmp/cciufS4Q.s:719    .text.matrix_scan:0000000000000152 .LBB64
     /tmp/cciufS4Q.s:728    .text.matrix_scan:0000000000000156 .LBE64
     /tmp/cciufS4Q.s:433    .text.matrix_scan:0000000000000034 .LBB53
     /tmp/cciufS4Q.s:439    .text.matrix_scan:0000000000000038 .LBE53
     /tmp/cciufS4Q.s:517    .text.matrix_scan:000000000000006c .LBB54
     /tmp/cciufS4Q.s:535    .text.matrix_scan:0000000000000086 .LBE54
     /tmp/cciufS4Q.s:542    .text.matrix_scan:0000000000000088 .LBB55
     /tmp/cciufS4Q.s:594    .text.matrix_scan:00000000000000c8 .LBE55
     /tmp/cciufS4Q.s:720    .text.matrix_scan:0000000000000152 .LBB56
     /tmp/cciufS4Q.s:727    .text.matrix_scan:0000000000000156 .LBE56
     /tmp/cciufS4Q.s:872    .text.matrix_key_count:0000000000000006 .LBB73
     /tmp/cciufS4Q.s:877    .text.matrix_key_count:000000000000000a .LBE73
     /tmp/cciufS4Q.s:882    .text.matrix_key_count:000000000000000c .LBB74
     /tmp/cciufS4Q.s:901    .text.matrix_key_count:0000000000000020 .LBE74

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop
__do_copy_data
__do_clear_bss
