   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.file 1 "quantum/matrix.c"
  12               		.section	.text.matrix_init_user,"ax",@progbits
  13               		.weak	matrix_init_user
  15               	matrix_init_user:
  16               	.LFB14:
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012 Jun Wako
   3:quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:quantum/matrix.c **** 
   5:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:quantum/matrix.c **** (at your option) any later version.
   9:quantum/matrix.c **** 
  10:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:quantum/matrix.c **** GNU General Public License for more details.
  14:quantum/matrix.c **** 
  15:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:quantum/matrix.c **** */
  18:quantum/matrix.c **** #include <stdint.h>
  19:quantum/matrix.c **** #include <stdbool.h>
  20:quantum/matrix.c **** #if defined(__AVR__)
  21:quantum/matrix.c **** #include <avr/io.h>
  22:quantum/matrix.c **** #endif
  23:quantum/matrix.c **** #include "wait.h"
  24:quantum/matrix.c **** #include "print.h"
  25:quantum/matrix.c **** #include "debug.h"
  26:quantum/matrix.c **** #include "util.h"
  27:quantum/matrix.c **** #include "matrix.h"
  28:quantum/matrix.c **** #include "timer.h"
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  34:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  35:quantum/matrix.c **** #endif
  36:quantum/matrix.c **** 
  37:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  38:quantum/matrix.c ****     static uint16_t debouncing_time;
  39:quantum/matrix.c ****     static bool debouncing = false;
  40:quantum/matrix.c **** #endif
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  43:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  44:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  45:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  46:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  47:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  48:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  49:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  50:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  51:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  52:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  53:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  54:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  55:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  56:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  57:quantum/matrix.c **** #endif
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** #ifdef MATRIX_MASKED
  60:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  61:quantum/matrix.c **** #endif
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** 
  66:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  67:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** static matrix_row_t matrix_raw[MATRIX_ROWS];
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #else // ROW2COL
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  17               		.loc 1 108 29 view -0
  18               		.cfi_startproc
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 109:quantum/matrix.c **** }
  23               		.loc 1 109 1 view .LVU1
  24               	/* epilogue start */
  25 0000 0895      		ret
  26               		.cfi_endproc
  27               	.LFE14:
  29               		.set	matrix_init_user.localalias,matrix_init_user
  30               		.section	.text.matrix_init_kb,"ax",@progbits
  31               		.weak	matrix_init_kb
  33               	matrix_init_kb:
  34               	.LFB12:
  98:quantum/matrix.c ****     matrix_init_user();
  35               		.loc 1 98 27 view -0
  36               		.cfi_startproc
  37               	/* prologue: function */
  38               	/* frame size = 0 */
  39               	/* stack size = 0 */
  40               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  41               		.loc 1 99 5 view .LVU3
  42 0000 0C94 0000 		jmp matrix_init_user
  43               	.LVL0:
  44               		.cfi_endproc
  45               	.LFE12:
  47               		.section	.text.matrix_init_quantum,"ax",@progbits
  48               		.weak	matrix_init_quantum
  50               	matrix_init_quantum:
  51               	.LFB10:
  88:quantum/matrix.c ****     matrix_init_kb();
  52               		.loc 1 88 32 view -0
  53               		.cfi_startproc
  54               	/* prologue: function */
  55               	/* frame size = 0 */
  56               	/* stack size = 0 */
  57               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  58               		.loc 1 89 5 view .LVU5
  59 0000 0C94 0000 		jmp matrix_init_kb
  60               	.LVL1:
  61               		.cfi_endproc
  62               	.LFE10:
  64               		.section	.text.matrix_scan_user,"ax",@progbits
  65               		.weak	matrix_scan_user
  67               	matrix_scan_user:
  68               	.LFB31:
  69               		.cfi_startproc
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
  70               		.loc 1 112 6 view -0
  71               	/* prologue: function */
  72               	/* frame size = 0 */
  73               	/* stack size = 0 */
  74               	.L__stack_usage = 0
  75               	/* epilogue start */
  76 0000 0895      		ret
  77               		.cfi_endproc
  78               	.LFE31:
  80               		.section	.text.matrix_scan_kb,"ax",@progbits
  81               		.weak	matrix_scan_kb
  83               	matrix_scan_kb:
  84               	.LFB13:
 103:quantum/matrix.c ****     matrix_scan_user();
  85               		.loc 1 103 27 view -0
  86               		.cfi_startproc
  87               	/* prologue: function */
  88               	/* frame size = 0 */
  89               	/* stack size = 0 */
  90               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  91               		.loc 1 104 5 view .LVU8
  92 0000 0C94 0000 		jmp matrix_scan_user
  93               	.LVL2:
  94               		.cfi_endproc
  95               	.LFE13:
  97               		.section	.text.matrix_scan_quantum,"ax",@progbits
  98               		.weak	matrix_scan_quantum
 100               	matrix_scan_quantum:
 101               	.LFB11:
  93:quantum/matrix.c ****     matrix_scan_kb();
 102               		.loc 1 93 32 view -0
 103               		.cfi_startproc
 104               	/* prologue: function */
 105               	/* frame size = 0 */
 106               	/* stack size = 0 */
 107               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 108               		.loc 1 94 5 view .LVU10
 109 0000 0C94 0000 		jmp matrix_scan_kb
 110               	.LVL3:
 111               		.cfi_endproc
 112               	.LFE11:
 114               		.section	.text.matrix_rows,"ax",@progbits
 115               	.global	matrix_rows
 117               	matrix_rows:
 118               	.LFB16:
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 119               		.loc 1 116 27 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 125               		.loc 1 117 5 view .LVU12
 118:quantum/matrix.c **** }
 126               		.loc 1 118 1 is_stmt 0 view .LVU13
 127 0000 88E0      		ldi r24,lo8(8)
 128               	/* epilogue start */
 129 0002 0895      		ret
 130               		.cfi_endproc
 131               	.LFE16:
 133               		.section	.text.matrix_cols,"ax",@progbits
 134               	.global	matrix_cols
 136               	matrix_cols:
 137               	.LFB17:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 138               		.loc 1 121 27 is_stmt 1 view -0
 139               		.cfi_startproc
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 144               		.loc 1 122 5 view .LVU15
 123:quantum/matrix.c **** }
 145               		.loc 1 123 1 is_stmt 0 view .LVU16
 146 0000 80E1      		ldi r24,lo8(16)
 147               	/* epilogue start */
 148 0002 0895      		ret
 149               		.cfi_endproc
 150               	.LFE17:
 152               		.section	.text.matrix_init,"ax",@progbits
 153               	.global	matrix_init
 155               	matrix_init:
 156               	.LFB18:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #else
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 157               		.loc 1 149 24 is_stmt 1 view -0
 158               		.cfi_startproc
 159 0000 CF93      		push r28
 160               	.LCFI0:
 161               		.cfi_def_cfa_offset 3
 162               		.cfi_offset 28, -2
 163 0002 DF93      		push r29
 164               	.LCFI1:
 165               		.cfi_def_cfa_offset 4
 166               		.cfi_offset 29, -3
 167               	/* prologue: function */
 168               	/* frame size = 0 */
 169               	/* stack size = 2 */
 170               	.L__stack_usage = 2
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 171               		.loc 1 153 9 view .LVU18
 172 0004 85B7      		in r24,0x35
 173               		.loc 1 153 15 is_stmt 0 view .LVU19
 174 0006 8068      		ori r24,lo8(-128)
 175 0008 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 176               		.loc 1 154 9 is_stmt 1 view .LVU20
 177 000a 85B7      		in r24,0x35
 178               		.loc 1 154 15 is_stmt 0 view .LVU21
 179 000c 8068      		ori r24,lo8(-128)
 180 000e 85BF      		out 0x35,r24
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 181               		.loc 1 159 5 is_stmt 1 view .LVU22
 182               	.LBB21:
 183               	.LBI21:
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #else // ROW2COL
 162:quantum/matrix.c ****     unselect_cols();
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_raw[i] = 0;
 170:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 171:quantum/matrix.c ****     }
 172:quantum/matrix.c **** 
 173:quantum/matrix.c ****     matrix_init_quantum();
 174:quantum/matrix.c **** }
 175:quantum/matrix.c **** 
 176:quantum/matrix.c **** uint8_t matrix_scan(void)
 177:quantum/matrix.c **** {
 178:quantum/matrix.c **** 
 179:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Set row, read cols
 182:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 183:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 184:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 185:quantum/matrix.c **** 
 186:quantum/matrix.c ****             if (matrix_changed) {
 187:quantum/matrix.c ****                 debouncing = true;
 188:quantum/matrix.c ****                 debouncing_time = timer_read();
 189:quantum/matrix.c ****             }
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** #       else
 192:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 193:quantum/matrix.c **** #       endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     }
 196:quantum/matrix.c **** 
 197:quantum/matrix.c **** #else // ROW2COL
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // Set col, read rows
 200:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 201:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 202:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 203:quantum/matrix.c ****             if (matrix_changed) {
 204:quantum/matrix.c ****                 debouncing = true;
 205:quantum/matrix.c ****                 debouncing_time = timer_read();
 206:quantum/matrix.c ****             }
 207:quantum/matrix.c **** #       else
 208:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 209:quantum/matrix.c **** #       endif
 210:quantum/matrix.c **** 
 211:quantum/matrix.c ****     }
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #endif
 214:quantum/matrix.c **** 
 215:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 216:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 217:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 218:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 219:quantum/matrix.c ****             }
 220:quantum/matrix.c ****             debouncing = false;
 221:quantum/matrix.c ****         }
 222:quantum/matrix.c **** #   endif
 223:quantum/matrix.c **** 
 224:quantum/matrix.c ****     matrix_scan_quantum();
 225:quantum/matrix.c ****     return 1;
 226:quantum/matrix.c **** }
 227:quantum/matrix.c **** 
 228:quantum/matrix.c **** bool matrix_is_modified(void)
 229:quantum/matrix.c **** {
 230:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 231:quantum/matrix.c ****     if (debouncing) return false;
 232:quantum/matrix.c **** #endif
 233:quantum/matrix.c ****     return true;
 234:quantum/matrix.c **** }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c **** inline
 237:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 238:quantum/matrix.c **** {
 239:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** inline
 243:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 244:quantum/matrix.c **** {
 245:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 246:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 247:quantum/matrix.c **** #ifdef MATRIX_MASKED
 248:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 249:quantum/matrix.c **** #else
 250:quantum/matrix.c ****     return matrix[row];
 251:quantum/matrix.c **** #endif
 252:quantum/matrix.c **** }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c **** void matrix_print(void)
 255:quantum/matrix.c **** {
 256:quantum/matrix.c ****     print_matrix_header();
 257:quantum/matrix.c **** 
 258:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 259:quantum/matrix.c ****         phex(row); print(": ");
 260:quantum/matrix.c ****         print_matrix_row(row);
 261:quantum/matrix.c ****         print("\n");
 262:quantum/matrix.c ****     }
 263:quantum/matrix.c **** }
 264:quantum/matrix.c **** 
 265:quantum/matrix.c **** uint8_t matrix_key_count(void)
 266:quantum/matrix.c **** {
 267:quantum/matrix.c ****     uint8_t count = 0;
 268:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 269:quantum/matrix.c ****         count += matrix_bitpop(i);
 270:quantum/matrix.c ****     }
 271:quantum/matrix.c ****     return count;
 272:quantum/matrix.c **** }
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** 
 276:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 277:quantum/matrix.c **** 
 278:quantum/matrix.c **** static void init_cols(void)
 279:quantum/matrix.c **** {
 280:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 281:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 283:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 284:quantum/matrix.c ****     }
 285:quantum/matrix.c **** }
 286:quantum/matrix.c **** 
 287:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 288:quantum/matrix.c **** {
 289:quantum/matrix.c ****     // Store last value of row prior to reading
 290:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 291:quantum/matrix.c **** 
 292:quantum/matrix.c ****     // Clear data in matrix row
 293:quantum/matrix.c ****     current_matrix[current_row] = 0;
 294:quantum/matrix.c **** 
 295:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 296:quantum/matrix.c ****     select_row(current_row);
 297:quantum/matrix.c ****     wait_us(30);
 298:quantum/matrix.c **** 
 299:quantum/matrix.c ****     // For each col...
 300:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 301:quantum/matrix.c **** 
 302:quantum/matrix.c ****         // Select the col pin to read (active low)
 303:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 304:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 305:quantum/matrix.c **** 
 306:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 307:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 308:quantum/matrix.c ****     }
 309:quantum/matrix.c **** 
 310:quantum/matrix.c ****     // Unselect row
 311:quantum/matrix.c ****     unselect_row(current_row);
 312:quantum/matrix.c **** 
 313:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 314:quantum/matrix.c **** }
 315:quantum/matrix.c **** 
 316:quantum/matrix.c **** static void select_row(uint8_t row)
 317:quantum/matrix.c **** {
 318:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 320:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 321:quantum/matrix.c **** }
 322:quantum/matrix.c **** 
 323:quantum/matrix.c **** static void unselect_row(uint8_t row)
 324:quantum/matrix.c **** {
 325:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 327:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 328:quantum/matrix.c **** }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c **** static void unselect_rows(void)
 184               		.loc 1 330 13 view .LVU23
 331:quantum/matrix.c **** {
 332:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 185               		.loc 1 332 5 view .LVU24
 186               	.LBB22:
 187               		.loc 1 332 9 view .LVU25
 188               	.LVL4:
 189               		.loc 1 332 26 view .LVU26
 190 0010 A0E0      		ldi r26,lo8(row_pins)
 191 0012 B0E0      		ldi r27,hi8(row_pins)
 192 0014 20E0      		ldi r18,lo8(row_pins+8)
 193 0016 30E0      		ldi r19,hi8(row_pins+8)
 194               	.LBB23:
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 195               		.loc 1 334 38 is_stmt 0 view .LVU27
 196 0018 61E0      		ldi r22,lo8(1)
 197 001a 70E0      		ldi r23,0
 198               	.LVL5:
 199               	.L10:
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 200               		.loc 1 333 9 is_stmt 1 view .LVU28
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 201               		.loc 1 333 17 is_stmt 0 view .LVU29
 202 001c 8D91      		ld r24,X+
 203               	.LVL6:
 204               		.loc 1 334 9 is_stmt 1 view .LVU30
 205 001e E82F      		mov r30,r24
 206 0020 E295      		swap r30
 207 0022 EF70      		andi r30,lo8(15)
 208 0024 F0E0      		ldi r31,0
 209 0026 41A1      		ldd r20,Z+33
 210               		.loc 1 334 38 is_stmt 0 view .LVU31
 211 0028 8F70      		andi r24,lo8(15)
 212               	.LVL7:
 213               		.loc 1 334 38 view .LVU32
 214 002a EB01      		movw r28,r22
 215 002c 00C0      		rjmp 2f
 216               		1:
 217 002e CC0F      		lsl r28
 218 0030 DD1F      		rol r29
 219               		2:
 220 0032 8A95      		dec r24
 221 0034 02F4      		brpl 1b
 222 0036 CE01      		movw r24,r28
 223               		.loc 1 334 34 view .LVU33
 224 0038 9C2F      		mov r25,r28
 225 003a 9095      		com r25
 226 003c 9423      		and r25,r20
 227 003e 91A3      		std Z+33,r25
 228               	.LVL8:
 335:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 229               		.loc 1 335 9 is_stmt 1 view .LVU34
 230 0040 92A1      		ldd r25,Z+34
 231               		.loc 1 335 34 is_stmt 0 view .LVU35
 232 0042 892B      		or r24,r25
 233 0044 82A3      		std Z+34,r24
 234               	.LBE23:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 235               		.loc 1 332 42 is_stmt 1 view .LVU36
 236               	.LVL9:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 237               		.loc 1 332 26 view .LVU37
 238 0046 2A17      		cp r18,r26
 239 0048 3B07      		cpc r19,r27
 240 004a 01F4      		brne .L10
 241 004c A0E0      		ldi r26,lo8(col_pins)
 242 004e B0E0      		ldi r27,hi8(col_pins)
 243               	.LVL10:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 244               		.loc 1 332 26 is_stmt 0 view .LVU38
 245 0050 20E0      		ldi r18,lo8(col_pins+16)
 246 0052 30E0      		ldi r19,hi8(col_pins+16)
 247               	.LBE22:
 248               	.LBE21:
 249               	.LBB24:
 250               	.LBB25:
 251               	.LBB26:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 252               		.loc 1 282 38 view .LVU39
 253 0054 61E0      		ldi r22,lo8(1)
 254 0056 70E0      		ldi r23,0
 255               	.LVL11:
 256               	.L11:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 257               		.loc 1 281 9 is_stmt 1 view .LVU40
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 258               		.loc 1 281 17 is_stmt 0 view .LVU41
 259 0058 8D91      		ld r24,X+
 260               	.LVL12:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 261               		.loc 1 282 9 is_stmt 1 view .LVU42
 262 005a E82F      		mov r30,r24
 263 005c E295      		swap r30
 264 005e EF70      		andi r30,lo8(15)
 265 0060 F0E0      		ldi r31,0
 266 0062 41A1      		ldd r20,Z+33
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 267               		.loc 1 282 38 is_stmt 0 view .LVU43
 268 0064 8F70      		andi r24,lo8(15)
 269               	.LVL13:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 270               		.loc 1 282 38 view .LVU44
 271 0066 EB01      		movw r28,r22
 272 0068 00C0      		rjmp 2f
 273               		1:
 274 006a CC0F      		lsl r28
 275 006c DD1F      		rol r29
 276               		2:
 277 006e 8A95      		dec r24
 278 0070 02F4      		brpl 1b
 279 0072 CE01      		movw r24,r28
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 280               		.loc 1 282 34 view .LVU45
 281 0074 9C2F      		mov r25,r28
 282 0076 9095      		com r25
 283 0078 9423      		and r25,r20
 284 007a 91A3      		std Z+33,r25
 285               	.LVL14:
 283:quantum/matrix.c ****     }
 286               		.loc 1 283 9 is_stmt 1 view .LVU46
 287 007c 92A1      		ldd r25,Z+34
 283:quantum/matrix.c ****     }
 288               		.loc 1 283 34 is_stmt 0 view .LVU47
 289 007e 892B      		or r24,r25
 290 0080 82A3      		std Z+34,r24
 291               	.LBE26:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 292               		.loc 1 280 42 is_stmt 1 view .LVU48
 293               	.LVL15:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 294               		.loc 1 280 26 view .LVU49
 295 0082 2A17      		cp r18,r26
 296 0084 3B07      		cpc r19,r27
 297 0086 01F4      		brne .L11
 298               	.LBE25:
 299               	.LBE24:
 300               	.LBB27:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 301               		.loc 1 168 19 is_stmt 0 view .LVU50
 302 0088 80E1      		ldi r24,lo8(16)
 303 008a E0E0      		ldi r30,lo8(matrix)
 304 008c F0E0      		ldi r31,hi8(matrix)
 305 008e DF01      		movw r26,r30
 306               	.LVL16:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 307               		.loc 1 168 19 view .LVU51
 308 0090 C82F      		mov r28,r24
 309               		0:
 310 0092 1D92      		st X+,__zero_reg__
 311 0094 CA95      		dec r28
 312 0096 01F4      		brne 0b
 170:quantum/matrix.c ****     }
 313               		.loc 1 170 30 view .LVU52
 314 0098 E0E0      		ldi r30,lo8(matrix_debouncing)
 315 009a F0E0      		ldi r31,hi8(matrix_debouncing)
 316 009c DF01      		movw r26,r30
 317               		0:
 318 009e 1D92      		st X+,__zero_reg__
 319 00a0 8A95      		dec r24
 320 00a2 01F4      		brne 0b
 321               	.LVL17:
 170:quantum/matrix.c ****     }
 322               		.loc 1 170 30 view .LVU53
 323               	.LBE27:
 173:quantum/matrix.c **** }
 324               		.loc 1 173 5 is_stmt 1 view .LVU54
 325               	/* epilogue start */
 174:quantum/matrix.c **** 
 326               		.loc 1 174 1 is_stmt 0 view .LVU55
 327 00a4 DF91      		pop r29
 328 00a6 CF91      		pop r28
 173:quantum/matrix.c **** }
 329               		.loc 1 173 5 view .LVU56
 330 00a8 0C94 0000 		jmp matrix_init_quantum
 331               	.LVL18:
 332               		.cfi_endproc
 333               	.LFE18:
 335               		.section	.text.matrix_scan,"ax",@progbits
 336               	.global	matrix_scan
 338               	matrix_scan:
 339               	.LFB19:
 177:quantum/matrix.c **** 
 340               		.loc 1 177 1 is_stmt 1 view -0
 341               		.cfi_startproc
 342 0000 2F92      		push r2
 343               	.LCFI2:
 344               		.cfi_def_cfa_offset 3
 345               		.cfi_offset 2, -2
 346 0002 3F92      		push r3
 347               	.LCFI3:
 348               		.cfi_def_cfa_offset 4
 349               		.cfi_offset 3, -3
 350 0004 5F92      		push r5
 351               	.LCFI4:
 352               		.cfi_def_cfa_offset 5
 353               		.cfi_offset 5, -4
 354 0006 6F92      		push r6
 355               	.LCFI5:
 356               		.cfi_def_cfa_offset 6
 357               		.cfi_offset 6, -5
 358 0008 7F92      		push r7
 359               	.LCFI6:
 360               		.cfi_def_cfa_offset 7
 361               		.cfi_offset 7, -6
 362 000a 8F92      		push r8
 363               	.LCFI7:
 364               		.cfi_def_cfa_offset 8
 365               		.cfi_offset 8, -7
 366 000c 9F92      		push r9
 367               	.LCFI8:
 368               		.cfi_def_cfa_offset 9
 369               		.cfi_offset 9, -8
 370 000e AF92      		push r10
 371               	.LCFI9:
 372               		.cfi_def_cfa_offset 10
 373               		.cfi_offset 10, -9
 374 0010 BF92      		push r11
 375               	.LCFI10:
 376               		.cfi_def_cfa_offset 11
 377               		.cfi_offset 11, -10
 378 0012 CF92      		push r12
 379               	.LCFI11:
 380               		.cfi_def_cfa_offset 12
 381               		.cfi_offset 12, -11
 382 0014 DF92      		push r13
 383               	.LCFI12:
 384               		.cfi_def_cfa_offset 13
 385               		.cfi_offset 13, -12
 386 0016 EF92      		push r14
 387               	.LCFI13:
 388               		.cfi_def_cfa_offset 14
 389               		.cfi_offset 14, -13
 390 0018 FF92      		push r15
 391               	.LCFI14:
 392               		.cfi_def_cfa_offset 15
 393               		.cfi_offset 15, -14
 394 001a 0F93      		push r16
 395               	.LCFI15:
 396               		.cfi_def_cfa_offset 16
 397               		.cfi_offset 16, -15
 398 001c 1F93      		push r17
 399               	.LCFI16:
 400               		.cfi_def_cfa_offset 17
 401               		.cfi_offset 17, -16
 402 001e CF93      		push r28
 403               	.LCFI17:
 404               		.cfi_def_cfa_offset 18
 405               		.cfi_offset 28, -17
 406 0020 DF93      		push r29
 407               	.LCFI18:
 408               		.cfi_def_cfa_offset 19
 409               		.cfi_offset 29, -18
 410               	/* prologue: function */
 411               	/* frame size = 0 */
 412               	/* stack size = 17 */
 413               	.L__stack_usage = 17
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 414               		.loc 1 182 5 view .LVU58
 415               	.LBB45:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 416               		.loc 1 182 10 view .LVU59
 417               	.LVL19:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 418               		.loc 1 182 47 view .LVU60
 419 0022 20E0      		ldi r18,lo8(matrix_debouncing)
 420 0024 222E      		mov r2,r18
 421 0026 20E0      		ldi r18,hi8(matrix_debouncing)
 422 0028 322E      		mov r3,r18
 423 002a 30E0      		ldi r19,lo8(row_pins)
 424 002c E32E      		mov r14,r19
 425 002e 30E0      		ldi r19,hi8(row_pins)
 426 0030 F32E      		mov r15,r19
 427 0032 40E0      		ldi r20,lo8(matrix_debouncing+16)
 428 0034 842E      		mov r8,r20
 429 0036 40E0      		ldi r20,hi8(matrix_debouncing+16)
 430 0038 942E      		mov r9,r20
 431               	.LBB46:
 432               	.LBB47:
 433               	.LBB48:
 434               	.LBB49:
 435               	.LBB50:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 436               		.loc 1 319 34 is_stmt 0 view .LVU61
 437 003a 01E0      		ldi r16,lo8(1)
 438 003c 10E0      		ldi r17,0
 439               	.LBE50:
 440               	.LBE49:
 441               	.LBE48:
 442               	.LBE47:
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 443               		.loc 1 187 28 view .LVU62
 444 003e 6624      		clr r6
 445 0040 6394      		inc r6
 446               	.LVL20:
 447               	.L18:
 184:quantum/matrix.c **** 
 448               		.loc 1 184 13 is_stmt 1 view .LVU63
 449               	.LBB66:
 450               	.LBI47:
 287:quantum/matrix.c **** {
 451               		.loc 1 287 13 view .LVU64
 452               	.LBB64:
 290:quantum/matrix.c **** 
 453               		.loc 1 290 5 view .LVU65
 290:quantum/matrix.c **** 
 454               		.loc 1 290 18 is_stmt 0 view .LVU66
 455 0042 E101      		movw r28,r2
 456 0044 A990      		ld r10,Y+
 457 0046 B990      		ld r11,Y+
 458 0048 1E01      		movw r2,r28
 459               	.LVL21:
 293:quantum/matrix.c **** 
 460               		.loc 1 293 5 is_stmt 1 view .LVU67
 461 004a DE01      		movw r26,r28
 293:quantum/matrix.c **** 
 462               		.loc 1 293 33 is_stmt 0 view .LVU68
 463 004c 1E92      		st -X,__zero_reg__
 464 004e 1E92      		st -X,__zero_reg__
 296:quantum/matrix.c ****     wait_us(30);
 465               		.loc 1 296 5 is_stmt 1 view .LVU69
 466               	.LVL22:
 467               	.LBB52:
 468               	.LBI49:
 316:quantum/matrix.c **** {
 469               		.loc 1 316 13 view .LVU70
 470               	.LBB51:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 471               		.loc 1 318 5 view .LVU71
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 472               		.loc 1 318 13 is_stmt 0 view .LVU72
 473 0050 F701      		movw r30,r14
 474 0052 8191      		ld r24,Z+
 475 0054 7F01      		movw r14,r30
 476               	.LVL23:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 477               		.loc 1 319 5 is_stmt 1 view .LVU73
 478 0056 E82F      		mov r30,r24
 479 0058 E295      		swap r30
 480 005a EF70      		andi r30,lo8(15)
 481 005c F0E0      		ldi r31,0
 482 005e 21A1      		ldd r18,Z+33
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 483               		.loc 1 319 34 is_stmt 0 view .LVU74
 484 0060 8F70      		andi r24,lo8(15)
 485               	.LVL24:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 486               		.loc 1 319 34 view .LVU75
 487 0062 A801      		movw r20,r16
 488 0064 00C0      		rjmp 2f
 489               		1:
 490 0066 440F      		lsl r20
 491 0068 551F      		rol r21
 492               		2:
 493 006a 8A95      		dec r24
 494 006c 02F4      		brpl 1b
 495 006e CA01      		movw r24,r20
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 496               		.loc 1 319 30 view .LVU76
 497 0070 242B      		or r18,r20
 498 0072 21A3      		std Z+33,r18
 499               	.LVL25:
 320:quantum/matrix.c **** }
 500               		.loc 1 320 5 is_stmt 1 view .LVU77
 501 0074 22A1      		ldd r18,Z+34
 320:quantum/matrix.c **** }
 502               		.loc 1 320 30 is_stmt 0 view .LVU78
 503 0076 742E      		mov r7,r20
 504 0078 7094      		com r7
 505 007a 2721      		and r18,r7
 506 007c 22A3      		std Z+34,r18
 507               	.LVL26:
 320:quantum/matrix.c **** }
 508               		.loc 1 320 30 view .LVU79
 509               	.LBE51:
 510               	.LBE52:
 297:quantum/matrix.c **** 
 511               		.loc 1 297 5 is_stmt 1 view .LVU80
 512               	.LBB53:
 513               	.LBI53:
 514               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2551 2020-10-10 20:33:35Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 515               		.loc 2 255 1 view .LVU81
 516               	.LBB54:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 517               		.loc 2 257 2 view .LVU82
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 518               		.loc 2 261 2 view .LVU83
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 519               		.loc 2 262 2 view .LVU84
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 520               		.loc 2 263 2 view .LVU85
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 521               		.loc 2 273 3 view .LVU86
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 522               		.loc 2 276 2 view .LVU87
 523 007e 50EA      		ldi r21,lo8(-96)
 524 0080 5A95      	1:	dec r21
 525 0082 01F4      		brne 1b
 526               	.LVL27:
 527               		.loc 2 276 2 is_stmt 0 view .LVU88
 528               	.LBE54:
 529               	.LBE53:
 300:quantum/matrix.c **** 
 530               		.loc 1 300 5 is_stmt 1 view .LVU89
 531               	.LBB56:
 300:quantum/matrix.c **** 
 532               		.loc 1 300 9 view .LVU90
 300:quantum/matrix.c **** 
 533               		.loc 1 300 42 view .LVU91
 534 0084 90E0      		ldi r25,lo8(col_pins)
 535 0086 C92E      		mov r12,r25
 536 0088 90E0      		ldi r25,hi8(col_pins)
 537 008a D92E      		mov r13,r25
 538               	.LBE56:
 539               	.LBB59:
 540               	.LBB55:
 541               		.loc 2 276 2 is_stmt 0 view .LVU92
 542 008c 40E0      		ldi r20,0
 543 008e 50E0      		ldi r21,0
 544               	.LVL28:
 545               	.L16:
 546               		.loc 2 276 2 view .LVU93
 547               	.LBE55:
 548               	.LBE59:
 549               	.LBB60:
 550               	.LBB57:
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 551               		.loc 1 303 9 is_stmt 1 view .LVU94
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 552               		.loc 1 303 17 is_stmt 0 view .LVU95
 553 0090 E601      		movw r28,r12
 554 0092 2991      		ld r18,Y+
 555 0094 6E01      		movw r12,r28
 556               	.LVL29:
 304:quantum/matrix.c **** 
 557               		.loc 1 304 9 is_stmt 1 view .LVU96
 304:quantum/matrix.c **** 
 558               		.loc 1 304 30 is_stmt 0 view .LVU97
 559 0096 622F      		mov r22,r18
 560 0098 6295      		swap r22
 561 009a 6F70      		andi r22,lo8(15)
 562 009c 605E      		subi r22,lo8(-(32))
 563 009e 70E0      		ldi r23,0
 564 00a0 EB01      		movw r28,r22
 565 00a2 5880      		ld r5,Y
 566               	.LVL30:
 307:quantum/matrix.c ****     }
 567               		.loc 1 307 9 is_stmt 1 view .LVU98
 307:quantum/matrix.c ****     }
 568               		.loc 1 307 23 is_stmt 0 view .LVU99
 569 00a4 6D91      		ld r22,X+
 570 00a6 7C91      		ld r23,X
 571 00a8 1197      		sbiw r26,1
 304:quantum/matrix.c **** 
 572               		.loc 1 304 51 view .LVU100
 573 00aa 2F70      		andi r18,lo8(15)
 574               	.LVL31:
 304:quantum/matrix.c **** 
 575               		.loc 1 304 51 view .LVU101
 576 00ac E801      		movw r28,r16
 577 00ae 00C0      		rjmp 2f
 578               		1:
 579 00b0 CC0F      		lsl r28
 580 00b2 DD1F      		rol r29
 581               		2:
 582 00b4 2A95      		dec r18
 583 00b6 02F4      		brpl 1b
 584 00b8 9E01      		movw r18,r28
 585               	.LVL32:
 304:quantum/matrix.c **** 
 586               		.loc 1 304 17 view .LVU102
 587 00ba 2521      		and r18,r5
 307:quantum/matrix.c ****     }
 588               		.loc 1 307 55 view .LVU103
 589 00bc 2111      		cpse r18,__zero_reg__
 590 00be 00C0      		rjmp .L22
 591 00c0 9801      		movw r18,r16
 592 00c2 042E      		mov r0,r20
 593 00c4 00C0      		rjmp 2f
 594               		1:
 595 00c6 220F      		lsl r18
 596 00c8 331F      		rol r19
 597               		2:
 598 00ca 0A94      		dec r0
 599 00cc 02F4      		brpl 1b
 600               	.L15:
 307:quantum/matrix.c ****     }
 601               		.loc 1 307 37 view .LVU104
 602 00ce 622B      		or r22,r18
 603 00d0 732B      		or r23,r19
 604 00d2 1196      		adiw r26,1
 605 00d4 7C93      		st X,r23
 606 00d6 6E93      		st -X,r22
 607               	.LBE57:
 300:quantum/matrix.c **** 
 608               		.loc 1 300 66 is_stmt 1 view .LVU105
 609               	.LVL33:
 300:quantum/matrix.c **** 
 610               		.loc 1 300 42 view .LVU106
 611 00d8 4F5F      		subi r20,-1
 612 00da 5F4F      		sbci r21,-1
 613               	.LVL34:
 300:quantum/matrix.c **** 
 614               		.loc 1 300 42 is_stmt 0 view .LVU107
 615 00dc 4031      		cpi r20,16
 616 00de 5105      		cpc r21,__zero_reg__
 617 00e0 01F4      		brne .L16
 618               	.LBE60:
 311:quantum/matrix.c **** 
 619               		.loc 1 311 5 is_stmt 1 view .LVU108
 620               	.LVL35:
 621               	.LBB61:
 622               	.LBI61:
 323:quantum/matrix.c **** {
 623               		.loc 1 323 13 view .LVU109
 624               	.LBB62:
 325:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 625               		.loc 1 325 5 view .LVU110
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 626               		.loc 1 326 5 view .LVU111
 627 00e2 91A1      		ldd r25,Z+33
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 628               		.loc 1 326 30 is_stmt 0 view .LVU112
 629 00e4 7922      		and r7,r25
 630 00e6 71A2      		std Z+33,r7
 631               	.LVL36:
 327:quantum/matrix.c **** }
 632               		.loc 1 327 5 is_stmt 1 view .LVU113
 633 00e8 92A1      		ldd r25,Z+34
 327:quantum/matrix.c **** }
 634               		.loc 1 327 30 is_stmt 0 view .LVU114
 635 00ea 892B      		or r24,r25
 636 00ec 82A3      		std Z+34,r24
 637               	.LVL37:
 327:quantum/matrix.c **** }
 638               		.loc 1 327 30 view .LVU115
 639               	.LBE62:
 640               	.LBE61:
 313:quantum/matrix.c **** }
 641               		.loc 1 313 5 is_stmt 1 view .LVU116
 313:quantum/matrix.c **** }
 642               		.loc 1 313 5 is_stmt 0 view .LVU117
 643               	.LBE64:
 644               	.LBE66:
 186:quantum/matrix.c ****                 debouncing = true;
 645               		.loc 1 186 13 is_stmt 1 view .LVU118
 186:quantum/matrix.c ****                 debouncing = true;
 646               		.loc 1 186 16 is_stmt 0 view .LVU119
 647 00ee 8D91      		ld r24,X+
 648 00f0 9C91      		ld r25,X
 649 00f2 A816      		cp r10,r24
 650 00f4 B906      		cpc r11,r25
 651 00f6 01F0      		breq .L17
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 652               		.loc 1 187 17 is_stmt 1 view .LVU120
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 653               		.loc 1 187 28 is_stmt 0 view .LVU121
 654 00f8 6092 0000 		sts debouncing,r6
 188:quantum/matrix.c ****             }
 655               		.loc 1 188 17 is_stmt 1 view .LVU122
 188:quantum/matrix.c ****             }
 656               		.loc 1 188 35 is_stmt 0 view .LVU123
 657 00fc 0E94 0000 		call timer_read
 658               	.LVL38:
 188:quantum/matrix.c ****             }
 659               		.loc 1 188 33 view .LVU124
 660 0100 9093 0000 		sts debouncing_time+1,r25
 661 0104 8093 0000 		sts debouncing_time,r24
 662               	.L17:
 663               	.LBE46:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 664               		.loc 1 182 73 is_stmt 1 discriminator 2 view .LVU125
 665               	.LVL39:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 666               		.loc 1 182 47 discriminator 2 view .LVU126
 667 0108 8214      		cp r8,r2
 668 010a 9304      		cpc r9,r3
 669 010c 01F0      		breq .+2
 670 010e 00C0      		rjmp .L18
 671               	.LBE45:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 672               		.loc 1 216 9 view .LVU127
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 673               		.loc 1 216 12 is_stmt 0 view .LVU128
 674 0110 8091 0000 		lds r24,debouncing
 675 0114 8823      		tst r24
 676 0116 01F0      		breq .L20
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 677               		.loc 1 216 28 discriminator 1 view .LVU129
 678 0118 8091 0000 		lds r24,debouncing_time
 679 011c 9091 0000 		lds r25,debouncing_time+1
 680 0120 0E94 0000 		call timer_elapsed
 681               	.LVL40:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 682               		.loc 1 216 24 discriminator 1 view .LVU130
 683 0124 0697      		sbiw r24,6
 684 0126 00F0      		brlo .L20
 685               	.LBB69:
 218:quantum/matrix.c ****             }
 686               		.loc 1 218 27 view .LVU131
 687 0128 80E1      		ldi r24,lo8(16)
 688 012a E0E0      		ldi r30,lo8(matrix_debouncing)
 689 012c F0E0      		ldi r31,hi8(matrix_debouncing)
 690 012e A0E0      		ldi r26,lo8(matrix)
 691 0130 B0E0      		ldi r27,hi8(matrix)
 692               		0:
 693 0132 0190      		ld r0,Z+
 694 0134 0D92      		st X+,r0
 695 0136 8A95      		dec r24
 696 0138 01F4      		brne 0b
 697               	.LBE69:
 220:quantum/matrix.c ****         }
 698               		.loc 1 220 13 is_stmt 1 view .LVU132
 220:quantum/matrix.c ****         }
 699               		.loc 1 220 24 is_stmt 0 view .LVU133
 700 013a 1092 0000 		sts debouncing,__zero_reg__
 701               	.L20:
 224:quantum/matrix.c ****     return 1;
 702               		.loc 1 224 5 is_stmt 1 view .LVU134
 703 013e 0E94 0000 		call matrix_scan_quantum
 704               	.LVL41:
 225:quantum/matrix.c **** }
 705               		.loc 1 225 5 view .LVU135
 226:quantum/matrix.c **** 
 706               		.loc 1 226 1 is_stmt 0 view .LVU136
 707 0142 81E0      		ldi r24,lo8(1)
 708               	/* epilogue start */
 709 0144 DF91      		pop r29
 710 0146 CF91      		pop r28
 711 0148 1F91      		pop r17
 712 014a 0F91      		pop r16
 713 014c FF90      		pop r15
 714 014e EF90      		pop r14
 715               	.LVL42:
 226:quantum/matrix.c **** 
 716               		.loc 1 226 1 view .LVU137
 717 0150 DF90      		pop r13
 718 0152 CF90      		pop r12
 719 0154 BF90      		pop r11
 720 0156 AF90      		pop r10
 226:quantum/matrix.c **** 
 721               		.loc 1 226 1 view .LVU138
 722 0158 9F90      		pop r9
 723 015a 8F90      		pop r8
 724 015c 7F90      		pop r7
 725 015e 6F90      		pop r6
 726 0160 5F90      		pop r5
 727 0162 3F90      		pop r3
 728 0164 2F90      		pop r2
 729 0166 0895      		ret
 730               	.LVL43:
 731               	.L22:
 732               	.LBB70:
 733               	.LBB68:
 734               	.LBB67:
 735               	.LBB65:
 736               	.LBB63:
 737               	.LBB58:
 307:quantum/matrix.c ****     }
 738               		.loc 1 307 55 view .LVU139
 739 0168 20E0      		ldi r18,0
 740 016a 30E0      		ldi r19,0
 741 016c 00C0      		rjmp .L15
 742               	.LBE58:
 743               	.LBE63:
 744               	.LBE65:
 745               	.LBE67:
 746               	.LBE68:
 747               	.LBE70:
 748               		.cfi_endproc
 749               	.LFE19:
 751               		.section	.text.matrix_is_modified,"ax",@progbits
 752               	.global	matrix_is_modified
 754               	matrix_is_modified:
 755               	.LFB20:
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 756               		.loc 1 229 1 is_stmt 1 view -0
 757               		.cfi_startproc
 758               	/* prologue: function */
 759               	/* frame size = 0 */
 760               	/* stack size = 0 */
 761               	.L__stack_usage = 0
 231:quantum/matrix.c **** #endif
 762               		.loc 1 231 5 view .LVU141
 231:quantum/matrix.c **** #endif
 763               		.loc 1 231 8 is_stmt 0 view .LVU142
 764 0000 8091 0000 		lds r24,debouncing
 234:quantum/matrix.c **** 
 765               		.loc 1 234 1 view .LVU143
 766 0004 91E0      		ldi r25,lo8(1)
 767 0006 8927      		eor r24,r25
 768               	/* epilogue start */
 769 0008 0895      		ret
 770               		.cfi_endproc
 771               	.LFE20:
 773               		.section	.text.matrix_is_on,"ax",@progbits
 774               	.global	matrix_is_on
 776               	matrix_is_on:
 777               	.LVL44:
 778               	.LFB21:
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 779               		.loc 1 238 1 is_stmt 1 view -0
 780               		.cfi_startproc
 781               	/* prologue: function */
 782               	/* frame size = 0 */
 783               	/* stack size = 0 */
 784               	.L__stack_usage = 0
 239:quantum/matrix.c **** }
 785               		.loc 1 239 5 view .LVU145
 239:quantum/matrix.c **** }
 786               		.loc 1 239 19 is_stmt 0 view .LVU146
 787 0000 E82F      		mov r30,r24
 788 0002 F0E0      		ldi r31,0
 789 0004 EE0F      		lsl r30
 790 0006 FF1F      		rol r31
 791               	.LVL45:
 239:quantum/matrix.c **** }
 792               		.loc 1 239 19 view .LVU147
 793 0008 E050      		subi r30,lo8(-(matrix))
 794 000a F040      		sbci r31,hi8(-(matrix))
 239:quantum/matrix.c **** }
 795               		.loc 1 239 43 view .LVU148
 796 000c 21E0      		ldi r18,lo8(1)
 797 000e 30E0      		ldi r19,0
 798 0010 6230      		cpi r22,lo8(2)
 799 0012 00F4      		brsh .L27
 800 0014 20E0      		ldi r18,0
 801 0016 30E0      		ldi r19,0
 802               	.L27:
 239:quantum/matrix.c **** }
 803               		.loc 1 239 25 view .LVU149
 804 0018 8081      		ld r24,Z
 805 001a 9181      		ldd r25,Z+1
 806 001c 8223      		and r24,r18
 807 001e 9323      		and r25,r19
 240:quantum/matrix.c **** 
 808               		.loc 1 240 1 view .LVU150
 809 0020 8170      		andi r24,lo8(1)
 810               	/* epilogue start */
 811 0022 0895      		ret
 812               		.cfi_endproc
 813               	.LFE21:
 815               		.section	.text.matrix_get_row,"ax",@progbits
 816               	.global	matrix_get_row
 818               	matrix_get_row:
 819               	.LVL46:
 820               	.LFB22:
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 821               		.loc 1 244 1 is_stmt 1 view -0
 822               		.cfi_startproc
 823               	/* prologue: function */
 824               	/* frame size = 0 */
 825               	/* stack size = 0 */
 826               	.L__stack_usage = 0
 250:quantum/matrix.c **** #endif
 827               		.loc 1 250 5 view .LVU152
 250:quantum/matrix.c **** #endif
 828               		.loc 1 250 18 is_stmt 0 view .LVU153
 829 0000 E82F      		mov r30,r24
 830 0002 F0E0      		ldi r31,0
 831 0004 EE0F      		lsl r30
 832 0006 FF1F      		rol r31
 833               	.LVL47:
 250:quantum/matrix.c **** #endif
 834               		.loc 1 250 18 view .LVU154
 835 0008 E050      		subi r30,lo8(-(matrix))
 836 000a F040      		sbci r31,hi8(-(matrix))
 252:quantum/matrix.c **** 
 837               		.loc 1 252 1 view .LVU155
 838 000c 8081      		ld r24,Z
 839 000e 9181      		ldd r25,Z+1
 840               	/* epilogue start */
 841 0010 0895      		ret
 842               		.cfi_endproc
 843               	.LFE22:
 845               		.section	.text.matrix_print,"ax",@progbits
 846               	.global	matrix_print
 848               	matrix_print:
 849               	.LFB23:
 255:quantum/matrix.c ****     print_matrix_header();
 850               		.loc 1 255 1 is_stmt 1 view -0
 851               		.cfi_startproc
 852               	/* prologue: function */
 853               	/* frame size = 0 */
 854               	/* stack size = 0 */
 855               	.L__stack_usage = 0
 256:quantum/matrix.c **** 
 856               		.loc 1 256 26 view .LVU157
 258:quantum/matrix.c ****         phex(row); print(": ");
 857               		.loc 1 258 5 view .LVU158
 258:quantum/matrix.c ****         phex(row); print(": ");
 858               		.loc 1 258 10 view .LVU159
 258:quantum/matrix.c ****         phex(row); print(": ");
 859               		.loc 1 258 31 view .LVU160
 860               	/* epilogue start */
 263:quantum/matrix.c **** 
 861               		.loc 1 263 1 is_stmt 0 view .LVU161
 862 0000 0895      		ret
 863               		.cfi_endproc
 864               	.LFE23:
 866               		.section	.text.matrix_key_count,"ax",@progbits
 867               	.global	matrix_key_count
 869               	matrix_key_count:
 870               	.LFB24:
 266:quantum/matrix.c ****     uint8_t count = 0;
 871               		.loc 1 266 1 is_stmt 1 view -0
 872               		.cfi_startproc
 873 0000 0F93      		push r16
 874               	.LCFI19:
 875               		.cfi_def_cfa_offset 3
 876               		.cfi_offset 16, -2
 877 0002 1F93      		push r17
 878               	.LCFI20:
 879               		.cfi_def_cfa_offset 4
 880               		.cfi_offset 17, -3
 881 0004 CF93      		push r28
 882               	.LCFI21:
 883               		.cfi_def_cfa_offset 5
 884               		.cfi_offset 28, -4
 885               	/* prologue: function */
 886               	/* frame size = 0 */
 887               	/* stack size = 3 */
 888               	.L__stack_usage = 3
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 889               		.loc 1 267 5 view .LVU163
 890               	.LVL48:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 891               		.loc 1 268 5 view .LVU164
 892               	.LBB71:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 893               		.loc 1 268 10 view .LVU165
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 894               		.loc 1 268 27 view .LVU166
 895 0006 00E0      		ldi r16,lo8(matrix)
 896 0008 10E0      		ldi r17,hi8(matrix)
 897               	.LBE71:
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 898               		.loc 1 267 13 is_stmt 0 view .LVU167
 899 000a C0E0      		ldi r28,0
 900               	.LVL49:
 901               	.L31:
 902               	.LBB72:
 269:quantum/matrix.c ****     }
 903               		.loc 1 269 9 is_stmt 1 discriminator 3 view .LVU168
 269:quantum/matrix.c ****     }
 904               		.loc 1 269 18 is_stmt 0 discriminator 3 view .LVU169
 905 000c F801      		movw r30,r16
 906 000e 8191      		ld r24,Z+
 907 0010 9191      		ld r25,Z+
 908 0012 8F01      		movw r16,r30
 909               	.LVL50:
 269:quantum/matrix.c ****     }
 910               		.loc 1 269 18 discriminator 3 view .LVU170
 911 0014 0E94 0000 		call bitpop16
 912               	.LVL51:
 269:quantum/matrix.c ****     }
 913               		.loc 1 269 15 discriminator 3 view .LVU171
 914 0018 C80F      		add r28,r24
 915               	.LVL52:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 916               		.loc 1 268 43 is_stmt 1 discriminator 3 view .LVU172
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 917               		.loc 1 268 27 discriminator 3 view .LVU173
 918 001a F0E0      		ldi r31,hi8(matrix+16)
 919 001c 0030      		cpi r16,lo8(matrix+16)
 920 001e 1F07      		cpc r17,r31
 921 0020 01F4      		brne .L31
 922               	.LBE72:
 271:quantum/matrix.c **** }
 923               		.loc 1 271 5 view .LVU174
 272:quantum/matrix.c **** 
 924               		.loc 1 272 1 is_stmt 0 view .LVU175
 925 0022 8C2F      		mov r24,r28
 926               	/* epilogue start */
 927 0024 CF91      		pop r28
 928               	.LVL53:
 272:quantum/matrix.c **** 
 929               		.loc 1 272 1 view .LVU176
 930 0026 1F91      		pop r17
 931 0028 0F91      		pop r16
 932               	.LVL54:
 272:quantum/matrix.c **** 
 933               		.loc 1 272 1 view .LVU177
 934 002a 0895      		ret
 935               		.cfi_endproc
 936               	.LFE24:
 938               		.section	.bss.matrix_debouncing,"aw",@nobits
 941               	matrix_debouncing:
 942 0000 0000 0000 		.zero	16
 942      0000 0000 
 942      0000 0000 
 942      0000 0000 
 943               		.section	.bss.matrix,"aw",@nobits
 946               	matrix:
 947 0000 0000 0000 		.zero	16
 947      0000 0000 
 947      0000 0000 
 947      0000 0000 
 948               		.section	.rodata.col_pins,"a"
 951               	col_pins:
 952 0000 F1F0 0100 		.string	"\361\360\001"
 953 0004 C6C7 3031 		.ascii	"\306\30701a`\301\300\227\004\225\224"
 953      6160 C1C0 
 953      9704 9594 
 954               		.section	.rodata.row_pins,"a"
 957               	row_pins:
 958 0000 3233 3435 		.ascii	"2345\223\222\221\220"
 958      9392 9190 
 959               		.section	.bss.debouncing,"aw",@nobits
 962               	debouncing:
 963 0000 00        		.zero	1
 964               		.section	.bss.debouncing_time,"aw",@nobits
 967               	debouncing_time:
 968 0000 0000      		.zero	2
 969               		.text
 970               	.Letext0:
 971               		.file 3 "/usr/avr/include/stdint.h"
 972               		.file 4 "./tmk_core/common/matrix.h"
 973               		.file 5 "./tmk_core/common/util.h"
 974               		.file 6 "./tmk_core/common/timer.h"
 975               		.file 7 "/usr/avr/include/math.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccWVSWB8.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccWVSWB8.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccWVSWB8.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccWVSWB8.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccWVSWB8.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccWVSWB8.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccWVSWB8.s:15     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccWVSWB8.s:17     .text.matrix_init_user:0000000000000000 .Loc.0
     /tmp/ccWVSWB8.s:18     .text.matrix_init_user:0000000000000000 L0
     /tmp/ccWVSWB8.s:23     .text.matrix_init_user:0000000000000000 .Loc.1
     /tmp/ccWVSWB8.s:26     .text.matrix_init_user:0000000000000002 L0
     /tmp/ccWVSWB8.s:15     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias
     /tmp/ccWVSWB8.s:33     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccWVSWB8.s:35     .text.matrix_init_kb:0000000000000000 .Loc.2
     /tmp/ccWVSWB8.s:36     .text.matrix_init_kb:0000000000000000 L0
     /tmp/ccWVSWB8.s:41     .text.matrix_init_kb:0000000000000000 .Loc.3
     /tmp/ccWVSWB8.s:44     .text.matrix_init_kb:0000000000000004 L0
     /tmp/ccWVSWB8.s:50     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccWVSWB8.s:52     .text.matrix_init_quantum:0000000000000000 .Loc.4
     /tmp/ccWVSWB8.s:53     .text.matrix_init_quantum:0000000000000000 L0
     /tmp/ccWVSWB8.s:58     .text.matrix_init_quantum:0000000000000000 .Loc.5
     /tmp/ccWVSWB8.s:61     .text.matrix_init_quantum:0000000000000004 L0
     /tmp/ccWVSWB8.s:67     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccWVSWB8.s:69     .text.matrix_scan_user:0000000000000000 L0
     /tmp/ccWVSWB8.s:70     .text.matrix_scan_user:0000000000000000 .Loc.6
     /tmp/ccWVSWB8.s:77     .text.matrix_scan_user:0000000000000002 L0
     /tmp/ccWVSWB8.s:83     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccWVSWB8.s:85     .text.matrix_scan_kb:0000000000000000 .Loc.7
     /tmp/ccWVSWB8.s:86     .text.matrix_scan_kb:0000000000000000 L0
     /tmp/ccWVSWB8.s:91     .text.matrix_scan_kb:0000000000000000 .Loc.8
     /tmp/ccWVSWB8.s:94     .text.matrix_scan_kb:0000000000000004 L0
     /tmp/ccWVSWB8.s:100    .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccWVSWB8.s:102    .text.matrix_scan_quantum:0000000000000000 .Loc.9
     /tmp/ccWVSWB8.s:103    .text.matrix_scan_quantum:0000000000000000 L0
     /tmp/ccWVSWB8.s:108    .text.matrix_scan_quantum:0000000000000000 .Loc.10
     /tmp/ccWVSWB8.s:111    .text.matrix_scan_quantum:0000000000000004 L0
     /tmp/ccWVSWB8.s:117    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccWVSWB8.s:119    .text.matrix_rows:0000000000000000 .Loc.11
     /tmp/ccWVSWB8.s:120    .text.matrix_rows:0000000000000000 L0
     /tmp/ccWVSWB8.s:125    .text.matrix_rows:0000000000000000 .Loc.12
     /tmp/ccWVSWB8.s:126    .text.matrix_rows:0000000000000000 .Loc.13
     /tmp/ccWVSWB8.s:130    .text.matrix_rows:0000000000000004 L0
     /tmp/ccWVSWB8.s:136    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccWVSWB8.s:138    .text.matrix_cols:0000000000000000 .Loc.14
     /tmp/ccWVSWB8.s:139    .text.matrix_cols:0000000000000000 L0
     /tmp/ccWVSWB8.s:144    .text.matrix_cols:0000000000000000 .Loc.15
     /tmp/ccWVSWB8.s:145    .text.matrix_cols:0000000000000000 .Loc.16
     /tmp/ccWVSWB8.s:149    .text.matrix_cols:0000000000000004 L0
     /tmp/ccWVSWB8.s:155    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccWVSWB8.s:157    .text.matrix_init:0000000000000000 .Loc.17
     /tmp/ccWVSWB8.s:158    .text.matrix_init:0000000000000000 L0
     /tmp/ccWVSWB8.s:171    .text.matrix_init:0000000000000004 .Loc.18
     /tmp/ccWVSWB8.s:173    .text.matrix_init:0000000000000006 .Loc.19
     /tmp/ccWVSWB8.s:176    .text.matrix_init:000000000000000a .Loc.20
     /tmp/ccWVSWB8.s:178    .text.matrix_init:000000000000000c .Loc.21
     /tmp/ccWVSWB8.s:181    .text.matrix_init:0000000000000010 .Loc.22
     /tmp/ccWVSWB8.s:184    .text.matrix_init:0000000000000010 .Loc.23
     /tmp/ccWVSWB8.s:185    .text.matrix_init:0000000000000010 .Loc.24
     /tmp/ccWVSWB8.s:187    .text.matrix_init:0000000000000010 .Loc.25
     /tmp/ccWVSWB8.s:189    .text.matrix_init:0000000000000010 .Loc.26
     /tmp/ccWVSWB8.s:957    .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccWVSWB8.s:195    .text.matrix_init:0000000000000018 .Loc.27
     /tmp/ccWVSWB8.s:200    .text.matrix_init:000000000000001c .Loc.28
     /tmp/ccWVSWB8.s:201    .text.matrix_init:000000000000001c .Loc.29
     /tmp/ccWVSWB8.s:204    .text.matrix_init:000000000000001e .Loc.30
     /tmp/ccWVSWB8.s:210    .text.matrix_init:0000000000000028 .Loc.31
     /tmp/ccWVSWB8.s:213    .text.matrix_init:000000000000002a .Loc.32
     /tmp/ccWVSWB8.s:223    .text.matrix_init:0000000000000038 .Loc.33
     /tmp/ccWVSWB8.s:229    .text.matrix_init:0000000000000040 .Loc.34
     /tmp/ccWVSWB8.s:231    .text.matrix_init:0000000000000042 .Loc.35
     /tmp/ccWVSWB8.s:235    .text.matrix_init:0000000000000046 .Loc.36
     /tmp/ccWVSWB8.s:237    .text.matrix_init:0000000000000046 .Loc.37
     /tmp/ccWVSWB8.s:951    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccWVSWB8.s:244    .text.matrix_init:0000000000000050 .Loc.38
     /tmp/ccWVSWB8.s:252    .text.matrix_init:0000000000000054 .Loc.39
     /tmp/ccWVSWB8.s:257    .text.matrix_init:0000000000000058 .Loc.40
     /tmp/ccWVSWB8.s:258    .text.matrix_init:0000000000000058 .Loc.41
     /tmp/ccWVSWB8.s:261    .text.matrix_init:000000000000005a .Loc.42
     /tmp/ccWVSWB8.s:267    .text.matrix_init:0000000000000064 .Loc.43
     /tmp/ccWVSWB8.s:270    .text.matrix_init:0000000000000066 .Loc.44
     /tmp/ccWVSWB8.s:280    .text.matrix_init:0000000000000074 .Loc.45
     /tmp/ccWVSWB8.s:286    .text.matrix_init:000000000000007c .Loc.46
     /tmp/ccWVSWB8.s:288    .text.matrix_init:000000000000007e .Loc.47
     /tmp/ccWVSWB8.s:292    .text.matrix_init:0000000000000082 .Loc.48
     /tmp/ccWVSWB8.s:294    .text.matrix_init:0000000000000082 .Loc.49
     /tmp/ccWVSWB8.s:301    .text.matrix_init:0000000000000088 .Loc.50
     /tmp/ccWVSWB8.s:946    .bss.matrix:0000000000000000 matrix
     /tmp/ccWVSWB8.s:307    .text.matrix_init:0000000000000090 .Loc.51
     /tmp/ccWVSWB8.s:313    .text.matrix_init:0000000000000098 .Loc.52
     /tmp/ccWVSWB8.s:941    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccWVSWB8.s:322    .text.matrix_init:00000000000000a4 .Loc.53
     /tmp/ccWVSWB8.s:324    .text.matrix_init:00000000000000a4 .Loc.54
     /tmp/ccWVSWB8.s:326    .text.matrix_init:00000000000000a4 .Loc.55
     /tmp/ccWVSWB8.s:329    .text.matrix_init:00000000000000a8 .Loc.56
     /tmp/ccWVSWB8.s:332    .text.matrix_init:00000000000000ac L0
     /tmp/ccWVSWB8.s:338    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccWVSWB8.s:340    .text.matrix_scan:0000000000000000 .Loc.57
     /tmp/ccWVSWB8.s:341    .text.matrix_scan:0000000000000000 L0
     /tmp/ccWVSWB8.s:414    .text.matrix_scan:0000000000000022 .Loc.58
     /tmp/ccWVSWB8.s:416    .text.matrix_scan:0000000000000022 .Loc.59
     /tmp/ccWVSWB8.s:418    .text.matrix_scan:0000000000000022 .Loc.60
     /tmp/ccWVSWB8.s:436    .text.matrix_scan:000000000000003a .Loc.61
     /tmp/ccWVSWB8.s:443    .text.matrix_scan:000000000000003e .Loc.62
     /tmp/ccWVSWB8.s:448    .text.matrix_scan:0000000000000042 .Loc.63
     /tmp/ccWVSWB8.s:451    .text.matrix_scan:0000000000000042 .Loc.64
     /tmp/ccWVSWB8.s:453    .text.matrix_scan:0000000000000042 .Loc.65
     /tmp/ccWVSWB8.s:454    .text.matrix_scan:0000000000000042 .Loc.66
     /tmp/ccWVSWB8.s:460    .text.matrix_scan:000000000000004a .Loc.67
     /tmp/ccWVSWB8.s:462    .text.matrix_scan:000000000000004c .Loc.68
     /tmp/ccWVSWB8.s:465    .text.matrix_scan:0000000000000050 .Loc.69
     /tmp/ccWVSWB8.s:469    .text.matrix_scan:0000000000000050 .Loc.70
     /tmp/ccWVSWB8.s:471    .text.matrix_scan:0000000000000050 .Loc.71
     /tmp/ccWVSWB8.s:472    .text.matrix_scan:0000000000000050 .Loc.72
     /tmp/ccWVSWB8.s:477    .text.matrix_scan:0000000000000056 .Loc.73
     /tmp/ccWVSWB8.s:483    .text.matrix_scan:0000000000000060 .Loc.74
     /tmp/ccWVSWB8.s:486    .text.matrix_scan:0000000000000062 .Loc.75
     /tmp/ccWVSWB8.s:496    .text.matrix_scan:0000000000000070 .Loc.76
     /tmp/ccWVSWB8.s:500    .text.matrix_scan:0000000000000074 .Loc.77
     /tmp/ccWVSWB8.s:502    .text.matrix_scan:0000000000000076 .Loc.78
     /tmp/ccWVSWB8.s:508    .text.matrix_scan:000000000000007e .Loc.79
     /tmp/ccWVSWB8.s:511    .text.matrix_scan:000000000000007e .Loc.80
     /tmp/ccWVSWB8.s:515    .text.matrix_scan:000000000000007e .Loc.81
     /tmp/ccWVSWB8.s:517    .text.matrix_scan:000000000000007e .Loc.82
     /tmp/ccWVSWB8.s:518    .text.matrix_scan:000000000000007e .Loc.83
     /tmp/ccWVSWB8.s:519    .text.matrix_scan:000000000000007e .Loc.84
     /tmp/ccWVSWB8.s:520    .text.matrix_scan:000000000000007e .Loc.85
     /tmp/ccWVSWB8.s:521    .text.matrix_scan:000000000000007e .Loc.86
     /tmp/ccWVSWB8.s:522    .text.matrix_scan:000000000000007e .Loc.87
     /tmp/ccWVSWB8.s:527    .text.matrix_scan:0000000000000084 .Loc.88
     /tmp/ccWVSWB8.s:530    .text.matrix_scan:0000000000000084 .Loc.89
     /tmp/ccWVSWB8.s:532    .text.matrix_scan:0000000000000084 .Loc.90
     /tmp/ccWVSWB8.s:533    .text.matrix_scan:0000000000000084 .Loc.91
     /tmp/ccWVSWB8.s:541    .text.matrix_scan:000000000000008c .Loc.92
     /tmp/ccWVSWB8.s:546    .text.matrix_scan:0000000000000090 .Loc.93
     /tmp/ccWVSWB8.s:551    .text.matrix_scan:0000000000000090 .Loc.94
     /tmp/ccWVSWB8.s:552    .text.matrix_scan:0000000000000090 .Loc.95
     /tmp/ccWVSWB8.s:557    .text.matrix_scan:0000000000000096 .Loc.96
     /tmp/ccWVSWB8.s:558    .text.matrix_scan:0000000000000096 .Loc.97
     /tmp/ccWVSWB8.s:567    .text.matrix_scan:00000000000000a4 .Loc.98
     /tmp/ccWVSWB8.s:568    .text.matrix_scan:00000000000000a4 .Loc.99
     /tmp/ccWVSWB8.s:572    .text.matrix_scan:00000000000000aa .Loc.100
     /tmp/ccWVSWB8.s:575    .text.matrix_scan:00000000000000ac .Loc.101
     /tmp/ccWVSWB8.s:586    .text.matrix_scan:00000000000000ba .Loc.102
     /tmp/ccWVSWB8.s:588    .text.matrix_scan:00000000000000bc .Loc.103
     /tmp/ccWVSWB8.s:601    .text.matrix_scan:00000000000000ce .Loc.104
     /tmp/ccWVSWB8.s:608    .text.matrix_scan:00000000000000d8 .Loc.105
     /tmp/ccWVSWB8.s:610    .text.matrix_scan:00000000000000d8 .Loc.106
     /tmp/ccWVSWB8.s:614    .text.matrix_scan:00000000000000dc .Loc.107
     /tmp/ccWVSWB8.s:619    .text.matrix_scan:00000000000000e2 .Loc.108
     /tmp/ccWVSWB8.s:623    .text.matrix_scan:00000000000000e2 .Loc.109
     /tmp/ccWVSWB8.s:625    .text.matrix_scan:00000000000000e2 .Loc.110
     /tmp/ccWVSWB8.s:626    .text.matrix_scan:00000000000000e2 .Loc.111
     /tmp/ccWVSWB8.s:628    .text.matrix_scan:00000000000000e4 .Loc.112
     /tmp/ccWVSWB8.s:632    .text.matrix_scan:00000000000000e8 .Loc.113
     /tmp/ccWVSWB8.s:634    .text.matrix_scan:00000000000000ea .Loc.114
     /tmp/ccWVSWB8.s:638    .text.matrix_scan:00000000000000ee .Loc.115
     /tmp/ccWVSWB8.s:641    .text.matrix_scan:00000000000000ee .Loc.116
     /tmp/ccWVSWB8.s:642    .text.matrix_scan:00000000000000ee .Loc.117
     /tmp/ccWVSWB8.s:645    .text.matrix_scan:00000000000000ee .Loc.118
     /tmp/ccWVSWB8.s:646    .text.matrix_scan:00000000000000ee .Loc.119
     /tmp/ccWVSWB8.s:652    .text.matrix_scan:00000000000000f8 .Loc.120
     /tmp/ccWVSWB8.s:653    .text.matrix_scan:00000000000000f8 .Loc.121
     /tmp/ccWVSWB8.s:962    .bss.debouncing:0000000000000000 debouncing
     /tmp/ccWVSWB8.s:655    .text.matrix_scan:00000000000000fc .Loc.122
     /tmp/ccWVSWB8.s:656    .text.matrix_scan:00000000000000fc .Loc.123
     /tmp/ccWVSWB8.s:659    .text.matrix_scan:0000000000000100 .Loc.124
     /tmp/ccWVSWB8.s:967    .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/ccWVSWB8.s:664    .text.matrix_scan:0000000000000108 .Loc.125
     /tmp/ccWVSWB8.s:666    .text.matrix_scan:0000000000000108 .Loc.126
     /tmp/ccWVSWB8.s:669    .text.matrix_scan:000000000000010e L0
     /tmp/ccWVSWB8.s:672    .text.matrix_scan:0000000000000110 .Loc.127
     /tmp/ccWVSWB8.s:673    .text.matrix_scan:0000000000000110 .Loc.128
     /tmp/ccWVSWB8.s:677    .text.matrix_scan:0000000000000118 .Loc.129
     /tmp/ccWVSWB8.s:682    .text.matrix_scan:0000000000000124 .Loc.130
     /tmp/ccWVSWB8.s:686    .text.matrix_scan:0000000000000128 .Loc.131
     /tmp/ccWVSWB8.s:698    .text.matrix_scan:000000000000013a .Loc.132
     /tmp/ccWVSWB8.s:699    .text.matrix_scan:000000000000013a .Loc.133
     /tmp/ccWVSWB8.s:702    .text.matrix_scan:000000000000013e .Loc.134
     /tmp/ccWVSWB8.s:705    .text.matrix_scan:0000000000000142 .Loc.135
     /tmp/ccWVSWB8.s:706    .text.matrix_scan:0000000000000142 .Loc.136
     /tmp/ccWVSWB8.s:716    .text.matrix_scan:0000000000000150 .Loc.137
     /tmp/ccWVSWB8.s:721    .text.matrix_scan:0000000000000158 .Loc.138
     /tmp/ccWVSWB8.s:738    .text.matrix_scan:0000000000000168 .Loc.139
     /tmp/ccWVSWB8.s:748    .text.matrix_scan:000000000000016e L0
     /tmp/ccWVSWB8.s:754    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccWVSWB8.s:756    .text.matrix_is_modified:0000000000000000 .Loc.140
     /tmp/ccWVSWB8.s:757    .text.matrix_is_modified:0000000000000000 L0
     /tmp/ccWVSWB8.s:762    .text.matrix_is_modified:0000000000000000 .Loc.141
     /tmp/ccWVSWB8.s:763    .text.matrix_is_modified:0000000000000000 .Loc.142
     /tmp/ccWVSWB8.s:765    .text.matrix_is_modified:0000000000000004 .Loc.143
     /tmp/ccWVSWB8.s:770    .text.matrix_is_modified:000000000000000a L0
     /tmp/ccWVSWB8.s:776    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccWVSWB8.s:779    .text.matrix_is_on:0000000000000000 .Loc.144
     /tmp/ccWVSWB8.s:780    .text.matrix_is_on:0000000000000000 L0
     /tmp/ccWVSWB8.s:785    .text.matrix_is_on:0000000000000000 .Loc.145
     /tmp/ccWVSWB8.s:786    .text.matrix_is_on:0000000000000000 .Loc.146
     /tmp/ccWVSWB8.s:792    .text.matrix_is_on:0000000000000008 .Loc.147
     /tmp/ccWVSWB8.s:795    .text.matrix_is_on:000000000000000c .Loc.148
     /tmp/ccWVSWB8.s:803    .text.matrix_is_on:0000000000000018 .Loc.149
     /tmp/ccWVSWB8.s:808    .text.matrix_is_on:0000000000000020 .Loc.150
     /tmp/ccWVSWB8.s:812    .text.matrix_is_on:0000000000000024 L0
     /tmp/ccWVSWB8.s:818    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccWVSWB8.s:821    .text.matrix_get_row:0000000000000000 .Loc.151
     /tmp/ccWVSWB8.s:822    .text.matrix_get_row:0000000000000000 L0
     /tmp/ccWVSWB8.s:827    .text.matrix_get_row:0000000000000000 .Loc.152
     /tmp/ccWVSWB8.s:828    .text.matrix_get_row:0000000000000000 .Loc.153
     /tmp/ccWVSWB8.s:834    .text.matrix_get_row:0000000000000008 .Loc.154
     /tmp/ccWVSWB8.s:837    .text.matrix_get_row:000000000000000c .Loc.155
     /tmp/ccWVSWB8.s:842    .text.matrix_get_row:0000000000000012 L0
     /tmp/ccWVSWB8.s:848    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccWVSWB8.s:850    .text.matrix_print:0000000000000000 .Loc.156
     /tmp/ccWVSWB8.s:851    .text.matrix_print:0000000000000000 L0
     /tmp/ccWVSWB8.s:856    .text.matrix_print:0000000000000000 .Loc.157
     /tmp/ccWVSWB8.s:857    .text.matrix_print:0000000000000000 .Loc.158
     /tmp/ccWVSWB8.s:858    .text.matrix_print:0000000000000000 .Loc.159
     /tmp/ccWVSWB8.s:859    .text.matrix_print:0000000000000000 .Loc.160
     /tmp/ccWVSWB8.s:861    .text.matrix_print:0000000000000000 .Loc.161
     /tmp/ccWVSWB8.s:863    .text.matrix_print:0000000000000002 L0
     /tmp/ccWVSWB8.s:869    .text.matrix_key_count:0000000000000000 matrix_key_count
     /tmp/ccWVSWB8.s:871    .text.matrix_key_count:0000000000000000 .Loc.162
     /tmp/ccWVSWB8.s:872    .text.matrix_key_count:0000000000000000 L0
     /tmp/ccWVSWB8.s:889    .text.matrix_key_count:0000000000000006 .Loc.163
     /tmp/ccWVSWB8.s:891    .text.matrix_key_count:0000000000000006 .Loc.164
     /tmp/ccWVSWB8.s:893    .text.matrix_key_count:0000000000000006 .Loc.165
     /tmp/ccWVSWB8.s:894    .text.matrix_key_count:0000000000000006 .Loc.166
     /tmp/ccWVSWB8.s:898    .text.matrix_key_count:000000000000000a .Loc.167
     /tmp/ccWVSWB8.s:903    .text.matrix_key_count:000000000000000c .Loc.168
     /tmp/ccWVSWB8.s:904    .text.matrix_key_count:000000000000000c .Loc.169
     /tmp/ccWVSWB8.s:910    .text.matrix_key_count:0000000000000014 .Loc.170
     /tmp/ccWVSWB8.s:913    .text.matrix_key_count:0000000000000018 .Loc.171
     /tmp/ccWVSWB8.s:916    .text.matrix_key_count:000000000000001a .Loc.172
     /tmp/ccWVSWB8.s:917    .text.matrix_key_count:000000000000001a .Loc.173
     /tmp/ccWVSWB8.s:923    .text.matrix_key_count:0000000000000022 .Loc.174
     /tmp/ccWVSWB8.s:924    .text.matrix_key_count:0000000000000022 .Loc.175
     /tmp/ccWVSWB8.s:929    .text.matrix_key_count:0000000000000026 .Loc.176
     /tmp/ccWVSWB8.s:933    .text.matrix_key_count:000000000000002a .Loc.177
     /tmp/ccWVSWB8.s:935    .text.matrix_key_count:000000000000002c L0
     /tmp/ccWVSWB8.s:30     .text.matrix_init_user:0000000000000002 L0
     /tmp/ccWVSWB8.s:47     .text.matrix_init_kb:0000000000000004 L0
     /tmp/ccWVSWB8.s:64     .text.matrix_init_quantum:0000000000000004 L0
     /tmp/ccWVSWB8.s:80     .text.matrix_scan_user:0000000000000002 L0
     /tmp/ccWVSWB8.s:97     .text.matrix_scan_kb:0000000000000004 L0
     /tmp/ccWVSWB8.s:114    .text.matrix_scan_quantum:0000000000000004 L0
     /tmp/ccWVSWB8.s:133    .text.matrix_rows:0000000000000004 L0
     /tmp/ccWVSWB8.s:152    .text.matrix_cols:0000000000000004 L0
     /tmp/ccWVSWB8.s:335    .text.matrix_init:00000000000000ac L0
     /tmp/ccWVSWB8.s:751    .text.matrix_scan:000000000000016e L0
     /tmp/ccWVSWB8.s:773    .text.matrix_is_modified:000000000000000a L0
     /tmp/ccWVSWB8.s:815    .text.matrix_is_on:0000000000000024 L0
     /tmp/ccWVSWB8.s:845    .text.matrix_get_row:0000000000000012 L0
     /tmp/ccWVSWB8.s:866    .text.matrix_print:0000000000000002 L0
     /tmp/ccWVSWB8.s:938    .text.matrix_key_count:000000000000002c L0
                     .debug_frame:0000000000000000 L0
     /tmp/ccWVSWB8.s:219    .text.matrix_init:0000000000000032 .L21
     /tmp/ccWVSWB8.s:216    .text.matrix_init:000000000000002e .L11
     /tmp/ccWVSWB8.s:199    .text.matrix_init:000000000000001c .L10
     /tmp/ccWVSWB8.s:276    .text.matrix_init:000000000000006e .L22
     /tmp/ccWVSWB8.s:273    .text.matrix_init:000000000000006a .L12
     /tmp/ccWVSWB8.s:256    .text.matrix_init:0000000000000058 .L11
     /tmp/ccWVSWB8.s:309    .text.matrix_init:0000000000000092 .L01
     /tmp/ccWVSWB8.s:317    .text.matrix_init:000000000000009e .L02
     /tmp/ccWVSWB8.s:492    .text.matrix_scan:000000000000006a .L23
     /tmp/ccWVSWB8.s:489    .text.matrix_scan:0000000000000066 .L13
     /tmp/ccWVSWB8.s:524    .text.matrix_scan:0000000000000080 .L14
     /tmp/ccWVSWB8.s:581    .text.matrix_scan:00000000000000b4 .L24
     /tmp/ccWVSWB8.s:578    .text.matrix_scan:00000000000000b0 .L15
     /tmp/ccWVSWB8.s:731    .text.matrix_scan:0000000000000168 .L22
     /tmp/ccWVSWB8.s:597    .text.matrix_scan:00000000000000ca .L25
     /tmp/ccWVSWB8.s:594    .text.matrix_scan:00000000000000c6 .L16
     /tmp/ccWVSWB8.s:545    .text.matrix_scan:0000000000000090 .L16
     /tmp/ccWVSWB8.s:662    .text.matrix_scan:0000000000000108 .L17
     /tmp/ccWVSWB8.s:447    .text.matrix_scan:0000000000000042 .L18
     /tmp/ccWVSWB8.s:701    .text.matrix_scan:000000000000013e .L20
     /tmp/ccWVSWB8.s:692    .text.matrix_scan:0000000000000132 .L03
     /tmp/ccWVSWB8.s:600    .text.matrix_scan:00000000000000ce .L15
     /tmp/ccWVSWB8.s:802    .text.matrix_is_on:0000000000000018 .L27
     /tmp/ccWVSWB8.s:901    .text.matrix_key_count:000000000000000c .L31
     /tmp/ccWVSWB8.s:1914   .debug_abbrev:0000000000000000 .Ldebug_abbrev0
     /tmp/ccWVSWB8.s:3672   .debug_ranges:0000000000000000 .Ldebug_ranges0
     /tmp/ccWVSWB8.s:3758   .debug_line:0000000000000000 .Ldebug_line0
     /tmp/ccWVSWB8.s:870    .text.matrix_key_count:0000000000000000 .LFB24
     /tmp/ccWVSWB8.s:936    .text.matrix_key_count:000000000000002c .LFE24
     /tmp/ccWVSWB8.s:2868   .debug_loc:0000000000000000 .LLST21
     /tmp/ccWVSWB8.s:2902   .debug_loc:0000000000000042 .LLST22
     /tmp/ccWVSWB8.s:2895   .debug_loc:000000000000003c .LVUS22
     /tmp/ccWVSWB8.s:2927   .debug_loc:0000000000000074 .LLST23
     /tmp/ccWVSWB8.s:2918   .debug_loc:000000000000006c .LVUS23
     /tmp/ccWVSWB8.s:912    .text.matrix_key_count:0000000000000018 .LVL51
     /tmp/ccWVSWB8.s:849    .text.matrix_print:0000000000000000 .LFB23
     /tmp/ccWVSWB8.s:864    .text.matrix_print:0000000000000002 .LFE23
     /tmp/ccWVSWB8.s:820    .text.matrix_get_row:0000000000000000 .LFB22
     /tmp/ccWVSWB8.s:843    .text.matrix_get_row:0000000000000012 .LFE22
     /tmp/ccWVSWB8.s:2975   .debug_loc:00000000000000cd .LLST20
     /tmp/ccWVSWB8.s:2970   .debug_loc:00000000000000c9 .LVUS20
     /tmp/ccWVSWB8.s:778    .text.matrix_is_on:0000000000000000 .LFB21
     /tmp/ccWVSWB8.s:813    .text.matrix_is_on:0000000000000024 .LFE21
     /tmp/ccWVSWB8.s:2994   .debug_loc:00000000000000f2 .LLST19
     /tmp/ccWVSWB8.s:2989   .debug_loc:00000000000000ee .LVUS19
     /tmp/ccWVSWB8.s:755    .text.matrix_is_modified:0000000000000000 .LFB20
     /tmp/ccWVSWB8.s:771    .text.matrix_is_modified:000000000000000a .LFE20
     /tmp/ccWVSWB8.s:339    .text.matrix_scan:0000000000000000 .LFB19
     /tmp/ccWVSWB8.s:749    .text.matrix_scan:000000000000016e .LFE19
     /tmp/ccWVSWB8.s:3008   .debug_loc:0000000000000113 .LLST5
     /tmp/ccWVSWB8.s:3130   .debug_loc:000000000000020f .LLST6
     /tmp/ccWVSWB8.s:3119   .debug_loc:0000000000000205 .LVUS6
     /tmp/ccWVSWB8.s:3181   .debug_loc:0000000000000275 .LLST7
     /tmp/ccWVSWB8.s:3178   .debug_loc:0000000000000273 .LVUS7
     /tmp/ccWVSWB8.s:450    .text.matrix_scan:0000000000000042 .LBI47
     /tmp/ccWVSWB8.s:3206   .debug_loc:0000000000000299 .LLST8
     /tmp/ccWVSWB8.s:3199   .debug_loc:0000000000000293 .LVUS8
     /tmp/ccWVSWB8.s:3245   .debug_loc:00000000000002e2 .LLST9
     /tmp/ccWVSWB8.s:3240   .debug_loc:00000000000002de .LVUS9
     /tmp/ccWVSWB8.s:468    .text.matrix_scan:0000000000000050 .LBI49
     /tmp/ccWVSWB8.s:3271   .debug_loc:000000000000030e .LLST10
     /tmp/ccWVSWB8.s:3266   .debug_loc:000000000000030a .LVUS10
     /tmp/ccWVSWB8.s:3299   .debug_loc:0000000000000342 .LLST11
     /tmp/ccWVSWB8.s:3294   .debug_loc:000000000000033e .LVUS11
     /tmp/ccWVSWB8.s:513    .text.matrix_scan:000000000000007e .LBI53
     /tmp/ccWVSWB8.s:3314   .debug_loc:0000000000000363 .LLST12
     /tmp/ccWVSWB8.s:3311   .debug_loc:0000000000000361 .LVUS12
     /tmp/ccWVSWB8.s:3326   .debug_loc:000000000000037d .LLST13
     /tmp/ccWVSWB8.s:3323   .debug_loc:000000000000037b .LVUS13
     /tmp/ccWVSWB8.s:3338   .debug_loc:0000000000000397 .LLST14
     /tmp/ccWVSWB8.s:3335   .debug_loc:0000000000000395 .LVUS14
     /tmp/ccWVSWB8.s:3358   .debug_loc:00000000000003b7 .LLST15
     /tmp/ccWVSWB8.s:3347   .debug_loc:00000000000003ad .LVUS15
     /tmp/ccWVSWB8.s:3391   .debug_loc:00000000000003ff .LLST16
     /tmp/ccWVSWB8.s:3384   .debug_loc:00000000000003f9 .LVUS16
     /tmp/ccWVSWB8.s:3417   .debug_loc:0000000000000432 .LLST17
     /tmp/ccWVSWB8.s:3408   .debug_loc:000000000000042a .LVUS17
     /tmp/ccWVSWB8.s:622    .text.matrix_scan:00000000000000e2 .LBI61
     /tmp/ccWVSWB8.s:621    .text.matrix_scan:00000000000000e2 .LBB61
     /tmp/ccWVSWB8.s:640    .text.matrix_scan:00000000000000ee .LBE61
     /tmp/ccWVSWB8.s:3477   .debug_loc:000000000000048e .LLST18
     /tmp/ccWVSWB8.s:3474   .debug_loc:000000000000048c .LVUS18
     /tmp/ccWVSWB8.s:658    .text.matrix_scan:0000000000000100 .LVL38
     /tmp/ccWVSWB8.s:685    .text.matrix_scan:0000000000000128 .LBB69
     /tmp/ccWVSWB8.s:697    .text.matrix_scan:000000000000013a .LBE69
     /tmp/ccWVSWB8.s:681    .text.matrix_scan:0000000000000124 .LVL40
     /tmp/ccWVSWB8.s:704    .text.matrix_scan:0000000000000142 .LVL41
     /tmp/ccWVSWB8.s:156    .text.matrix_init:0000000000000000 .LFB18
     /tmp/ccWVSWB8.s:333    .text.matrix_init:00000000000000ac .LFE18
     /tmp/ccWVSWB8.s:3491   .debug_loc:00000000000004ab .LLST0
     /tmp/ccWVSWB8.s:300    .text.matrix_init:0000000000000088 .LBB27
     /tmp/ccWVSWB8.s:323    .text.matrix_init:00000000000000a4 .LBE27
     /tmp/ccWVSWB8.s:183    .text.matrix_init:0000000000000010 .LBI21
     /tmp/ccWVSWB8.s:182    .text.matrix_init:0000000000000010 .LBB21
     /tmp/ccWVSWB8.s:248    .text.matrix_init:0000000000000054 .LBE21
     /tmp/ccWVSWB8.s:186    .text.matrix_init:0000000000000010 .LBB22
     /tmp/ccWVSWB8.s:247    .text.matrix_init:0000000000000054 .LBE22
     /tmp/ccWVSWB8.s:3521   .debug_loc:00000000000004e2 .LLST1
     /tmp/ccWVSWB8.s:3512   .debug_loc:00000000000004da .LVUS1
     /tmp/ccWVSWB8.s:194    .text.matrix_init:0000000000000018 .LBB23
     /tmp/ccWVSWB8.s:234    .text.matrix_init:0000000000000046 .LBE23
     /tmp/ccWVSWB8.s:3563   .debug_loc:0000000000000535 .LLST2
     /tmp/ccWVSWB8.s:3558   .debug_loc:0000000000000531 .LVUS2
     /tmp/ccWVSWB8.s:249    .text.matrix_init:0000000000000054 .LBB24
     /tmp/ccWVSWB8.s:299    .text.matrix_init:0000000000000088 .LBE24
     /tmp/ccWVSWB8.s:250    .text.matrix_init:0000000000000054 .LBB25
     /tmp/ccWVSWB8.s:298    .text.matrix_init:0000000000000088 .LBE25
     /tmp/ccWVSWB8.s:3582   .debug_loc:000000000000055a .LLST3
     /tmp/ccWVSWB8.s:3575   .debug_loc:0000000000000554 .LVUS3
     /tmp/ccWVSWB8.s:251    .text.matrix_init:0000000000000054 .LBB26
     /tmp/ccWVSWB8.s:291    .text.matrix_init:0000000000000082 .LBE26
     /tmp/ccWVSWB8.s:3619   .debug_loc:00000000000005a1 .LLST4
     /tmp/ccWVSWB8.s:3614   .debug_loc:000000000000059d .LVUS4
     /tmp/ccWVSWB8.s:331    .text.matrix_init:00000000000000ac .LVL18
     /tmp/ccWVSWB8.s:137    .text.matrix_cols:0000000000000000 .LFB17
     /tmp/ccWVSWB8.s:150    .text.matrix_cols:0000000000000004 .LFE17
     /tmp/ccWVSWB8.s:118    .text.matrix_rows:0000000000000000 .LFB16
     /tmp/ccWVSWB8.s:131    .text.matrix_rows:0000000000000004 .LFE16
     /tmp/ccWVSWB8.s:16     .text.matrix_init_user:0000000000000000 .LFB14
     /tmp/ccWVSWB8.s:27     .text.matrix_init_user:0000000000000002 .LFE14
     /tmp/ccWVSWB8.s:84     .text.matrix_scan_kb:0000000000000000 .LFB13
     /tmp/ccWVSWB8.s:95     .text.matrix_scan_kb:0000000000000004 .LFE13
     /tmp/ccWVSWB8.s:93     .text.matrix_scan_kb:0000000000000004 .LVL2
     /tmp/ccWVSWB8.s:34     .text.matrix_init_kb:0000000000000000 .LFB12
     /tmp/ccWVSWB8.s:45     .text.matrix_init_kb:0000000000000004 .LFE12
     /tmp/ccWVSWB8.s:43     .text.matrix_init_kb:0000000000000004 .LVL0
     /tmp/ccWVSWB8.s:101    .text.matrix_scan_quantum:0000000000000000 .LFB11
     /tmp/ccWVSWB8.s:112    .text.matrix_scan_quantum:0000000000000004 .LFE11
     /tmp/ccWVSWB8.s:110    .text.matrix_scan_quantum:0000000000000004 .LVL3
     /tmp/ccWVSWB8.s:51     .text.matrix_init_quantum:0000000000000000 .LFB10
     /tmp/ccWVSWB8.s:62     .text.matrix_init_quantum:0000000000000004 .LFE10
     /tmp/ccWVSWB8.s:60     .text.matrix_init_quantum:0000000000000004 .LVL1
     /tmp/ccWVSWB8.s:874    .text.matrix_key_count:0000000000000002 .LCFI19
     /tmp/ccWVSWB8.s:878    .text.matrix_key_count:0000000000000004 .LCFI20
     /tmp/ccWVSWB8.s:882    .text.matrix_key_count:0000000000000006 .LCFI21
     /tmp/ccWVSWB8.s:890    .text.matrix_key_count:0000000000000006 .LVL48
     /tmp/ccWVSWB8.s:900    .text.matrix_key_count:000000000000000c .LVL49
     /tmp/ccWVSWB8.s:928    .text.matrix_key_count:0000000000000026 .LVL53
     /tmp/ccWVSWB8.s:909    .text.matrix_key_count:0000000000000014 .LVL50
     /tmp/ccWVSWB8.s:915    .text.matrix_key_count:000000000000001a .LVL52
     /tmp/ccWVSWB8.s:932    .text.matrix_key_count:000000000000002a .LVL54
     /tmp/ccWVSWB8.s:819    .text.matrix_get_row:0000000000000000 .LVL46
     /tmp/ccWVSWB8.s:833    .text.matrix_get_row:0000000000000008 .LVL47
     /tmp/ccWVSWB8.s:777    .text.matrix_is_on:0000000000000000 .LVL44
     /tmp/ccWVSWB8.s:791    .text.matrix_is_on:0000000000000008 .LVL45
     /tmp/ccWVSWB8.s:343    .text.matrix_scan:0000000000000002 .LCFI2
     /tmp/ccWVSWB8.s:347    .text.matrix_scan:0000000000000004 .LCFI3
     /tmp/ccWVSWB8.s:351    .text.matrix_scan:0000000000000006 .LCFI4
     /tmp/ccWVSWB8.s:355    .text.matrix_scan:0000000000000008 .LCFI5
     /tmp/ccWVSWB8.s:359    .text.matrix_scan:000000000000000a .LCFI6
     /tmp/ccWVSWB8.s:363    .text.matrix_scan:000000000000000c .LCFI7
     /tmp/ccWVSWB8.s:367    .text.matrix_scan:000000000000000e .LCFI8
     /tmp/ccWVSWB8.s:371    .text.matrix_scan:0000000000000010 .LCFI9
     /tmp/ccWVSWB8.s:375    .text.matrix_scan:0000000000000012 .LCFI10
     /tmp/ccWVSWB8.s:379    .text.matrix_scan:0000000000000014 .LCFI11
     /tmp/ccWVSWB8.s:383    .text.matrix_scan:0000000000000016 .LCFI12
     /tmp/ccWVSWB8.s:387    .text.matrix_scan:0000000000000018 .LCFI13
     /tmp/ccWVSWB8.s:391    .text.matrix_scan:000000000000001a .LCFI14
     /tmp/ccWVSWB8.s:395    .text.matrix_scan:000000000000001c .LCFI15
     /tmp/ccWVSWB8.s:399    .text.matrix_scan:000000000000001e .LCFI16
     /tmp/ccWVSWB8.s:403    .text.matrix_scan:0000000000000020 .LCFI17
     /tmp/ccWVSWB8.s:407    .text.matrix_scan:0000000000000022 .LCFI18
     /tmp/ccWVSWB8.s:417    .text.matrix_scan:0000000000000022 .LVL19
     /tmp/ccWVSWB8.s:446    .text.matrix_scan:0000000000000042 .LVL20
     /tmp/ccWVSWB8.s:476    .text.matrix_scan:0000000000000056 .LVL23
     /tmp/ccWVSWB8.s:665    .text.matrix_scan:0000000000000108 .LVL39
     /tmp/ccWVSWB8.s:715    .text.matrix_scan:0000000000000150 .LVL42
     /tmp/ccWVSWB8.s:730    .text.matrix_scan:0000000000000168 .LVL43
     /tmp/ccWVSWB8.s:637    .text.matrix_scan:00000000000000ee .LVL37
     /tmp/ccWVSWB8.s:459    .text.matrix_scan:000000000000004a .LVL21
     /tmp/ccWVSWB8.s:466    .text.matrix_scan:0000000000000050 .LVL22
     /tmp/ccWVSWB8.s:507    .text.matrix_scan:000000000000007e .LVL26
     /tmp/ccWVSWB8.s:485    .text.matrix_scan:0000000000000062 .LVL24
     /tmp/ccWVSWB8.s:499    .text.matrix_scan:0000000000000074 .LVL25
     /tmp/ccWVSWB8.s:526    .text.matrix_scan:0000000000000084 .LVL27
     /tmp/ccWVSWB8.s:544    .text.matrix_scan:0000000000000090 .LVL28
     /tmp/ccWVSWB8.s:609    .text.matrix_scan:00000000000000d8 .LVL33
     /tmp/ccWVSWB8.s:613    .text.matrix_scan:00000000000000dc .LVL34
     /tmp/ccWVSWB8.s:556    .text.matrix_scan:0000000000000096 .LVL29
     /tmp/ccWVSWB8.s:574    .text.matrix_scan:00000000000000ac .LVL31
     /tmp/ccWVSWB8.s:631    .text.matrix_scan:00000000000000e8 .LVL36
     /tmp/ccWVSWB8.s:566    .text.matrix_scan:00000000000000a4 .LVL30
     /tmp/ccWVSWB8.s:585    .text.matrix_scan:00000000000000ba .LVL32
     /tmp/ccWVSWB8.s:620    .text.matrix_scan:00000000000000e2 .LVL35
     /tmp/ccWVSWB8.s:160    .text.matrix_init:0000000000000002 .LCFI0
     /tmp/ccWVSWB8.s:164    .text.matrix_init:0000000000000004 .LCFI1
     /tmp/ccWVSWB8.s:188    .text.matrix_init:0000000000000010 .LVL4
     /tmp/ccWVSWB8.s:198    .text.matrix_init:000000000000001c .LVL5
     /tmp/ccWVSWB8.s:203    .text.matrix_init:000000000000001e .LVL6
     /tmp/ccWVSWB8.s:236    .text.matrix_init:0000000000000046 .LVL9
     /tmp/ccWVSWB8.s:243    .text.matrix_init:0000000000000050 .LVL10
     /tmp/ccWVSWB8.s:212    .text.matrix_init:000000000000002a .LVL7
     /tmp/ccWVSWB8.s:228    .text.matrix_init:0000000000000040 .LVL8
     /tmp/ccWVSWB8.s:255    .text.matrix_init:0000000000000058 .LVL11
     /tmp/ccWVSWB8.s:260    .text.matrix_init:000000000000005a .LVL12
     /tmp/ccWVSWB8.s:293    .text.matrix_init:0000000000000082 .LVL15
     /tmp/ccWVSWB8.s:306    .text.matrix_init:0000000000000090 .LVL16
     /tmp/ccWVSWB8.s:269    .text.matrix_init:0000000000000066 .LVL13
     /tmp/ccWVSWB8.s:285    .text.matrix_init:000000000000007c .LVL14
     /tmp/ccWVSWB8.s:977    .debug_info:0000000000000000 .Ldebug_info0
     /tmp/ccWVSWB8.s:68     .text.matrix_scan_user:0000000000000000 .LFB31
     /tmp/ccWVSWB8.s:78     .text.matrix_scan_user:0000000000000002 .LFE31
     /tmp/ccWVSWB8.s:415    .text.matrix_scan:0000000000000022 .LBB45
     /tmp/ccWVSWB8.s:671    .text.matrix_scan:0000000000000110 .LBE45
     /tmp/ccWVSWB8.s:732    .text.matrix_scan:0000000000000168 .LBB70
     /tmp/ccWVSWB8.s:747    .text.matrix_scan:000000000000016e .LBE70
     /tmp/ccWVSWB8.s:431    .text.matrix_scan:000000000000003a .LBB46
     /tmp/ccWVSWB8.s:663    .text.matrix_scan:0000000000000108 .LBE46
     /tmp/ccWVSWB8.s:733    .text.matrix_scan:0000000000000168 .LBB68
     /tmp/ccWVSWB8.s:746    .text.matrix_scan:000000000000016e .LBE68
     /tmp/ccWVSWB8.s:432    .text.matrix_scan:000000000000003a .LBB47
     /tmp/ccWVSWB8.s:442    .text.matrix_scan:000000000000003e .LBE47
     /tmp/ccWVSWB8.s:449    .text.matrix_scan:0000000000000042 .LBB66
     /tmp/ccWVSWB8.s:644    .text.matrix_scan:00000000000000ee .LBE66
     /tmp/ccWVSWB8.s:734    .text.matrix_scan:0000000000000168 .LBB67
     /tmp/ccWVSWB8.s:745    .text.matrix_scan:000000000000016e .LBE67
     /tmp/ccWVSWB8.s:434    .text.matrix_scan:000000000000003a .LBB49
     /tmp/ccWVSWB8.s:440    .text.matrix_scan:000000000000003e .LBE49
     /tmp/ccWVSWB8.s:467    .text.matrix_scan:0000000000000050 .LBB52
     /tmp/ccWVSWB8.s:510    .text.matrix_scan:000000000000007e .LBE52
     /tmp/ccWVSWB8.s:512    .text.matrix_scan:000000000000007e .LBB53
     /tmp/ccWVSWB8.s:529    .text.matrix_scan:0000000000000084 .LBE53
     /tmp/ccWVSWB8.s:539    .text.matrix_scan:000000000000008c .LBB59
     /tmp/ccWVSWB8.s:548    .text.matrix_scan:0000000000000090 .LBE59
     /tmp/ccWVSWB8.s:531    .text.matrix_scan:0000000000000084 .LBB56
     /tmp/ccWVSWB8.s:538    .text.matrix_scan:000000000000008c .LBE56
     /tmp/ccWVSWB8.s:549    .text.matrix_scan:0000000000000090 .LBB60
     /tmp/ccWVSWB8.s:618    .text.matrix_scan:00000000000000e2 .LBE60
     /tmp/ccWVSWB8.s:736    .text.matrix_scan:0000000000000168 .LBB63
     /tmp/ccWVSWB8.s:743    .text.matrix_scan:000000000000016e .LBE63
     /tmp/ccWVSWB8.s:550    .text.matrix_scan:0000000000000090 .LBB57
     /tmp/ccWVSWB8.s:607    .text.matrix_scan:00000000000000d8 .LBE57
     /tmp/ccWVSWB8.s:737    .text.matrix_scan:0000000000000168 .LBB58
     /tmp/ccWVSWB8.s:742    .text.matrix_scan:000000000000016e .LBE58
     /tmp/ccWVSWB8.s:892    .text.matrix_key_count:0000000000000006 .LBB71
     /tmp/ccWVSWB8.s:897    .text.matrix_key_count:000000000000000a .LBE71
     /tmp/ccWVSWB8.s:902    .text.matrix_key_count:000000000000000c .LBB72
     /tmp/ccWVSWB8.s:922    .text.matrix_key_count:0000000000000022 .LBE72

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop16
__do_copy_data
__do_clear_bss
